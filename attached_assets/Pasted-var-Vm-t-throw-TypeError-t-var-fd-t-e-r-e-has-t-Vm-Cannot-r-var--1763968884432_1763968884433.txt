var Vm = t => {
    throw TypeError(t)
}
;
var fd = (t, e, r) => e.has(t) || Vm("Cannot " + r);
var E = (t, e, r) => (fd(t, e, "read from private field"),
r ? r.call(t) : e.get(t))
  , ee = (t, e, r) => e.has(t) ? Vm("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r)
  , z = (t, e, r, n) => (fd(t, e, "write to private field"),
n ? n.call(t, r) : e.set(t, r),
r)
  , de = (t, e, r) => (fd(t, e, "access private method"),
r);
var El = (t, e, r, n) => ({
    set _(s) {
        z(t, e, s, r)
    },
    get _() {
        return E(t, e, n)
    }
});
function Wy(t, e) {
    for (var r = 0; r < e.length; r++) {
        const n = e[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const s in n)
                if (s !== "default" && !(s in t)) {
                    const i = Object.getOwnPropertyDescriptor(n, s);
                    i && Object.defineProperty(t, s, i.get ? i : {
                        enumerable: !0,
                        get: () => n[s]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        n(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function r(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity),
        s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function n(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const i = r(s);
        fetch(s.href, i)
    }
}
)();
function Hy(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
function UE(t) {
    if (t.__esModule)
        return t;
    var e = t.default;
    if (typeof e == "function") {
        var r = function n() {
            return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        r.prototype = e.prototype
    } else
        r = {};
    return Object.defineProperty(r, "__esModule", {
        value: !0
    }),
    Object.keys(t).forEach(function(n) {
        var s = Object.getOwnPropertyDescriptor(t, n);
        Object.defineProperty(r, n, s.get ? s : {
            enumerable: !0,
            get: function() {
                return t[n]
            }
        })
    }),
    r
}
var qy = {
    exports: {}
}
  , Tc = {}
  , Ky = {
    exports: {}
}
  , he = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var al = Symbol.for("react.element")
  , VE = Symbol.for("react.portal")
  , BE = Symbol.for("react.fragment")
  , zE = Symbol.for("react.strict_mode")
  , WE = Symbol.for("react.profiler")
  , HE = Symbol.for("react.provider")
  , qE = Symbol.for("react.context")
  , KE = Symbol.for("react.forward_ref")
  , GE = Symbol.for("react.suspense")
  , QE = Symbol.for("react.memo")
  , ZE = Symbol.for("react.lazy")
  , Bm = Symbol.iterator;
function YE(t) {
    return t === null || typeof t != "object" ? null : (t = Bm && t[Bm] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Gy = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , Qy = Object.assign
  , Zy = {};
function bo(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = Zy,
    this.updater = r || Gy
}
bo.prototype.isReactComponent = {};
bo.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
}
;
bo.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function Yy() {}
Yy.prototype = bo.prototype;
function Zh(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = Zy,
    this.updater = r || Gy
}
var Yh = Zh.prototype = new Yy;
Yh.constructor = Zh;
Qy(Yh, bo.prototype);
Yh.isPureReactComponent = !0;
var zm = Array.isArray
  , Jy = Object.prototype.hasOwnProperty
  , Jh = {
    current: null
}
  , Xy = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function ew(t, e, r) {
    var n, s = {}, i = null, o = null;
    if (e != null)
        for (n in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (i = "" + e.key),
        e)
            Jy.call(e, n) && !Xy.hasOwnProperty(n) && (s[n] = e[n]);
    var a = arguments.length - 2;
    if (a === 1)
        s.children = r;
    else if (1 < a) {
        for (var l = Array(a), u = 0; u < a; u++)
            l[u] = arguments[u + 2];
        s.children = l
    }
    if (t && t.defaultProps)
        for (n in a = t.defaultProps,
        a)
            s[n] === void 0 && (s[n] = a[n]);
    return {
        $$typeof: al,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: Jh.current
    }
}
function JE(t, e) {
    return {
        $$typeof: al,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function Xh(t) {
    return typeof t == "object" && t !== null && t.$$typeof === al
}
function XE(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(r) {
        return e[r]
    })
}
var Wm = /\/+/g;
function hd(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? XE("" + t.key) : e.toString(36)
}
function lu(t, e, r, n, s) {
    var i = typeof t;
    (i === "undefined" || i === "boolean") && (t = null);
    var o = !1;
    if (t === null)
        o = !0;
    else
        switch (i) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case al:
            case VE:
                o = !0
            }
        }
    if (o)
        return o = t,
        s = s(o),
        t = n === "" ? "." + hd(o, 0) : n,
        zm(s) ? (r = "",
        t != null && (r = t.replace(Wm, "$&/") + "/"),
        lu(s, e, r, "", function(u) {
            return u
        })) : s != null && (Xh(s) && (s = JE(s, r + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(Wm, "$&/") + "/") + t)),
        e.push(s)),
        1;
    if (o = 0,
    n = n === "" ? "." : n + ":",
    zm(t))
        for (var a = 0; a < t.length; a++) {
            i = t[a];
            var l = n + hd(i, a);
            o += lu(i, e, r, l, s)
        }
    else if (l = YE(t),
    typeof l == "function")
        for (t = l.call(t),
        a = 0; !(i = t.next()).done; )
            i = i.value,
            l = n + hd(i, a++),
            o += lu(i, e, r, l, s);
    else if (i === "object")
        throw e = String(t),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function kl(t, e, r) {
    if (t == null)
        return t;
    var n = []
      , s = 0;
    return lu(t, n, "", "", function(i) {
        return e.call(r, i, s++)
    }),
    n
}
function ek(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(),
        e.then(function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = r)
        }, function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = r)
        }),
        t._status === -1 && (t._status = 0,
        t._result = e)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var _t = {
    current: null
}
  , uu = {
    transition: null
}
  , tk = {
    ReactCurrentDispatcher: _t,
    ReactCurrentBatchConfig: uu,
    ReactCurrentOwner: Jh
};
function tw() {
    throw Error("act(...) is not supported in production builds of React.")
}
he.Children = {
    map: kl,
    forEach: function(t, e, r) {
        kl(t, function() {
            e.apply(this, arguments)
        }, r)
    },
    count: function(t) {
        var e = 0;
        return kl(t, function() {
            e++
        }),
        e
    },
    toArray: function(t) {
        return kl(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!Xh(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
he.Component = bo;
he.Fragment = BE;
he.Profiler = WE;
he.PureComponent = Zh;
he.StrictMode = zE;
he.Suspense = GE;
he.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tk;
he.act = tw;
he.cloneElement = function(t, e, r) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var n = Qy({}, t.props)
      , s = t.key
      , i = t.ref
      , o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (i = e.ref,
        o = Jh.current),
        e.key !== void 0 && (s = "" + e.key),
        t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
        for (l in e)
            Jy.call(e, l) && !Xy.hasOwnProperty(l) && (n[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        n.children = r;
    else if (1 < l) {
        a = Array(l);
        for (var u = 0; u < l; u++)
            a[u] = arguments[u + 2];
        n.children = a
    }
    return {
        $$typeof: al,
        type: t.type,
        key: s,
        ref: i,
        props: n,
        _owner: o
    }
}
;
he.createContext = function(t) {
    return t = {
        $$typeof: qE,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: HE,
        _context: t
    },
    t.Consumer = t
}
;
he.createElement = ew;
he.createFactory = function(t) {
    var e = ew.bind(null, t);
    return e.type = t,
    e
}
;
he.createRef = function() {
    return {
        current: null
    }
}
;
he.forwardRef = function(t) {
    return {
        $$typeof: KE,
        render: t
    }
}
;
he.isValidElement = Xh;
he.lazy = function(t) {
    return {
        $$typeof: ZE,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: ek
    }
}
;
he.memo = function(t, e) {
    return {
        $$typeof: QE,
        type: t,
        compare: e === void 0 ? null : e
    }
}
;
he.startTransition = function(t) {
    var e = uu.transition;
    uu.transition = {};
    try {
        t()
    } finally {
        uu.transition = e
    }
}
;
he.unstable_act = tw;
he.useCallback = function(t, e) {
    return _t.current.useCallback(t, e)
}
;
he.useContext = function(t) {
    return _t.current.useContext(t)
}
;
he.useDebugValue = function() {}
;
he.useDeferredValue = function(t) {
    return _t.current.useDeferredValue(t)
}
;
he.useEffect = function(t, e) {
    return _t.current.useEffect(t, e)
}
;
he.useId = function() {
    return _t.current.useId()
}
;
he.useImperativeHandle = function(t, e, r) {
    return _t.current.useImperativeHandle(t, e, r)
}
;
he.useInsertionEffect = function(t, e) {
    return _t.current.useInsertionEffect(t, e)
}
;
he.useLayoutEffect = function(t, e) {
    return _t.current.useLayoutEffect(t, e)
}
;
he.useMemo = function(t, e) {
    return _t.current.useMemo(t, e)
}
;
he.useReducer = function(t, e, r) {
    return _t.current.useReducer(t, e, r)
}
;
he.useRef = function(t) {
    return _t.current.useRef(t)
}
;
he.useState = function(t) {
    return _t.current.useState(t)
}
;
he.useSyncExternalStore = function(t, e, r) {
    return _t.current.useSyncExternalStore(t, e, r)
}
;
he.useTransition = function() {
    return _t.current.useTransition()
}
;
he.version = "18.3.1";
Ky.exports = he;
var b = Ky.exports;
const le = Hy(b)
  , rw = Wy({
    __proto__: null,
    default: le
}, [b]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rk = b
  , nk = Symbol.for("react.element")
  , sk = Symbol.for("react.fragment")
  , ik = Object.prototype.hasOwnProperty
  , ok = rk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , ak = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function nw(t, e, r) {
    var n, s = {}, i = null, o = null;
    r !== void 0 && (i = "" + r),
    e.key !== void 0 && (i = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (n in e)
        ik.call(e, n) && !ak.hasOwnProperty(n) && (s[n] = e[n]);
    if (t && t.defaultProps)
        for (n in e = t.defaultProps,
        e)
            s[n] === void 0 && (s[n] = e[n]);
    return {
        $$typeof: nk,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: ok.current
    }
}
Tc.Fragment = sk;
Tc.jsx = nw;
Tc.jsxs = nw;
qy.exports = Tc;
var y = qy.exports
  , sw = {
    exports: {}
}
  , Ht = {}
  , iw = {
    exports: {}
}
  , ow = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(A, V) {
        var Y = A.length;
        A.push(V);
        e: for (; 0 < Y; ) {
            var ae = Y - 1 >>> 1
              , Ee = A[ae];
            if (0 < s(Ee, V))
                A[ae] = V,
                A[Y] = Ee,
                Y = ae;
            else
                break e
        }
    }
    function r(A) {
        return A.length === 0 ? null : A[0]
    }
    function n(A) {
        if (A.length === 0)
            return null;
        var V = A[0]
          , Y = A.pop();
        if (Y !== V) {
            A[0] = Y;
            e: for (var ae = 0, Ee = A.length, xt = Ee >>> 1; ae < xt; ) {
                var St = 2 * (ae + 1) - 1
                  , pn = A[St]
                  , nr = St + 1
                  , kr = A[nr];
                if (0 > s(pn, Y))
                    nr < Ee && 0 > s(kr, pn) ? (A[ae] = kr,
                    A[nr] = Y,
                    ae = nr) : (A[ae] = pn,
                    A[St] = Y,
                    ae = St);
                else if (nr < Ee && 0 > s(kr, Y))
                    A[ae] = kr,
                    A[nr] = Y,
                    ae = nr;
                else
                    break e
            }
        }
        return V
    }
    function s(A, V) {
        var Y = A.sortIndex - V.sortIndex;
        return Y !== 0 ? Y : A.id - V.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        t.unstable_now = function() {
            return i.now()
        }
    } else {
        var o = Date
          , a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , u = []
      , c = 1
      , d = null
      , f = 3
      , p = !1
      , g = !1
      , h = !1
      , w = typeof setTimeout == "function" ? setTimeout : null
      , v = typeof clearTimeout == "function" ? clearTimeout : null
      , m = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function _(A) {
        for (var V = r(u); V !== null; ) {
            if (V.callback === null)
                n(u);
            else if (V.startTime <= A)
                n(u),
                V.sortIndex = V.expirationTime,
                e(l, V);
            else
                break;
            V = r(u)
        }
    }
    function x(A) {
        if (h = !1,
        _(A),
        !g)
            if (r(l) !== null)
                g = !0,
                te(k);
            else {
                var V = r(u);
                V !== null && oe(x, V.startTime - A)
            }
    }
    function k(A, V) {
        g = !1,
        h && (h = !1,
        v(P),
        P = -1),
        p = !0;
        var Y = f;
        try {
            for (_(V),
            d = r(l); d !== null && (!(d.expirationTime > V) || A && !X()); ) {
                var ae = d.callback;
                if (typeof ae == "function") {
                    d.callback = null,
                    f = d.priorityLevel;
                    var Ee = ae(d.expirationTime <= V);
                    V = t.unstable_now(),
                    typeof Ee == "function" ? d.callback = Ee : d === r(l) && n(l),
                    _(V)
                } else
                    n(l);
                d = r(l)
            }
            if (d !== null)
                var xt = !0;
            else {
                var St = r(u);
                St !== null && oe(x, St.startTime - V),
                xt = !1
            }
            return xt
        } finally {
            d = null,
            f = Y,
            p = !1
        }
    }
    var T = !1
      , C = null
      , P = -1
      , j = 5
      , $ = -1;
    function X() {
        return !(t.unstable_now() - $ < j)
    }
    function D() {
        if (C !== null) {
            var A = t.unstable_now();
            $ = A;
            var V = !0;
            try {
                V = C(!0, A)
            } finally {
                V ? H() : (T = !1,
                C = null)
            }
        } else
            T = !1
    }
    var H;
    if (typeof m == "function")
        H = function() {
            m(D)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var M = new MessageChannel
          , ie = M.port2;
        M.port1.onmessage = D,
        H = function() {
            ie.postMessage(null)
        }
    } else
        H = function() {
            w(D, 0)
        }
        ;
    function te(A) {
        C = A,
        T || (T = !0,
        H())
    }
    function oe(A, V) {
        P = w(function() {
            A(t.unstable_now())
        }, V)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(A) {
        A.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        g || p || (g = !0,
        te(k))
    }
    ,
    t.unstable_forceFrameRate = function(A) {
        0 > A || 125 < A ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : j = 0 < A ? Math.floor(1e3 / A) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return f
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return r(l)
    }
    ,
    t.unstable_next = function(A) {
        switch (f) {
        case 1:
        case 2:
        case 3:
            var V = 3;
            break;
        default:
            V = f
        }
        var Y = f;
        f = V;
        try {
            return A()
        } finally {
            f = Y
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(A, V) {
        switch (A) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            A = 3
        }
        var Y = f;
        f = A;
        try {
            return V()
        } finally {
            f = Y
        }
    }
    ,
    t.unstable_scheduleCallback = function(A, V, Y) {
        var ae = t.unstable_now();
        switch (typeof Y == "object" && Y !== null ? (Y = Y.delay,
        Y = typeof Y == "number" && 0 < Y ? ae + Y : ae) : Y = ae,
        A) {
        case 1:
            var Ee = -1;
            break;
        case 2:
            Ee = 250;
            break;
        case 5:
            Ee = 1073741823;
            break;
        case 4:
            Ee = 1e4;
            break;
        default:
            Ee = 5e3
        }
        return Ee = Y + Ee,
        A = {
            id: c++,
            callback: V,
            priorityLevel: A,
            startTime: Y,
            expirationTime: Ee,
            sortIndex: -1
        },
        Y > ae ? (A.sortIndex = Y,
        e(u, A),
        r(l) === null && A === r(u) && (h ? (v(P),
        P = -1) : h = !0,
        oe(x, Y - ae))) : (A.sortIndex = Ee,
        e(l, A),
        g || p || (g = !0,
        te(k))),
        A
    }
    ,
    t.unstable_shouldYield = X,
    t.unstable_wrapCallback = function(A) {
        var V = f;
        return function() {
            var Y = f;
            f = V;
            try {
                return A.apply(this, arguments)
            } finally {
                f = Y
            }
        }
    }
}
)(ow);
iw.exports = ow;
var lk = iw.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uk = b
  , Wt = lk;
function I(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++)
        e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var aw = new Set
  , wa = {};
function Gs(t, e) {
    oo(t, e),
    oo(t + "Capture", e)
}
function oo(t, e) {
    for (wa[t] = e,
    t = 0; t < e.length; t++)
        aw.add(e[t])
}
var nn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , pf = Object.prototype.hasOwnProperty
  , ck = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , Hm = {}
  , qm = {};
function dk(t) {
    return pf.call(qm, t) ? !0 : pf.call(Hm, t) ? !1 : ck.test(t) ? qm[t] = !0 : (Hm[t] = !0,
    !1)
}
function fk(t, e, r, n) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return n ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function hk(t, e, r, n) {
    if (e === null || typeof e > "u" || fk(t, e, r, n))
        return !0;
    if (n)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function bt(t, e, r, n, s, i, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = n,
    this.attributeNamespace = s,
    this.mustUseProperty = r,
    this.propertyName = t,
    this.type = e,
    this.sanitizeURL = i,
    this.removeEmptyString = o
}
var nt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    nt[t] = new bt(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var e = t[0];
    nt[e] = new bt(e,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    nt[t] = new bt(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    nt[t] = new bt(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    nt[t] = new bt(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    nt[t] = new bt(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    nt[t] = new bt(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    nt[t] = new bt(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    nt[t] = new bt(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var ep = /[\-:]([a-z])/g;
function tp(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(ep, tp);
    nt[e] = new bt(e,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(ep, tp);
    nt[e] = new bt(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(ep, tp);
    nt[e] = new bt(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    nt[t] = new bt(t,1,!1,t.toLowerCase(),null,!1,!1)
});
nt.xlinkHref = new bt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    nt[t] = new bt(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function rp(t, e, r, n) {
    var s = nt.hasOwnProperty(e) ? nt[e] : null;
    (s !== null ? s.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (hk(e, r, s, n) && (r = null),
    n || s === null ? dk(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : s.mustUseProperty ? t[s.propertyName] = r === null ? s.type === 3 ? !1 : "" : r : (e = s.attributeName,
    n = s.attributeNamespace,
    r === null ? t.removeAttribute(e) : (s = s.type,
    r = s === 3 || s === 4 && r === !0 ? "" : "" + r,
    n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))))
}
var fn = uk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Cl = Symbol.for("react.element")
  , wi = Symbol.for("react.portal")
  , _i = Symbol.for("react.fragment")
  , np = Symbol.for("react.strict_mode")
  , mf = Symbol.for("react.profiler")
  , lw = Symbol.for("react.provider")
  , uw = Symbol.for("react.context")
  , sp = Symbol.for("react.forward_ref")
  , gf = Symbol.for("react.suspense")
  , vf = Symbol.for("react.suspense_list")
  , ip = Symbol.for("react.memo")
  , xn = Symbol.for("react.lazy")
  , cw = Symbol.for("react.offscreen")
  , Km = Symbol.iterator;
function Mo(t) {
    return t === null || typeof t != "object" ? null : (t = Km && t[Km] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var Me = Object.assign, pd;
function Yo(t) {
    if (pd === void 0)
        try {
            throw Error()
        } catch (r) {
            var e = r.stack.trim().match(/\n( *(at )?)/);
            pd = e && e[1] || ""
        }
    return `
` + pd + t
}
var md = !1;
function gd(t, e) {
    if (!t || md)
        return "";
    md = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (u) {
                    var n = u
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (u) {
                    n = u
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (u) {
                n = u
            }
            t()
        }
    } catch (u) {
        if (u && n && typeof u.stack == "string") {
            for (var s = u.stack.split(`
`), i = n.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (s[o] !== i[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || s[o] !== i[a]) {
                                var l = `
` + s[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        md = !1,
        Error.prepareStackTrace = r
    }
    return (t = t ? t.displayName || t.name : "") ? Yo(t) : ""
}
function pk(t) {
    switch (t.tag) {
    case 5:
        return Yo(t.type);
    case 16:
        return Yo("Lazy");
    case 13:
        return Yo("Suspense");
    case 19:
        return Yo("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = gd(t.type, !1),
        t;
    case 11:
        return t = gd(t.type.render, !1),
        t;
    case 1:
        return t = gd(t.type, !0),
        t;
    default:
        return ""
    }
}
function yf(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case _i:
        return "Fragment";
    case wi:
        return "Portal";
    case mf:
        return "Profiler";
    case np:
        return "StrictMode";
    case gf:
        return "Suspense";
    case vf:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case uw:
            return (t.displayName || "Context") + ".Consumer";
        case lw:
            return (t._context.displayName || "Context") + ".Provider";
        case sp:
            var e = t.render;
            return t = t.displayName,
            t || (t = e.displayName || e.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case ip:
            return e = t.displayName || null,
            e !== null ? e : yf(t.type) || "Memo";
        case xn:
            e = t._payload,
            t = t._init;
            try {
                return yf(t(e))
            } catch {}
        }
    return null
}
function mk(t) {
    var e = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = e.render,
        t = t.displayName || t.name || "",
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return yf(e);
    case 8:
        return e === np ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Kn(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function dw(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function gk(t) {
    var e = dw(t) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
      , n = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var s = r.get
          , i = r.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return s.call(this)
            },
            set: function(o) {
                n = "" + o,
                i.call(this, o)
            }
        }),
        Object.defineProperty(t, e, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return n
            },
            setValue: function(o) {
                n = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[e]
            }
        }
    }
}
function Tl(t) {
    t._valueTracker || (t._valueTracker = gk(t))
}
function fw(t) {
    if (!t)
        return !1;
    var e = t._valueTracker;
    if (!e)
        return !0;
    var r = e.getValue()
      , n = "";
    return t && (n = dw(t) ? t.checked ? "true" : "false" : t.value),
    t = n,
    t !== r ? (e.setValue(t),
    !0) : !1
}
function Ou(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function wf(t, e) {
    var r = e.checked;
    return Me({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? t._wrapperState.initialChecked
    })
}
function Gm(t, e) {
    var r = e.defaultValue == null ? "" : e.defaultValue
      , n = e.checked != null ? e.checked : e.defaultChecked;
    r = Kn(e.value != null ? e.value : r),
    t._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function hw(t, e) {
    e = e.checked,
    e != null && rp(t, "checked", e, !1)
}
function _f(t, e) {
    hw(t, e);
    var r = Kn(e.value)
      , n = e.type;
    if (r != null)
        n === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
    else if (n === "submit" || n === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? bf(t, e.type, r) : e.hasOwnProperty("defaultValue") && bf(t, e.type, Kn(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}
function Qm(t, e, r) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var n = e.type;
        if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + t._wrapperState.initialValue,
        r || e === t.value || (t.value = e),
        t.defaultValue = e
    }
    r = t.name,
    r !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    r !== "" && (t.name = r)
}
function bf(t, e, r) {
    (e !== "number" || Ou(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}
var Jo = Array.isArray;
function Ni(t, e, r, n) {
    if (t = t.options,
    e) {
        e = {};
        for (var s = 0; s < r.length; s++)
            e["$" + r[s]] = !0;
        for (r = 0; r < t.length; r++)
            s = e.hasOwnProperty("$" + t[r].value),
            t[r].selected !== s && (t[r].selected = s),
            s && n && (t[r].defaultSelected = !0)
    } else {
        for (r = "" + Kn(r),
        e = null,
        s = 0; s < t.length; s++) {
            if (t[s].value === r) {
                t[s].selected = !0,
                n && (t[s].defaultSelected = !0);
                return
            }
            e !== null || t[s].disabled || (e = t[s])
        }
        e !== null && (e.selected = !0)
    }
}
function xf(t, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(I(91));
    return Me({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function Zm(t, e) {
    var r = e.value;
    if (r == null) {
        if (r = e.children,
        e = e.defaultValue,
        r != null) {
            if (e != null)
                throw Error(I(92));
            if (Jo(r)) {
                if (1 < r.length)
                    throw Error(I(93));
                r = r[0]
            }
            e = r
        }
        e == null && (e = ""),
        r = e
    }
    t._wrapperState = {
        initialValue: Kn(r)
    }
}
function pw(t, e) {
    var r = Kn(e.value)
      , n = Kn(e.defaultValue);
    r != null && (r = "" + r,
    r !== t.value && (t.value = r),
    e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)),
    n != null && (t.defaultValue = "" + n)
}
function Ym(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
function mw(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Sf(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? mw(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var Ol, gw = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, r, n, s) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, r, n, s)
        })
    }
    : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = e;
    else {
        for (Ol = Ol || document.createElement("div"),
        Ol.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Ol.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; e.firstChild; )
            t.appendChild(e.firstChild)
    }
});
function _a(t, e) {
    if (e) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
            r.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var ia = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , vk = ["Webkit", "ms", "Moz", "O"];
Object.keys(ia).forEach(function(t) {
    vk.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1),
        ia[e] = ia[t]
    })
});
function vw(t, e, r) {
    return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || ia.hasOwnProperty(t) && ia[t] ? ("" + e).trim() : e + "px"
}
function yw(t, e) {
    t = t.style;
    for (var r in e)
        if (e.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0
              , s = vw(r, e[r], n);
            r === "float" && (r = "cssFloat"),
            n ? t.setProperty(r, s) : t[r] = s
        }
}
var yk = Me({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Ef(t, e) {
    if (e) {
        if (yk[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(I(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(I(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(I(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(I(62))
    }
}
function kf(t, e) {
    if (t.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Cf = null;
function op(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var Tf = null
  , Ii = null
  , Di = null;
function Jm(t) {
    if (t = cl(t)) {
        if (typeof Tf != "function")
            throw Error(I(280));
        var e = t.stateNode;
        e && (e = jc(e),
        Tf(t.stateNode, t.type, e))
    }
}
function ww(t) {
    Ii ? Di ? Di.push(t) : Di = [t] : Ii = t
}
function _w() {
    if (Ii) {
        var t = Ii
          , e = Di;
        if (Di = Ii = null,
        Jm(t),
        e)
            for (t = 0; t < e.length; t++)
                Jm(e[t])
    }
}
function bw(t, e) {
    return t(e)
}
function xw() {}
var vd = !1;
function Sw(t, e, r) {
    if (vd)
        return t(e, r);
    vd = !0;
    try {
        return bw(t, e, r)
    } finally {
        vd = !1,
        (Ii !== null || Di !== null) && (xw(),
        _w())
    }
}
function ba(t, e) {
    var r = t.stateNode;
    if (r === null)
        return null;
    var n = jc(r);
    if (n === null)
        return null;
    r = n[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (n = !n.disabled) || (t = t.type,
        n = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !n;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (r && typeof r != "function")
        throw Error(I(231, e, typeof r));
    return r
}
var Of = !1;
if (nn)
    try {
        var Lo = {};
        Object.defineProperty(Lo, "passive", {
            get: function() {
                Of = !0
            }
        }),
        window.addEventListener("test", Lo, Lo),
        window.removeEventListener("test", Lo, Lo)
    } catch {
        Of = !1
    }
function wk(t, e, r, n, s, i, o, a, l) {
    var u = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(r, u)
    } catch (c) {
        this.onError(c)
    }
}
var oa = !1
  , Pu = null
  , Ru = !1
  , Pf = null
  , _k = {
    onError: function(t) {
        oa = !0,
        Pu = t
    }
};
function bk(t, e, r, n, s, i, o, a, l) {
    oa = !1,
    Pu = null,
    wk.apply(_k, arguments)
}
function xk(t, e, r, n, s, i, o, a, l) {
    if (bk.apply(this, arguments),
    oa) {
        if (oa) {
            var u = Pu;
            oa = !1,
            Pu = null
        } else
            throw Error(I(198));
        Ru || (Ru = !0,
        Pf = u)
    }
}
function Qs(t) {
    var e = t
      , r = t;
    if (t.alternate)
        for (; e.return; )
            e = e.return;
    else {
        t = e;
        do
            e = t,
            e.flags & 4098 && (r = e.return),
            t = e.return;
        while (t)
    }
    return e.tag === 3 ? r : null
}
function Ew(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate,
        t !== null && (e = t.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Xm(t) {
    if (Qs(t) !== t)
        throw Error(I(188))
}
function Sk(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Qs(t),
        e === null)
            throw Error(I(188));
        return e !== t ? null : t
    }
    for (var r = t, n = e; ; ) {
        var s = r.return;
        if (s === null)
            break;
        var i = s.alternate;
        if (i === null) {
            if (n = s.return,
            n !== null) {
                r = n;
                continue
            }
            break
        }
        if (s.child === i.child) {
            for (i = s.child; i; ) {
                if (i === r)
                    return Xm(s),
                    t;
                if (i === n)
                    return Xm(s),
                    e;
                i = i.sibling
            }
            throw Error(I(188))
        }
        if (r.return !== n.return)
            r = s,
            n = i;
        else {
            for (var o = !1, a = s.child; a; ) {
                if (a === r) {
                    o = !0,
                    r = s,
                    n = i;
                    break
                }
                if (a === n) {
                    o = !0,
                    n = s,
                    r = i;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = i.child; a; ) {
                    if (a === r) {
                        o = !0,
                        r = i,
                        n = s;
                        break
                    }
                    if (a === n) {
                        o = !0,
                        n = i,
                        r = s;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(I(189))
            }
        }
        if (r.alternate !== n)
            throw Error(I(190))
    }
    if (r.tag !== 3)
        throw Error(I(188));
    return r.stateNode.current === r ? t : e
}
function kw(t) {
    return t = Sk(t),
    t !== null ? Cw(t) : null
}
function Cw(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var e = Cw(t);
        if (e !== null)
            return e;
        t = t.sibling
    }
    return null
}
var Tw = Wt.unstable_scheduleCallback
  , eg = Wt.unstable_cancelCallback
  , Ek = Wt.unstable_shouldYield
  , kk = Wt.unstable_requestPaint
  , Ue = Wt.unstable_now
  , Ck = Wt.unstable_getCurrentPriorityLevel
  , ap = Wt.unstable_ImmediatePriority
  , Ow = Wt.unstable_UserBlockingPriority
  , Au = Wt.unstable_NormalPriority
  , Tk = Wt.unstable_LowPriority
  , Pw = Wt.unstable_IdlePriority
  , Oc = null
  , Dr = null;
function Ok(t) {
    if (Dr && typeof Dr.onCommitFiberRoot == "function")
        try {
            Dr.onCommitFiberRoot(Oc, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var vr = Math.clz32 ? Math.clz32 : Ak
  , Pk = Math.log
  , Rk = Math.LN2;
function Ak(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (Pk(t) / Rk | 0) | 0
}
var Pl = 64
  , Rl = 4194304;
function Xo(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function ju(t, e) {
    var r = t.pendingLanes;
    if (r === 0)
        return 0;
    var n = 0
      , s = t.suspendedLanes
      , i = t.pingedLanes
      , o = r & 268435455;
    if (o !== 0) {
        var a = o & ~s;
        a !== 0 ? n = Xo(a) : (i &= o,
        i !== 0 && (n = Xo(i)))
    } else
        o = r & ~s,
        o !== 0 ? n = Xo(o) : i !== 0 && (n = Xo(i));
    if (n === 0)
        return 0;
    if (e !== 0 && e !== n && !(e & s) && (s = n & -n,
    i = e & -e,
    s >= i || s === 16 && (i & 4194240) !== 0))
        return e;
    if (n & 4 && (n |= r & 16),
    e = t.entangledLanes,
    e !== 0)
        for (t = t.entanglements,
        e &= n; 0 < e; )
            r = 31 - vr(e),
            s = 1 << r,
            n |= t[r],
            e &= ~s;
    return n
}
function jk(t, e) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function Nk(t, e) {
    for (var r = t.suspendedLanes, n = t.pingedLanes, s = t.expirationTimes, i = t.pendingLanes; 0 < i; ) {
        var o = 31 - vr(i)
          , a = 1 << o
          , l = s[o];
        l === -1 ? (!(a & r) || a & n) && (s[o] = jk(a, e)) : l <= e && (t.expiredLanes |= a),
        i &= ~a
    }
}
function Rf(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function Rw() {
    var t = Pl;
    return Pl <<= 1,
    !(Pl & 4194240) && (Pl = 64),
    t
}
function yd(t) {
    for (var e = [], r = 0; 31 > r; r++)
        e.push(t);
    return e
}
function ll(t, e, r) {
    t.pendingLanes |= e,
    e !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    e = 31 - vr(e),
    t[e] = r
}
function Ik(t, e) {
    var r = t.pendingLanes & ~e;
    t.pendingLanes = e,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= e,
    t.mutableReadLanes &= e,
    t.entangledLanes &= e,
    e = t.entanglements;
    var n = t.eventTimes;
    for (t = t.expirationTimes; 0 < r; ) {
        var s = 31 - vr(r)
          , i = 1 << s;
        e[s] = 0,
        n[s] = -1,
        t[s] = -1,
        r &= ~i
    }
}
function lp(t, e) {
    var r = t.entangledLanes |= e;
    for (t = t.entanglements; r; ) {
        var n = 31 - vr(r)
          , s = 1 << n;
        s & e | t[n] & e && (t[n] |= e),
        r &= ~s
    }
}
var Se = 0;
function Aw(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var jw, up, Nw, Iw, Dw, Af = !1, Al = [], Fn = null, Un = null, Vn = null, xa = new Map, Sa = new Map, En = [], Dk = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function tg(t, e) {
    switch (t) {
    case "focusin":
    case "focusout":
        Fn = null;
        break;
    case "dragenter":
    case "dragleave":
        Un = null;
        break;
    case "mouseover":
    case "mouseout":
        Vn = null;
        break;
    case "pointerover":
    case "pointerout":
        xa.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Sa.delete(e.pointerId)
    }
}
function $o(t, e, r, n, s, i) {
    return t === null || t.nativeEvent !== i ? (t = {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: i,
        targetContainers: [s]
    },
    e !== null && (e = cl(e),
    e !== null && up(e)),
    t) : (t.eventSystemFlags |= n,
    e = t.targetContainers,
    s !== null && e.indexOf(s) === -1 && e.push(s),
    t)
}
function Mk(t, e, r, n, s) {
    switch (e) {
    case "focusin":
        return Fn = $o(Fn, t, e, r, n, s),
        !0;
    case "dragenter":
        return Un = $o(Un, t, e, r, n, s),
        !0;
    case "mouseover":
        return Vn = $o(Vn, t, e, r, n, s),
        !0;
    case "pointerover":
        var i = s.pointerId;
        return xa.set(i, $o(xa.get(i) || null, t, e, r, n, s)),
        !0;
    case "gotpointercapture":
        return i = s.pointerId,
        Sa.set(i, $o(Sa.get(i) || null, t, e, r, n, s)),
        !0
    }
    return !1
}
function Mw(t) {
    var e = bs(t.target);
    if (e !== null) {
        var r = Qs(e);
        if (r !== null) {
            if (e = r.tag,
            e === 13) {
                if (e = Ew(r),
                e !== null) {
                    t.blockedOn = e,
                    Dw(t.priority, function() {
                        Nw(r)
                    });
                    return
                }
            } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function cu(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var e = t.targetContainers; 0 < e.length; ) {
        var r = jf(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (r === null) {
            r = t.nativeEvent;
            var n = new r.constructor(r.type,r);
            Cf = n,
            r.target.dispatchEvent(n),
            Cf = null
        } else
            return e = cl(r),
            e !== null && up(e),
            t.blockedOn = r,
            !1;
        e.shift()
    }
    return !0
}
function rg(t, e, r) {
    cu(t) && r.delete(e)
}
function Lk() {
    Af = !1,
    Fn !== null && cu(Fn) && (Fn = null),
    Un !== null && cu(Un) && (Un = null),
    Vn !== null && cu(Vn) && (Vn = null),
    xa.forEach(rg),
    Sa.forEach(rg)
}
function Fo(t, e) {
    t.blockedOn === e && (t.blockedOn = null,
    Af || (Af = !0,
    Wt.unstable_scheduleCallback(Wt.unstable_NormalPriority, Lk)))
}
function Ea(t) {
    function e(s) {
        return Fo(s, t)
    }
    if (0 < Al.length) {
        Fo(Al[0], t);
        for (var r = 1; r < Al.length; r++) {
            var n = Al[r];
            n.blockedOn === t && (n.blockedOn = null)
        }
    }
    for (Fn !== null && Fo(Fn, t),
    Un !== null && Fo(Un, t),
    Vn !== null && Fo(Vn, t),
    xa.forEach(e),
    Sa.forEach(e),
    r = 0; r < En.length; r++)
        n = En[r],
        n.blockedOn === t && (n.blockedOn = null);
    for (; 0 < En.length && (r = En[0],
    r.blockedOn === null); )
        Mw(r),
        r.blockedOn === null && En.shift()
}
var Mi = fn.ReactCurrentBatchConfig
  , Nu = !0;
function $k(t, e, r, n) {
    var s = Se
      , i = Mi.transition;
    Mi.transition = null;
    try {
        Se = 1,
        cp(t, e, r, n)
    } finally {
        Se = s,
        Mi.transition = i
    }
}
function Fk(t, e, r, n) {
    var s = Se
      , i = Mi.transition;
    Mi.transition = null;
    try {
        Se = 4,
        cp(t, e, r, n)
    } finally {
        Se = s,
        Mi.transition = i
    }
}
function cp(t, e, r, n) {
    if (Nu) {
        var s = jf(t, e, r, n);
        if (s === null)
            Od(t, e, n, Iu, r),
            tg(t, n);
        else if (Mk(s, t, e, r, n))
            n.stopPropagation();
        else if (tg(t, n),
        e & 4 && -1 < Dk.indexOf(t)) {
            for (; s !== null; ) {
                var i = cl(s);
                if (i !== null && jw(i),
                i = jf(t, e, r, n),
                i === null && Od(t, e, n, Iu, r),
                i === s)
                    break;
                s = i
            }
            s !== null && n.stopPropagation()
        } else
            Od(t, e, n, null, r)
    }
}
var Iu = null;
function jf(t, e, r, n) {
    if (Iu = null,
    t = op(n),
    t = bs(t),
    t !== null)
        if (e = Qs(t),
        e === null)
            t = null;
        else if (r = e.tag,
        r === 13) {
            if (t = Ew(e),
            t !== null)
                return t;
            t = null
        } else if (r === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null
        } else
            e !== t && (t = null);
    return Iu = t,
    null
}
function Lw(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (Ck()) {
        case ap:
            return 1;
        case Ow:
            return 4;
        case Au:
        case Tk:
            return 16;
        case Pw:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Ln = null
  , dp = null
  , du = null;
function $w() {
    if (du)
        return du;
    var t, e = dp, r = e.length, n, s = "value"in Ln ? Ln.value : Ln.textContent, i = s.length;
    for (t = 0; t < r && e[t] === s[t]; t++)
        ;
    var o = r - t;
    for (n = 1; n <= o && e[r - n] === s[i - n]; n++)
        ;
    return du = s.slice(t, 1 < n ? 1 - n : void 0)
}
function fu(t) {
    var e = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && e === 13 && (t = 13)) : t = e,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function jl() {
    return !0
}
function ng() {
    return !1
}
function qt(t) {
    function e(r, n, s, i, o) {
        this._reactName = r,
        this._targetInst = s,
        this.type = n,
        this.nativeEvent = i,
        this.target = o,
        this.currentTarget = null;
        for (var a in t)
            t.hasOwnProperty(a) && (r = t[a],
            this[a] = r ? r(i) : i[a]);
        return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? jl : ng,
        this.isPropagationStopped = ng,
        this
    }
    return Me(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = jl)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = jl)
        },
        persist: function() {},
        isPersistent: jl
    }),
    e
}
var xo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, fp = qt(xo), ul = Me({}, xo, {
    view: 0,
    detail: 0
}), Uk = qt(ul), wd, _d, Uo, Pc = Me({}, ul, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: hp,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== Uo && (Uo && t.type === "mousemove" ? (wd = t.screenX - Uo.screenX,
        _d = t.screenY - Uo.screenY) : _d = wd = 0,
        Uo = t),
        wd)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : _d
    }
}), sg = qt(Pc), Vk = Me({}, Pc, {
    dataTransfer: 0
}), Bk = qt(Vk), zk = Me({}, ul, {
    relatedTarget: 0
}), bd = qt(zk), Wk = Me({}, xo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hk = qt(Wk), qk = Me({}, xo, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), Kk = qt(qk), Gk = Me({}, xo, {
    data: 0
}), ig = qt(Gk), Qk = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Zk = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Yk = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Jk(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = Yk[t]) ? !!e[t] : !1
}
function hp() {
    return Jk
}
var Xk = Me({}, ul, {
    key: function(t) {
        if (t.key) {
            var e = Qk[t.key] || t.key;
            if (e !== "Unidentified")
                return e
        }
        return t.type === "keypress" ? (t = fu(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Zk[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: hp,
    charCode: function(t) {
        return t.type === "keypress" ? fu(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? fu(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , e1 = qt(Xk)
  , t1 = Me({}, Pc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , og = qt(t1)
  , r1 = Me({}, ul, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: hp
})
  , n1 = qt(r1)
  , s1 = Me({}, xo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , i1 = qt(s1)
  , o1 = Me({}, Pc, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , a1 = qt(o1)
  , l1 = [9, 13, 27, 32]
  , pp = nn && "CompositionEvent"in window
  , aa = null;
nn && "documentMode"in document && (aa = document.documentMode);
var u1 = nn && "TextEvent"in window && !aa
  , Fw = nn && (!pp || aa && 8 < aa && 11 >= aa)
  , ag = " "
  , lg = !1;
function Uw(t, e) {
    switch (t) {
    case "keyup":
        return l1.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function Vw(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var bi = !1;
function c1(t, e) {
    switch (t) {
    case "compositionend":
        return Vw(e);
    case "keypress":
        return e.which !== 32 ? null : (lg = !0,
        ag);
    case "textInput":
        return t = e.data,
        t === ag && lg ? null : t;
    default:
        return null
    }
}
function d1(t, e) {
    if (bi)
        return t === "compositionend" || !pp && Uw(t, e) ? (t = $w(),
        du = dp = Ln = null,
        bi = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return Fw && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var f1 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function ug(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!f1[t.type] : e === "textarea"
}
function Bw(t, e, r, n) {
    ww(n),
    e = Du(e, "onChange"),
    0 < e.length && (r = new fp("onChange","change",null,r,n),
    t.push({
        event: r,
        listeners: e
    }))
}
var la = null
  , ka = null;
function h1(t) {
    Xw(t, 0)
}
function Rc(t) {
    var e = Ei(t);
    if (fw(e))
        return t
}
function p1(t, e) {
    if (t === "change")
        return e
}
var zw = !1;
if (nn) {
    var xd;
    if (nn) {
        var Sd = "oninput"in document;
        if (!Sd) {
            var cg = document.createElement("div");
            cg.setAttribute("oninput", "return;"),
            Sd = typeof cg.oninput == "function"
        }
        xd = Sd
    } else
        xd = !1;
    zw = xd && (!document.documentMode || 9 < document.documentMode)
}
function dg() {
    la && (la.detachEvent("onpropertychange", Ww),
    ka = la = null)
}
function Ww(t) {
    if (t.propertyName === "value" && Rc(ka)) {
        var e = [];
        Bw(e, ka, t, op(t)),
        Sw(h1, e)
    }
}
function m1(t, e, r) {
    t === "focusin" ? (dg(),
    la = e,
    ka = r,
    la.attachEvent("onpropertychange", Ww)) : t === "focusout" && dg()
}
function g1(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return Rc(ka)
}
function v1(t, e) {
    if (t === "click")
        return Rc(e)
}
function y1(t, e) {
    if (t === "input" || t === "change")
        return Rc(e)
}
function w1(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var _r = typeof Object.is == "function" ? Object.is : w1;
function Ca(t, e) {
    if (_r(t, e))
        return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
    var r = Object.keys(t)
      , n = Object.keys(e);
    if (r.length !== n.length)
        return !1;
    for (n = 0; n < r.length; n++) {
        var s = r[n];
        if (!pf.call(e, s) || !_r(t[s], e[s]))
            return !1
    }
    return !0
}
function fg(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function hg(t, e) {
    var r = fg(t);
    t = 0;
    for (var n; r; ) {
        if (r.nodeType === 3) {
            if (n = t + r.textContent.length,
            t <= e && n >= e)
                return {
                    node: r,
                    offset: e - t
                };
            t = n
        }
        e: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = fg(r)
    }
}
function Hw(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Hw(t, e.parentNode) : "contains"in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}
function qw() {
    for (var t = window, e = Ou(); e instanceof t.HTMLIFrameElement; ) {
        try {
            var r = typeof e.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            t = e.contentWindow;
        else
            break;
        e = Ou(t.document)
    }
    return e
}
function mp(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
function _1(t) {
    var e = qw()
      , r = t.focusedElem
      , n = t.selectionRange;
    if (e !== r && r && r.ownerDocument && Hw(r.ownerDocument.documentElement, r)) {
        if (n !== null && mp(r)) {
            if (e = n.start,
            t = n.end,
            t === void 0 && (t = e),
            "selectionStart"in r)
                r.selectionStart = e,
                r.selectionEnd = Math.min(t, r.value.length);
            else if (t = (e = r.ownerDocument || document) && e.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var s = r.textContent.length
                  , i = Math.min(n.start, s);
                n = n.end === void 0 ? i : Math.min(n.end, s),
                !t.extend && i > n && (s = n,
                n = i,
                i = s),
                s = hg(r, i);
                var o = hg(r, n);
                s && o && (t.rangeCount !== 1 || t.anchorNode !== s.node || t.anchorOffset !== s.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(s.node, s.offset),
                t.removeAllRanges(),
                i > n ? (t.addRange(e),
                t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                t.addRange(e)))
            }
        }
        for (e = [],
        t = r; t = t.parentNode; )
            t.nodeType === 1 && e.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < e.length; r++)
            t = e[r],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var b1 = nn && "documentMode"in document && 11 >= document.documentMode
  , xi = null
  , Nf = null
  , ua = null
  , If = !1;
function pg(t, e, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    If || xi == null || xi !== Ou(n) || (n = xi,
    "selectionStart"in n && mp(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(),
    n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }),
    ua && Ca(ua, n) || (ua = n,
    n = Du(Nf, "onSelect"),
    0 < n.length && (e = new fp("onSelect","select",null,e,r),
    t.push({
        event: e,
        listeners: n
    }),
    e.target = xi)))
}
function Nl(t, e) {
    var r = {};
    return r[t.toLowerCase()] = e.toLowerCase(),
    r["Webkit" + t] = "webkit" + e,
    r["Moz" + t] = "moz" + e,
    r
}
var Si = {
    animationend: Nl("Animation", "AnimationEnd"),
    animationiteration: Nl("Animation", "AnimationIteration"),
    animationstart: Nl("Animation", "AnimationStart"),
    transitionend: Nl("Transition", "TransitionEnd")
}
  , Ed = {}
  , Kw = {};
nn && (Kw = document.createElement("div").style,
"AnimationEvent"in window || (delete Si.animationend.animation,
delete Si.animationiteration.animation,
delete Si.animationstart.animation),
"TransitionEvent"in window || delete Si.transitionend.transition);
function Ac(t) {
    if (Ed[t])
        return Ed[t];
    if (!Si[t])
        return t;
    var e = Si[t], r;
    for (r in e)
        if (e.hasOwnProperty(r) && r in Kw)
            return Ed[t] = e[r];
    return t
}
var Gw = Ac("animationend")
  , Qw = Ac("animationiteration")
  , Zw = Ac("animationstart")
  , Yw = Ac("transitionend")
  , Jw = new Map
  , mg = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ns(t, e) {
    Jw.set(t, e),
    Gs(e, [t])
}
for (var kd = 0; kd < mg.length; kd++) {
    var Cd = mg[kd]
      , x1 = Cd.toLowerCase()
      , S1 = Cd[0].toUpperCase() + Cd.slice(1);
    ns(x1, "on" + S1)
}
ns(Gw, "onAnimationEnd");
ns(Qw, "onAnimationIteration");
ns(Zw, "onAnimationStart");
ns("dblclick", "onDoubleClick");
ns("focusin", "onFocus");
ns("focusout", "onBlur");
ns(Yw, "onTransitionEnd");
oo("onMouseEnter", ["mouseout", "mouseover"]);
oo("onMouseLeave", ["mouseout", "mouseover"]);
oo("onPointerEnter", ["pointerout", "pointerover"]);
oo("onPointerLeave", ["pointerout", "pointerover"]);
Gs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Gs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Gs("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Gs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Gs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Gs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ea = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , E1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(ea));
function gg(t, e, r) {
    var n = t.type || "unknown-event";
    t.currentTarget = r,
    xk(n, e, void 0, t),
    t.currentTarget = null
}
function Xw(t, e) {
    e = (e & 4) !== 0;
    for (var r = 0; r < t.length; r++) {
        var n = t[r]
          , s = n.event;
        n = n.listeners;
        e: {
            var i = void 0;
            if (e)
                for (var o = n.length - 1; 0 <= o; o--) {
                    var a = n[o]
                      , l = a.instance
                      , u = a.currentTarget;
                    if (a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    gg(s, a, u),
                    i = l
                }
            else
                for (o = 0; o < n.length; o++) {
                    if (a = n[o],
                    l = a.instance,
                    u = a.currentTarget,
                    a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    gg(s, a, u),
                    i = l
                }
        }
    }
    if (Ru)
        throw t = Pf,
        Ru = !1,
        Pf = null,
        t
}
function Oe(t, e) {
    var r = e[Ff];
    r === void 0 && (r = e[Ff] = new Set);
    var n = t + "__bubble";
    r.has(n) || (e0(e, t, 2, !1),
    r.add(n))
}
function Td(t, e, r) {
    var n = 0;
    e && (n |= 4),
    e0(r, t, n, e)
}
var Il = "_reactListening" + Math.random().toString(36).slice(2);
function Ta(t) {
    if (!t[Il]) {
        t[Il] = !0,
        aw.forEach(function(r) {
            r !== "selectionchange" && (E1.has(r) || Td(r, !1, t),
            Td(r, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[Il] || (e[Il] = !0,
        Td("selectionchange", !1, e))
    }
}
function e0(t, e, r, n) {
    switch (Lw(e)) {
    case 1:
        var s = $k;
        break;
    case 4:
        s = Fk;
        break;
    default:
        s = cp
    }
    r = s.bind(null, e, r, t),
    s = void 0,
    !Of || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (s = !0),
    n ? s !== void 0 ? t.addEventListener(e, r, {
        capture: !0,
        passive: s
    }) : t.addEventListener(e, r, !0) : s !== void 0 ? t.addEventListener(e, r, {
        passive: s
    }) : t.addEventListener(e, r, !1)
}
function Od(t, e, r, n, s) {
    var i = n;
    if (!(e & 1) && !(e & 2) && n !== null)
        e: for (; ; ) {
            if (n === null)
                return;
            var o = n.tag;
            if (o === 3 || o === 4) {
                var a = n.stateNode.containerInfo;
                if (a === s || a.nodeType === 8 && a.parentNode === s)
                    break;
                if (o === 4)
                    for (o = n.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === s || l.nodeType === 8 && l.parentNode === s))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = bs(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        n = i = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            n = n.return
        }
    Sw(function() {
        var u = i
          , c = op(r)
          , d = [];
        e: {
            var f = Jw.get(t);
            if (f !== void 0) {
                var p = fp
                  , g = t;
                switch (t) {
                case "keypress":
                    if (fu(r) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    p = e1;
                    break;
                case "focusin":
                    g = "focus",
                    p = bd;
                    break;
                case "focusout":
                    g = "blur",
                    p = bd;
                    break;
                case "beforeblur":
                case "afterblur":
                    p = bd;
                    break;
                case "click":
                    if (r.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    p = sg;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    p = Bk;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    p = n1;
                    break;
                case Gw:
                case Qw:
                case Zw:
                    p = Hk;
                    break;
                case Yw:
                    p = i1;
                    break;
                case "scroll":
                    p = Uk;
                    break;
                case "wheel":
                    p = a1;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    p = Kk;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    p = og
                }
                var h = (e & 4) !== 0
                  , w = !h && t === "scroll"
                  , v = h ? f !== null ? f + "Capture" : null : f;
                h = [];
                for (var m = u, _; m !== null; ) {
                    _ = m;
                    var x = _.stateNode;
                    if (_.tag === 5 && x !== null && (_ = x,
                    v !== null && (x = ba(m, v),
                    x != null && h.push(Oa(m, x, _)))),
                    w)
                        break;
                    m = m.return
                }
                0 < h.length && (f = new p(f,g,null,r,c),
                d.push({
                    event: f,
                    listeners: h
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (f = t === "mouseover" || t === "pointerover",
                p = t === "mouseout" || t === "pointerout",
                f && r !== Cf && (g = r.relatedTarget || r.fromElement) && (bs(g) || g[sn]))
                    break e;
                if ((p || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window,
                p ? (g = r.relatedTarget || r.toElement,
                p = u,
                g = g ? bs(g) : null,
                g !== null && (w = Qs(g),
                g !== w || g.tag !== 5 && g.tag !== 6) && (g = null)) : (p = null,
                g = u),
                p !== g)) {
                    if (h = sg,
                    x = "onMouseLeave",
                    v = "onMouseEnter",
                    m = "mouse",
                    (t === "pointerout" || t === "pointerover") && (h = og,
                    x = "onPointerLeave",
                    v = "onPointerEnter",
                    m = "pointer"),
                    w = p == null ? f : Ei(p),
                    _ = g == null ? f : Ei(g),
                    f = new h(x,m + "leave",p,r,c),
                    f.target = w,
                    f.relatedTarget = _,
                    x = null,
                    bs(c) === u && (h = new h(v,m + "enter",g,r,c),
                    h.target = _,
                    h.relatedTarget = w,
                    x = h),
                    w = x,
                    p && g)
                        t: {
                            for (h = p,
                            v = g,
                            m = 0,
                            _ = h; _; _ = ei(_))
                                m++;
                            for (_ = 0,
                            x = v; x; x = ei(x))
                                _++;
                            for (; 0 < m - _; )
                                h = ei(h),
                                m--;
                            for (; 0 < _ - m; )
                                v = ei(v),
                                _--;
                            for (; m--; ) {
                                if (h === v || v !== null && h === v.alternate)
                                    break t;
                                h = ei(h),
                                v = ei(v)
                            }
                            h = null
                        }
                    else
                        h = null;
                    p !== null && vg(d, f, p, h, !1),
                    g !== null && w !== null && vg(d, w, g, h, !0)
                }
            }
            e: {
                if (f = u ? Ei(u) : window,
                p = f.nodeName && f.nodeName.toLowerCase(),
                p === "select" || p === "input" && f.type === "file")
                    var k = p1;
                else if (ug(f))
                    if (zw)
                        k = y1;
                    else {
                        k = g1;
                        var T = m1
                    }
                else
                    (p = f.nodeName) && p.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (k = v1);
                if (k && (k = k(t, u))) {
                    Bw(d, k, r, c);
                    break e
                }
                T && T(t, f, u),
                t === "focusout" && (T = f._wrapperState) && T.controlled && f.type === "number" && bf(f, "number", f.value)
            }
            switch (T = u ? Ei(u) : window,
            t) {
            case "focusin":
                (ug(T) || T.contentEditable === "true") && (xi = T,
                Nf = u,
                ua = null);
                break;
            case "focusout":
                ua = Nf = xi = null;
                break;
            case "mousedown":
                If = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                If = !1,
                pg(d, r, c);
                break;
            case "selectionchange":
                if (b1)
                    break;
            case "keydown":
            case "keyup":
                pg(d, r, c)
            }
            var C;
            if (pp)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var P = "onCompositionStart";
                        break e;
                    case "compositionend":
                        P = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        P = "onCompositionUpdate";
                        break e
                    }
                    P = void 0
                }
            else
                bi ? Uw(t, r) && (P = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (P = "onCompositionStart");
            P && (Fw && r.locale !== "ko" && (bi || P !== "onCompositionStart" ? P === "onCompositionEnd" && bi && (C = $w()) : (Ln = c,
            dp = "value"in Ln ? Ln.value : Ln.textContent,
            bi = !0)),
            T = Du(u, P),
            0 < T.length && (P = new ig(P,t,null,r,c),
            d.push({
                event: P,
                listeners: T
            }),
            C ? P.data = C : (C = Vw(r),
            C !== null && (P.data = C)))),
            (C = u1 ? c1(t, r) : d1(t, r)) && (u = Du(u, "onBeforeInput"),
            0 < u.length && (c = new ig("onBeforeInput","beforeinput",null,r,c),
            d.push({
                event: c,
                listeners: u
            }),
            c.data = C))
        }
        Xw(d, e)
    })
}
function Oa(t, e, r) {
    return {
        instance: t,
        listener: e,
        currentTarget: r
    }
}
function Du(t, e) {
    for (var r = e + "Capture", n = []; t !== null; ) {
        var s = t
          , i = s.stateNode;
        s.tag === 5 && i !== null && (s = i,
        i = ba(t, r),
        i != null && n.unshift(Oa(t, i, s)),
        i = ba(t, e),
        i != null && n.push(Oa(t, i, s))),
        t = t.return
    }
    return n
}
function ei(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function vg(t, e, r, n, s) {
    for (var i = e._reactName, o = []; r !== null && r !== n; ) {
        var a = r
          , l = a.alternate
          , u = a.stateNode;
        if (l !== null && l === n)
            break;
        a.tag === 5 && u !== null && (a = u,
        s ? (l = ba(r, i),
        l != null && o.unshift(Oa(r, l, a))) : s || (l = ba(r, i),
        l != null && o.push(Oa(r, l, a)))),
        r = r.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var k1 = /\r\n?/g
  , C1 = /\u0000|\uFFFD/g;
function yg(t) {
    return (typeof t == "string" ? t : "" + t).replace(k1, `
`).replace(C1, "")
}
function Dl(t, e, r) {
    if (e = yg(e),
    yg(t) !== e && r)
        throw Error(I(425))
}
function Mu() {}
var Df = null
  , Mf = null;
function Lf(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var $f = typeof setTimeout == "function" ? setTimeout : void 0
  , T1 = typeof clearTimeout == "function" ? clearTimeout : void 0
  , wg = typeof Promise == "function" ? Promise : void 0
  , O1 = typeof queueMicrotask == "function" ? queueMicrotask : typeof wg < "u" ? function(t) {
    return wg.resolve(null).then(t).catch(P1)
}
: $f;
function P1(t) {
    setTimeout(function() {
        throw t
    })
}
function Pd(t, e) {
    var r = e
      , n = 0;
    do {
        var s = r.nextSibling;
        if (t.removeChild(r),
        s && s.nodeType === 8)
            if (r = s.data,
            r === "/$") {
                if (n === 0) {
                    t.removeChild(s),
                    Ea(e);
                    return
                }
                n--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = s
    } while (r);
    Ea(e)
}
function Bn(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = t.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return t
}
function _g(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
        if (t.nodeType === 8) {
            var r = t.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (e === 0)
                    return t;
                e--
            } else
                r === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var So = Math.random().toString(36).slice(2)
  , jr = "__reactFiber$" + So
  , Pa = "__reactProps$" + So
  , sn = "__reactContainer$" + So
  , Ff = "__reactEvents$" + So
  , R1 = "__reactListeners$" + So
  , A1 = "__reactHandles$" + So;
function bs(t) {
    var e = t[jr];
    if (e)
        return e;
    for (var r = t.parentNode; r; ) {
        if (e = r[sn] || r[jr]) {
            if (r = e.alternate,
            e.child !== null || r !== null && r.child !== null)
                for (t = _g(t); t !== null; ) {
                    if (r = t[jr])
                        return r;
                    t = _g(t)
                }
            return e
        }
        t = r,
        r = t.parentNode
    }
    return null
}
function cl(t) {
    return t = t[jr] || t[sn],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function Ei(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(I(33))
}
function jc(t) {
    return t[Pa] || null
}
var Uf = []
  , ki = -1;
function ss(t) {
    return {
        current: t
    }
}
function Re(t) {
    0 > ki || (t.current = Uf[ki],
    Uf[ki] = null,
    ki--)
}
function Ce(t, e) {
    ki++,
    Uf[ki] = t.current,
    t.current = e
}
var Gn = {}
  , ct = ss(Gn)
  , Ot = ss(!1)
  , Ms = Gn;
function ao(t, e) {
    var r = t.type.contextTypes;
    if (!r)
        return Gn;
    var n = t.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === e)
        return n.__reactInternalMemoizedMaskedChildContext;
    var s = {}, i;
    for (i in r)
        s[i] = e[i];
    return n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = e,
    t.__reactInternalMemoizedMaskedChildContext = s),
    s
}
function Pt(t) {
    return t = t.childContextTypes,
    t != null
}
function Lu() {
    Re(Ot),
    Re(ct)
}
function bg(t, e, r) {
    if (ct.current !== Gn)
        throw Error(I(168));
    Ce(ct, e),
    Ce(Ot, r)
}
function t0(t, e, r) {
    var n = t.stateNode;
    if (e = e.childContextTypes,
    typeof n.getChildContext != "function")
        return r;
    n = n.getChildContext();
    for (var s in n)
        if (!(s in e))
            throw Error(I(108, mk(t) || "Unknown", s));
    return Me({}, r, n)
}
function $u(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Gn,
    Ms = ct.current,
    Ce(ct, t),
    Ce(Ot, Ot.current),
    !0
}
function xg(t, e, r) {
    var n = t.stateNode;
    if (!n)
        throw Error(I(169));
    r ? (t = t0(t, e, Ms),
    n.__reactInternalMemoizedMergedChildContext = t,
    Re(Ot),
    Re(ct),
    Ce(ct, t)) : Re(Ot),
    Ce(Ot, r)
}
var Qr = null
  , Nc = !1
  , Rd = !1;
function r0(t) {
    Qr === null ? Qr = [t] : Qr.push(t)
}
function j1(t) {
    Nc = !0,
    r0(t)
}
function is() {
    if (!Rd && Qr !== null) {
        Rd = !0;
        var t = 0
          , e = Se;
        try {
            var r = Qr;
            for (Se = 1; t < r.length; t++) {
                var n = r[t];
                do
                    n = n(!0);
                while (n !== null)
            }
            Qr = null,
            Nc = !1
        } catch (s) {
            throw Qr !== null && (Qr = Qr.slice(t + 1)),
            Tw(ap, is),
            s
        } finally {
            Se = e,
            Rd = !1
        }
    }
    return null
}
var Ci = []
  , Ti = 0
  , Fu = null
  , Uu = 0
  , Qt = []
  , Zt = 0
  , Ls = null
  , Xr = 1
  , en = "";
function ps(t, e) {
    Ci[Ti++] = Uu,
    Ci[Ti++] = Fu,
    Fu = t,
    Uu = e
}
function n0(t, e, r) {
    Qt[Zt++] = Xr,
    Qt[Zt++] = en,
    Qt[Zt++] = Ls,
    Ls = t;
    var n = Xr;
    t = en;
    var s = 32 - vr(n) - 1;
    n &= ~(1 << s),
    r += 1;
    var i = 32 - vr(e) + s;
    if (30 < i) {
        var o = s - s % 5;
        i = (n & (1 << o) - 1).toString(32),
        n >>= o,
        s -= o,
        Xr = 1 << 32 - vr(e) + s | r << s | n,
        en = i + t
    } else
        Xr = 1 << i | r << s | n,
        en = t
}
function gp(t) {
    t.return !== null && (ps(t, 1),
    n0(t, 1, 0))
}
function vp(t) {
    for (; t === Fu; )
        Fu = Ci[--Ti],
        Ci[Ti] = null,
        Uu = Ci[--Ti],
        Ci[Ti] = null;
    for (; t === Ls; )
        Ls = Qt[--Zt],
        Qt[Zt] = null,
        en = Qt[--Zt],
        Qt[Zt] = null,
        Xr = Qt[--Zt],
        Qt[Zt] = null
}
var Vt = null
  , Ut = null
  , Ae = !1
  , dr = null;
function s0(t, e) {
    var r = Jt(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = e,
    r.return = t,
    e = t.deletions,
    e === null ? (t.deletions = [r],
    t.flags |= 16) : e.push(r)
}
function Sg(t, e) {
    switch (t.tag) {
    case 5:
        var r = t.type;
        return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (t.stateNode = e,
        Vt = t,
        Ut = Bn(e.firstChild),
        !0) : !1;
    case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (t.stateNode = e,
        Vt = t,
        Ut = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (r = Ls !== null ? {
            id: Xr,
            overflow: en
        } : null,
        t.memoizedState = {
            dehydrated: e,
            treeContext: r,
            retryLane: 1073741824
        },
        r = Jt(18, null, null, 0),
        r.stateNode = e,
        r.return = t,
        t.child = r,
        Vt = t,
        Ut = null,
        !0) : !1;
    default:
        return !1
    }
}
function Vf(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function Bf(t) {
    if (Ae) {
        var e = Ut;
        if (e) {
            var r = e;
            if (!Sg(t, e)) {
                if (Vf(t))
                    throw Error(I(418));
                e = Bn(r.nextSibling);
                var n = Vt;
                e && Sg(t, e) ? s0(n, r) : (t.flags = t.flags & -4097 | 2,
                Ae = !1,
                Vt = t)
            }
        } else {
            if (Vf(t))
                throw Error(I(418));
            t.flags = t.flags & -4097 | 2,
            Ae = !1,
            Vt = t
        }
    }
}
function Eg(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    Vt = t
}
function Ml(t) {
    if (t !== Vt)
        return !1;
    if (!Ae)
        return Eg(t),
        Ae = !0,
        !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type,
    e = e !== "head" && e !== "body" && !Lf(t.type, t.memoizedProps)),
    e && (e = Ut)) {
        if (Vf(t))
            throw i0(),
            Error(I(418));
        for (; e; )
            s0(t, e),
            e = Bn(e.nextSibling)
    }
    if (Eg(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(I(317));
        e: {
            for (t = t.nextSibling,
            e = 0; t; ) {
                if (t.nodeType === 8) {
                    var r = t.data;
                    if (r === "/$") {
                        if (e === 0) {
                            Ut = Bn(t.nextSibling);
                            break e
                        }
                        e--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || e++
                }
                t = t.nextSibling
            }
            Ut = null
        }
    } else
        Ut = Vt ? Bn(t.stateNode.nextSibling) : null;
    return !0
}
function i0() {
    for (var t = Ut; t; )
        t = Bn(t.nextSibling)
}
function lo() {
    Ut = Vt = null,
    Ae = !1
}
function yp(t) {
    dr === null ? dr = [t] : dr.push(t)
}
var N1 = fn.ReactCurrentBatchConfig;
function Vo(t, e, r) {
    if (t = r.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(I(309));
                var n = r.stateNode
            }
            if (!n)
                throw Error(I(147, t));
            var s = n
              , i = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function(o) {
                var a = s.refs;
                o === null ? delete a[i] : a[i] = o
            }
            ,
            e._stringRef = i,
            e)
        }
        if (typeof t != "string")
            throw Error(I(284));
        if (!r._owner)
            throw Error(I(290, t))
    }
    return t
}
function Ll(t, e) {
    throw t = Object.prototype.toString.call(e),
    Error(I(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}
function kg(t) {
    var e = t._init;
    return e(t._payload)
}
function o0(t) {
    function e(v, m) {
        if (t) {
            var _ = v.deletions;
            _ === null ? (v.deletions = [m],
            v.flags |= 16) : _.push(m)
        }
    }
    function r(v, m) {
        if (!t)
            return null;
        for (; m !== null; )
            e(v, m),
            m = m.sibling;
        return null
    }
    function n(v, m) {
        for (v = new Map; m !== null; )
            m.key !== null ? v.set(m.key, m) : v.set(m.index, m),
            m = m.sibling;
        return v
    }
    function s(v, m) {
        return v = qn(v, m),
        v.index = 0,
        v.sibling = null,
        v
    }
    function i(v, m, _) {
        return v.index = _,
        t ? (_ = v.alternate,
        _ !== null ? (_ = _.index,
        _ < m ? (v.flags |= 2,
        m) : _) : (v.flags |= 2,
        m)) : (v.flags |= 1048576,
        m)
    }
    function o(v) {
        return t && v.alternate === null && (v.flags |= 2),
        v
    }
    function a(v, m, _, x) {
        return m === null || m.tag !== 6 ? (m = Ld(_, v.mode, x),
        m.return = v,
        m) : (m = s(m, _),
        m.return = v,
        m)
    }
    function l(v, m, _, x) {
        var k = _.type;
        return k === _i ? c(v, m, _.props.children, x, _.key) : m !== null && (m.elementType === k || typeof k == "object" && k !== null && k.$$typeof === xn && kg(k) === m.type) ? (x = s(m, _.props),
        x.ref = Vo(v, m, _),
        x.return = v,
        x) : (x = wu(_.type, _.key, _.props, null, v.mode, x),
        x.ref = Vo(v, m, _),
        x.return = v,
        x)
    }
    function u(v, m, _, x) {
        return m === null || m.tag !== 4 || m.stateNode.containerInfo !== _.containerInfo || m.stateNode.implementation !== _.implementation ? (m = $d(_, v.mode, x),
        m.return = v,
        m) : (m = s(m, _.children || []),
        m.return = v,
        m)
    }
    function c(v, m, _, x, k) {
        return m === null || m.tag !== 7 ? (m = Is(_, v.mode, x, k),
        m.return = v,
        m) : (m = s(m, _),
        m.return = v,
        m)
    }
    function d(v, m, _) {
        if (typeof m == "string" && m !== "" || typeof m == "number")
            return m = Ld("" + m, v.mode, _),
            m.return = v,
            m;
        if (typeof m == "object" && m !== null) {
            switch (m.$$typeof) {
            case Cl:
                return _ = wu(m.type, m.key, m.props, null, v.mode, _),
                _.ref = Vo(v, null, m),
                _.return = v,
                _;
            case wi:
                return m = $d(m, v.mode, _),
                m.return = v,
                m;
            case xn:
                var x = m._init;
                return d(v, x(m._payload), _)
            }
            if (Jo(m) || Mo(m))
                return m = Is(m, v.mode, _, null),
                m.return = v,
                m;
            Ll(v, m)
        }
        return null
    }
    function f(v, m, _, x) {
        var k = m !== null ? m.key : null;
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return k !== null ? null : a(v, m, "" + _, x);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Cl:
                return _.key === k ? l(v, m, _, x) : null;
            case wi:
                return _.key === k ? u(v, m, _, x) : null;
            case xn:
                return k = _._init,
                f(v, m, k(_._payload), x)
            }
            if (Jo(_) || Mo(_))
                return k !== null ? null : c(v, m, _, x, null);
            Ll(v, _)
        }
        return null
    }
    function p(v, m, _, x, k) {
        if (typeof x == "string" && x !== "" || typeof x == "number")
            return v = v.get(_) || null,
            a(m, v, "" + x, k);
        if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
            case Cl:
                return v = v.get(x.key === null ? _ : x.key) || null,
                l(m, v, x, k);
            case wi:
                return v = v.get(x.key === null ? _ : x.key) || null,
                u(m, v, x, k);
            case xn:
                var T = x._init;
                return p(v, m, _, T(x._payload), k)
            }
            if (Jo(x) || Mo(x))
                return v = v.get(_) || null,
                c(m, v, x, k, null);
            Ll(m, x)
        }
        return null
    }
    function g(v, m, _, x) {
        for (var k = null, T = null, C = m, P = m = 0, j = null; C !== null && P < _.length; P++) {
            C.index > P ? (j = C,
            C = null) : j = C.sibling;
            var $ = f(v, C, _[P], x);
            if ($ === null) {
                C === null && (C = j);
                break
            }
            t && C && $.alternate === null && e(v, C),
            m = i($, m, P),
            T === null ? k = $ : T.sibling = $,
            T = $,
            C = j
        }
        if (P === _.length)
            return r(v, C),
            Ae && ps(v, P),
            k;
        if (C === null) {
            for (; P < _.length; P++)
                C = d(v, _[P], x),
                C !== null && (m = i(C, m, P),
                T === null ? k = C : T.sibling = C,
                T = C);
            return Ae && ps(v, P),
            k
        }
        for (C = n(v, C); P < _.length; P++)
            j = p(C, v, P, _[P], x),
            j !== null && (t && j.alternate !== null && C.delete(j.key === null ? P : j.key),
            m = i(j, m, P),
            T === null ? k = j : T.sibling = j,
            T = j);
        return t && C.forEach(function(X) {
            return e(v, X)
        }),
        Ae && ps(v, P),
        k
    }
    function h(v, m, _, x) {
        var k = Mo(_);
        if (typeof k != "function")
            throw Error(I(150));
        if (_ = k.call(_),
        _ == null)
            throw Error(I(151));
        for (var T = k = null, C = m, P = m = 0, j = null, $ = _.next(); C !== null && !$.done; P++,
        $ = _.next()) {
            C.index > P ? (j = C,
            C = null) : j = C.sibling;
            var X = f(v, C, $.value, x);
            if (X === null) {
                C === null && (C = j);
                break
            }
            t && C && X.alternate === null && e(v, C),
            m = i(X, m, P),
            T === null ? k = X : T.sibling = X,
            T = X,
            C = j
        }
        if ($.done)
            return r(v, C),
            Ae && ps(v, P),
            k;
        if (C === null) {
            for (; !$.done; P++,
            $ = _.next())
                $ = d(v, $.value, x),
                $ !== null && (m = i($, m, P),
                T === null ? k = $ : T.sibling = $,
                T = $);
            return Ae && ps(v, P),
            k
        }
        for (C = n(v, C); !$.done; P++,
        $ = _.next())
            $ = p(C, v, P, $.value, x),
            $ !== null && (t && $.alternate !== null && C.delete($.key === null ? P : $.key),
            m = i($, m, P),
            T === null ? k = $ : T.sibling = $,
            T = $);
        return t && C.forEach(function(D) {
            return e(v, D)
        }),
        Ae && ps(v, P),
        k
    }
    function w(v, m, _, x) {
        if (typeof _ == "object" && _ !== null && _.type === _i && _.key === null && (_ = _.props.children),
        typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Cl:
                e: {
                    for (var k = _.key, T = m; T !== null; ) {
                        if (T.key === k) {
                            if (k = _.type,
                            k === _i) {
                                if (T.tag === 7) {
                                    r(v, T.sibling),
                                    m = s(T, _.props.children),
                                    m.return = v,
                                    v = m;
                                    break e
                                }
                            } else if (T.elementType === k || typeof k == "object" && k !== null && k.$$typeof === xn && kg(k) === T.type) {
                                r(v, T.sibling),
                                m = s(T, _.props),
                                m.ref = Vo(v, T, _),
                                m.return = v,
                                v = m;
                                break e
                            }
                            r(v, T);
                            break
                        } else
                            e(v, T);
                        T = T.sibling
                    }
                    _.type === _i ? (m = Is(_.props.children, v.mode, x, _.key),
                    m.return = v,
                    v = m) : (x = wu(_.type, _.key, _.props, null, v.mode, x),
                    x.ref = Vo(v, m, _),
                    x.return = v,
                    v = x)
                }
                return o(v);
            case wi:
                e: {
                    for (T = _.key; m !== null; ) {
                        if (m.key === T)
                            if (m.tag === 4 && m.stateNode.containerInfo === _.containerInfo && m.stateNode.implementation === _.implementation) {
                                r(v, m.sibling),
                                m = s(m, _.children || []),
                                m.return = v,
                                v = m;
                                break e
                            } else {
                                r(v, m);
                                break
                            }
                        else
                            e(v, m);
                        m = m.sibling
                    }
                    m = $d(_, v.mode, x),
                    m.return = v,
                    v = m
                }
                return o(v);
            case xn:
                return T = _._init,
                w(v, m, T(_._payload), x)
            }
            if (Jo(_))
                return g(v, m, _, x);
            if (Mo(_))
                return h(v, m, _, x);
            Ll(v, _)
        }
        return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _,
        m !== null && m.tag === 6 ? (r(v, m.sibling),
        m = s(m, _),
        m.return = v,
        v = m) : (r(v, m),
        m = Ld(_, v.mode, x),
        m.return = v,
        v = m),
        o(v)) : r(v, m)
    }
    return w
}
var uo = o0(!0)
  , a0 = o0(!1)
  , Vu = ss(null)
  , Bu = null
  , Oi = null
  , wp = null;
function _p() {
    wp = Oi = Bu = null
}
function bp(t) {
    var e = Vu.current;
    Re(Vu),
    t._currentValue = e
}
function zf(t, e, r) {
    for (; t !== null; ) {
        var n = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e,
        n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e),
        t === r)
            break;
        t = t.return
    }
}
function Li(t, e) {
    Bu = t,
    wp = Oi = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & e && (Tt = !0),
    t.firstContext = null)
}
function er(t) {
    var e = t._currentValue;
    if (wp !== t)
        if (t = {
            context: t,
            memoizedValue: e,
            next: null
        },
        Oi === null) {
            if (Bu === null)
                throw Error(I(308));
            Oi = t,
            Bu.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            Oi = Oi.next = t;
    return e
}
var xs = null;
function xp(t) {
    xs === null ? xs = [t] : xs.push(t)
}
function l0(t, e, r, n) {
    var s = e.interleaved;
    return s === null ? (r.next = r,
    xp(e)) : (r.next = s.next,
    s.next = r),
    e.interleaved = r,
    on(t, n)
}
function on(t, e) {
    t.lanes |= e;
    var r = t.alternate;
    for (r !== null && (r.lanes |= e),
    r = t,
    t = t.return; t !== null; )
        t.childLanes |= e,
        r = t.alternate,
        r !== null && (r.childLanes |= e),
        r = t,
        t = t.return;
    return r.tag === 3 ? r.stateNode : null
}
var Sn = !1;
function Sp(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function u0(t, e) {
    t = t.updateQueue,
    e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function tn(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function zn(t, e, r) {
    var n = t.updateQueue;
    if (n === null)
        return null;
    if (n = n.shared,
    ge & 2) {
        var s = n.pending;
        return s === null ? e.next = e : (e.next = s.next,
        s.next = e),
        n.pending = e,
        on(t, r)
    }
    return s = n.interleaved,
    s === null ? (e.next = e,
    xp(n)) : (e.next = s.next,
    s.next = e),
    n.interleaved = e,
    on(t, r)
}
function hu(t, e, r) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (r & 4194240) !== 0)) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        lp(t, r)
    }
}
function Cg(t, e) {
    var r = t.updateQueue
      , n = t.alternate;
    if (n !== null && (n = n.updateQueue,
    r === n)) {
        var s = null
          , i = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                i === null ? s = i = o : i = i.next = o,
                r = r.next
            } while (r !== null);
            i === null ? s = i = e : i = i.next = e
        } else
            s = i = e;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: s,
            lastBaseUpdate: i,
            shared: n.shared,
            effects: n.effects
        },
        t.updateQueue = r;
        return
    }
    t = r.lastBaseUpdate,
    t === null ? r.firstBaseUpdate = e : t.next = e,
    r.lastBaseUpdate = e
}
function zu(t, e, r, n) {
    var s = t.updateQueue;
    Sn = !1;
    var i = s.firstBaseUpdate
      , o = s.lastBaseUpdate
      , a = s.shared.pending;
    if (a !== null) {
        s.shared.pending = null;
        var l = a
          , u = l.next;
        l.next = null,
        o === null ? i = u : o.next = u,
        o = l;
        var c = t.alternate;
        c !== null && (c = c.updateQueue,
        a = c.lastBaseUpdate,
        a !== o && (a === null ? c.firstBaseUpdate = u : a.next = u,
        c.lastBaseUpdate = l))
    }
    if (i !== null) {
        var d = s.baseState;
        o = 0,
        c = u = l = null,
        a = i;
        do {
            var f = a.lane
              , p = a.eventTime;
            if ((n & f) === f) {
                c !== null && (c = c.next = {
                    eventTime: p,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var g = t
                      , h = a;
                    switch (f = e,
                    p = r,
                    h.tag) {
                    case 1:
                        if (g = h.payload,
                        typeof g == "function") {
                            d = g.call(p, d, f);
                            break e
                        }
                        d = g;
                        break e;
                    case 3:
                        g.flags = g.flags & -65537 | 128;
                    case 0:
                        if (g = h.payload,
                        f = typeof g == "function" ? g.call(p, d, f) : g,
                        f == null)
                            break e;
                        d = Me({}, d, f);
                        break e;
                    case 2:
                        Sn = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64,
                f = s.effects,
                f === null ? s.effects = [a] : f.push(a))
            } else
                p = {
                    eventTime: p,
                    lane: f,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                c === null ? (u = c = p,
                l = d) : c = c.next = p,
                o |= f;
            if (a = a.next,
            a === null) {
                if (a = s.shared.pending,
                a === null)
                    break;
                f = a,
                a = f.next,
                f.next = null,
                s.lastBaseUpdate = f,
                s.shared.pending = null
            }
        } while (!0);
        if (c === null && (l = d),
        s.baseState = l,
        s.firstBaseUpdate = u,
        s.lastBaseUpdate = c,
        e = s.shared.interleaved,
        e !== null) {
            s = e;
            do
                o |= s.lane,
                s = s.next;
            while (s !== e)
        } else
            i === null && (s.shared.lanes = 0);
        Fs |= o,
        t.lanes = o,
        t.memoizedState = d
    }
}
function Tg(t, e, r) {
    if (t = e.effects,
    e.effects = null,
    t !== null)
        for (e = 0; e < t.length; e++) {
            var n = t[e]
              , s = n.callback;
            if (s !== null) {
                if (n.callback = null,
                n = r,
                typeof s != "function")
                    throw Error(I(191, s));
                s.call(n)
            }
        }
}
var dl = {}
  , Mr = ss(dl)
  , Ra = ss(dl)
  , Aa = ss(dl);
function Ss(t) {
    if (t === dl)
        throw Error(I(174));
    return t
}
function Ep(t, e) {
    switch (Ce(Aa, e),
    Ce(Ra, t),
    Ce(Mr, dl),
    t = e.nodeType,
    t) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : Sf(null, "");
        break;
    default:
        t = t === 8 ? e.parentNode : e,
        e = t.namespaceURI || null,
        t = t.tagName,
        e = Sf(e, t)
    }
    Re(Mr),
    Ce(Mr, e)
}
function co() {
    Re(Mr),
    Re(Ra),
    Re(Aa)
}
function c0(t) {
    Ss(Aa.current);
    var e = Ss(Mr.current)
      , r = Sf(e, t.type);
    e !== r && (Ce(Ra, t),
    Ce(Mr, r))
}
function kp(t) {
    Ra.current === t && (Re(Mr),
    Re(Ra))
}
var Ie = ss(0);
function Wu(t) {
    for (var e = t; e !== null; ) {
        if (e.tag === 13) {
            var r = e.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === t)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var Ad = [];
function Cp() {
    for (var t = 0; t < Ad.length; t++)
        Ad[t]._workInProgressVersionPrimary = null;
    Ad.length = 0
}
var pu = fn.ReactCurrentDispatcher
  , jd = fn.ReactCurrentBatchConfig
  , $s = 0
  , De = null
  , Ge = null
  , Ye = null
  , Hu = !1
  , ca = !1
  , ja = 0
  , I1 = 0;
function ot() {
    throw Error(I(321))
}
function Tp(t, e) {
    if (e === null)
        return !1;
    for (var r = 0; r < e.length && r < t.length; r++)
        if (!_r(t[r], e[r]))
            return !1;
    return !0
}
function Op(t, e, r, n, s, i) {
    if ($s = i,
    De = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    pu.current = t === null || t.memoizedState === null ? $1 : F1,
    t = r(n, s),
    ca) {
        i = 0;
        do {
            if (ca = !1,
            ja = 0,
            25 <= i)
                throw Error(I(301));
            i += 1,
            Ye = Ge = null,
            e.updateQueue = null,
            pu.current = U1,
            t = r(n, s)
        } while (ca)
    }
    if (pu.current = qu,
    e = Ge !== null && Ge.next !== null,
    $s = 0,
    Ye = Ge = De = null,
    Hu = !1,
    e)
        throw Error(I(300));
    return t
}
function Pp() {
    var t = ja !== 0;
    return ja = 0,
    t
}
function Tr() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ye === null ? De.memoizedState = Ye = t : Ye = Ye.next = t,
    Ye
}
function tr() {
    if (Ge === null) {
        var t = De.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = Ge.next;
    var e = Ye === null ? De.memoizedState : Ye.next;
    if (e !== null)
        Ye = e,
        Ge = t;
    else {
        if (t === null)
            throw Error(I(310));
        Ge = t,
        t = {
            memoizedState: Ge.memoizedState,
            baseState: Ge.baseState,
            baseQueue: Ge.baseQueue,
            queue: Ge.queue,
            next: null
        },
        Ye === null ? De.memoizedState = Ye = t : Ye = Ye.next = t
    }
    return Ye
}
function Na(t, e) {
    return typeof e == "function" ? e(t) : e
}
function Nd(t) {
    var e = tr()
      , r = e.queue;
    if (r === null)
        throw Error(I(311));
    r.lastRenderedReducer = t;
    var n = Ge
      , s = n.baseQueue
      , i = r.pending;
    if (i !== null) {
        if (s !== null) {
            var o = s.next;
            s.next = i.next,
            i.next = o
        }
        n.baseQueue = s = i,
        r.pending = null
    }
    if (s !== null) {
        i = s.next,
        n = n.baseState;
        var a = o = null
          , l = null
          , u = i;
        do {
            var c = u.lane;
            if (($s & c) === c)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: u.action,
                    hasEagerState: u.hasEagerState,
                    eagerState: u.eagerState,
                    next: null
                }),
                n = u.hasEagerState ? u.eagerState : t(n, u.action);
            else {
                var d = {
                    lane: c,
                    action: u.action,
                    hasEagerState: u.hasEagerState,
                    eagerState: u.eagerState,
                    next: null
                };
                l === null ? (a = l = d,
                o = n) : l = l.next = d,
                De.lanes |= c,
                Fs |= c
            }
            u = u.next
        } while (u !== null && u !== i);
        l === null ? o = n : l.next = a,
        _r(n, e.memoizedState) || (Tt = !0),
        e.memoizedState = n,
        e.baseState = o,
        e.baseQueue = l,
        r.lastRenderedState = n
    }
    if (t = r.interleaved,
    t !== null) {
        s = t;
        do
            i = s.lane,
            De.lanes |= i,
            Fs |= i,
            s = s.next;
        while (s !== t)
    } else
        s === null && (r.lanes = 0);
    return [e.memoizedState, r.dispatch]
}
function Id(t) {
    var e = tr()
      , r = e.queue;
    if (r === null)
        throw Error(I(311));
    r.lastRenderedReducer = t;
    var n = r.dispatch
      , s = r.pending
      , i = e.memoizedState;
    if (s !== null) {
        r.pending = null;
        var o = s = s.next;
        do
            i = t(i, o.action),
            o = o.next;
        while (o !== s);
        _r(i, e.memoizedState) || (Tt = !0),
        e.memoizedState = i,
        e.baseQueue === null && (e.baseState = i),
        r.lastRenderedState = i
    }
    return [i, n]
}
function d0() {}
function f0(t, e) {
    var r = De
      , n = tr()
      , s = e()
      , i = !_r(n.memoizedState, s);
    if (i && (n.memoizedState = s,
    Tt = !0),
    n = n.queue,
    Rp(m0.bind(null, r, n, t), [t]),
    n.getSnapshot !== e || i || Ye !== null && Ye.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        Ia(9, p0.bind(null, r, n, s, e), void 0, null),
        Je === null)
            throw Error(I(349));
        $s & 30 || h0(r, e, s)
    }
    return s
}
function h0(t, e, r) {
    t.flags |= 16384,
    t = {
        getSnapshot: e,
        value: r
    },
    e = De.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    De.updateQueue = e,
    e.stores = [t]) : (r = e.stores,
    r === null ? e.stores = [t] : r.push(t))
}
function p0(t, e, r, n) {
    e.value = r,
    e.getSnapshot = n,
    g0(e) && v0(t)
}
function m0(t, e, r) {
    return r(function() {
        g0(e) && v0(t)
    })
}
function g0(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !_r(t, r)
    } catch {
        return !0
    }
}
function v0(t) {
    var e = on(t, 1);
    e !== null && yr(e, t, 1, -1)
}
function Og(t) {
    var e = Tr();
    return typeof t == "function" && (t = t()),
    e.memoizedState = e.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Na,
        lastRenderedState: t
    },
    e.queue = t,
    t = t.dispatch = L1.bind(null, De, t),
    [e.memoizedState, t]
}
function Ia(t, e, r, n) {
    return t = {
        tag: t,
        create: e,
        destroy: r,
        deps: n,
        next: null
    },
    e = De.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    De.updateQueue = e,
    e.lastEffect = t.next = t) : (r = e.lastEffect,
    r === null ? e.lastEffect = t.next = t : (n = r.next,
    r.next = t,
    t.next = n,
    e.lastEffect = t)),
    t
}
function y0() {
    return tr().memoizedState
}
function mu(t, e, r, n) {
    var s = Tr();
    De.flags |= t,
    s.memoizedState = Ia(1 | e, r, void 0, n === void 0 ? null : n)
}
function Ic(t, e, r, n) {
    var s = tr();
    n = n === void 0 ? null : n;
    var i = void 0;
    if (Ge !== null) {
        var o = Ge.memoizedState;
        if (i = o.destroy,
        n !== null && Tp(n, o.deps)) {
            s.memoizedState = Ia(e, r, i, n);
            return
        }
    }
    De.flags |= t,
    s.memoizedState = Ia(1 | e, r, i, n)
}
function Pg(t, e) {
    return mu(8390656, 8, t, e)
}
function Rp(t, e) {
    return Ic(2048, 8, t, e)
}
function w0(t, e) {
    return Ic(4, 2, t, e)
}
function _0(t, e) {
    return Ic(4, 4, t, e)
}
function b0(t, e) {
    if (typeof e == "function")
        return t = t(),
        e(t),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return t = t(),
        e.current = t,
        function() {
            e.current = null
        }
}
function x0(t, e, r) {
    return r = r != null ? r.concat([t]) : null,
    Ic(4, 4, b0.bind(null, e, t), r)
}
function Ap() {}
function S0(t, e) {
    var r = tr();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Tp(e, n[1]) ? n[0] : (r.memoizedState = [t, e],
    t)
}
function E0(t, e) {
    var r = tr();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Tp(e, n[1]) ? n[0] : (t = t(),
    r.memoizedState = [t, e],
    t)
}
function k0(t, e, r) {
    return $s & 21 ? (_r(r, e) || (r = Rw(),
    De.lanes |= r,
    Fs |= r,
    t.baseState = !0),
    e) : (t.baseState && (t.baseState = !1,
    Tt = !0),
    t.memoizedState = r)
}
function D1(t, e) {
    var r = Se;
    Se = r !== 0 && 4 > r ? r : 4,
    t(!0);
    var n = jd.transition;
    jd.transition = {};
    try {
        t(!1),
        e()
    } finally {
        Se = r,
        jd.transition = n
    }
}
function C0() {
    return tr().memoizedState
}
function M1(t, e, r) {
    var n = Hn(t);
    if (r = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    T0(t))
        O0(e, r);
    else if (r = l0(t, e, r, n),
    r !== null) {
        var s = yt();
        yr(r, t, n, s),
        P0(r, e, n)
    }
}
function L1(t, e, r) {
    var n = Hn(t)
      , s = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (T0(t))
        O0(e, s);
    else {
        var i = t.alternate;
        if (t.lanes === 0 && (i === null || i.lanes === 0) && (i = e.lastRenderedReducer,
        i !== null))
            try {
                var o = e.lastRenderedState
                  , a = i(o, r);
                if (s.hasEagerState = !0,
                s.eagerState = a,
                _r(a, o)) {
                    var l = e.interleaved;
                    l === null ? (s.next = s,
                    xp(e)) : (s.next = l.next,
                    l.next = s),
                    e.interleaved = s;
                    return
                }
            } catch {} finally {}
        r = l0(t, e, s, n),
        r !== null && (s = yt(),
        yr(r, t, n, s),
        P0(r, e, n))
    }
}
function T0(t) {
    var e = t.alternate;
    return t === De || e !== null && e === De
}
function O0(t, e) {
    ca = Hu = !0;
    var r = t.pending;
    r === null ? e.next = e : (e.next = r.next,
    r.next = e),
    t.pending = e
}
function P0(t, e, r) {
    if (r & 4194240) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        lp(t, r)
    }
}
var qu = {
    readContext: er,
    useCallback: ot,
    useContext: ot,
    useEffect: ot,
    useImperativeHandle: ot,
    useInsertionEffect: ot,
    useLayoutEffect: ot,
    useMemo: ot,
    useReducer: ot,
    useRef: ot,
    useState: ot,
    useDebugValue: ot,
    useDeferredValue: ot,
    useTransition: ot,
    useMutableSource: ot,
    useSyncExternalStore: ot,
    useId: ot,
    unstable_isNewReconciler: !1
}
  , $1 = {
    readContext: er,
    useCallback: function(t, e) {
        return Tr().memoizedState = [t, e === void 0 ? null : e],
        t
    },
    useContext: er,
    useEffect: Pg,
    useImperativeHandle: function(t, e, r) {
        return r = r != null ? r.concat([t]) : null,
        mu(4194308, 4, b0.bind(null, e, t), r)
    },
    useLayoutEffect: function(t, e) {
        return mu(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
        return mu(4, 2, t, e)
    },
    useMemo: function(t, e) {
        var r = Tr();
        return e = e === void 0 ? null : e,
        t = t(),
        r.memoizedState = [t, e],
        t
    },
    useReducer: function(t, e, r) {
        var n = Tr();
        return e = r !== void 0 ? r(e) : e,
        n.memoizedState = n.baseState = e,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
        },
        n.queue = t,
        t = t.dispatch = M1.bind(null, De, t),
        [n.memoizedState, t]
    },
    useRef: function(t) {
        var e = Tr();
        return t = {
            current: t
        },
        e.memoizedState = t
    },
    useState: Og,
    useDebugValue: Ap,
    useDeferredValue: function(t) {
        return Tr().memoizedState = t
    },
    useTransition: function() {
        var t = Og(!1)
          , e = t[0];
        return t = D1.bind(null, t[1]),
        Tr().memoizedState = t,
        [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, r) {
        var n = De
          , s = Tr();
        if (Ae) {
            if (r === void 0)
                throw Error(I(407));
            r = r()
        } else {
            if (r = e(),
            Je === null)
                throw Error(I(349));
            $s & 30 || h0(n, e, r)
        }
        s.memoizedState = r;
        var i = {
            value: r,
            getSnapshot: e
        };
        return s.queue = i,
        Pg(m0.bind(null, n, i, t), [t]),
        n.flags |= 2048,
        Ia(9, p0.bind(null, n, i, r, e), void 0, null),
        r
    },
    useId: function() {
        var t = Tr()
          , e = Je.identifierPrefix;
        if (Ae) {
            var r = en
              , n = Xr;
            r = (n & ~(1 << 32 - vr(n) - 1)).toString(32) + r,
            e = ":" + e + "R" + r,
            r = ja++,
            0 < r && (e += "H" + r.toString(32)),
            e += ":"
        } else
            r = I1++,
            e = ":" + e + "r" + r.toString(32) + ":";
        return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , F1 = {
    readContext: er,
    useCallback: S0,
    useContext: er,
    useEffect: Rp,
    useImperativeHandle: x0,
    useInsertionEffect: w0,
    useLayoutEffect: _0,
    useMemo: E0,
    useReducer: Nd,
    useRef: y0,
    useState: function() {
        return Nd(Na)
    },
    useDebugValue: Ap,
    useDeferredValue: function(t) {
        var e = tr();
        return k0(e, Ge.memoizedState, t)
    },
    useTransition: function() {
        var t = Nd(Na)[0]
          , e = tr().memoizedState;
        return [t, e]
    },
    useMutableSource: d0,
    useSyncExternalStore: f0,
    useId: C0,
    unstable_isNewReconciler: !1
}
  , U1 = {
    readContext: er,
    useCallback: S0,
    useContext: er,
    useEffect: Rp,
    useImperativeHandle: x0,
    useInsertionEffect: w0,
    useLayoutEffect: _0,
    useMemo: E0,
    useReducer: Id,
    useRef: y0,
    useState: function() {
        return Id(Na)
    },
    useDebugValue: Ap,
    useDeferredValue: function(t) {
        var e = tr();
        return Ge === null ? e.memoizedState = t : k0(e, Ge.memoizedState, t)
    },
    useTransition: function() {
        var t = Id(Na)[0]
          , e = tr().memoizedState;
        return [t, e]
    },
    useMutableSource: d0,
    useSyncExternalStore: f0,
    useId: C0,
    unstable_isNewReconciler: !1
};
function or(t, e) {
    if (t && t.defaultProps) {
        e = Me({}, e),
        t = t.defaultProps;
        for (var r in t)
            e[r] === void 0 && (e[r] = t[r]);
        return e
    }
    return e
}
function Wf(t, e, r, n) {
    e = t.memoizedState,
    r = r(n, e),
    r = r == null ? e : Me({}, e, r),
    t.memoizedState = r,
    t.lanes === 0 && (t.updateQueue.baseState = r)
}
var Dc = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Qs(t) === t : !1
    },
    enqueueSetState: function(t, e, r) {
        t = t._reactInternals;
        var n = yt()
          , s = Hn(t)
          , i = tn(n, s);
        i.payload = e,
        r != null && (i.callback = r),
        e = zn(t, i, s),
        e !== null && (yr(e, t, s, n),
        hu(e, t, s))
    },
    enqueueReplaceState: function(t, e, r) {
        t = t._reactInternals;
        var n = yt()
          , s = Hn(t)
          , i = tn(n, s);
        i.tag = 1,
        i.payload = e,
        r != null && (i.callback = r),
        e = zn(t, i, s),
        e !== null && (yr(e, t, s, n),
        hu(e, t, s))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var r = yt()
          , n = Hn(t)
          , s = tn(r, n);
        s.tag = 2,
        e != null && (s.callback = e),
        e = zn(t, s, n),
        e !== null && (yr(e, t, n, r),
        hu(e, t, n))
    }
};
function Rg(t, e, r, n, s, i, o) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, i, o) : e.prototype && e.prototype.isPureReactComponent ? !Ca(r, n) || !Ca(s, i) : !0
}
function R0(t, e, r) {
    var n = !1
      , s = Gn
      , i = e.contextType;
    return typeof i == "object" && i !== null ? i = er(i) : (s = Pt(e) ? Ms : ct.current,
    n = e.contextTypes,
    i = (n = n != null) ? ao(t, s) : Gn),
    e = new e(r,i),
    t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Dc,
    t.stateNode = e,
    e._reactInternals = t,
    n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = s,
    t.__reactInternalMemoizedMaskedChildContext = i),
    e
}
function Ag(t, e, r, n) {
    t = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, n),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, n),
    e.state !== t && Dc.enqueueReplaceState(e, e.state, null)
}
function Hf(t, e, r, n) {
    var s = t.stateNode;
    s.props = r,
    s.state = t.memoizedState,
    s.refs = {},
    Sp(t);
    var i = e.contextType;
    typeof i == "object" && i !== null ? s.context = er(i) : (i = Pt(e) ? Ms : ct.current,
    s.context = ao(t, i)),
    s.state = t.memoizedState,
    i = e.getDerivedStateFromProps,
    typeof i == "function" && (Wf(t, e, i, r),
    s.state = t.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (e = s.state,
    typeof s.componentWillMount == "function" && s.componentWillMount(),
    typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(),
    e !== s.state && Dc.enqueueReplaceState(s, s.state, null),
    zu(t, r, s, n),
    s.state = t.memoizedState),
    typeof s.componentDidMount == "function" && (t.flags |= 4194308)
}
function fo(t, e) {
    try {
        var r = ""
          , n = e;
        do
            r += pk(n),
            n = n.return;
        while (n);
        var s = r
    } catch (i) {
        s = `
Error generating stack: ` + i.message + `
` + i.stack
    }
    return {
        value: t,
        source: e,
        stack: s,
        digest: null
    }
}
function Dd(t, e, r) {
    return {
        value: t,
        source: null,
        stack: r ?? null,
        digest: e ?? null
    }
}
function qf(t, e) {
    try {
        console.error(e.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var V1 = typeof WeakMap == "function" ? WeakMap : Map;
function A0(t, e, r) {
    r = tn(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var n = e.value;
    return r.callback = function() {
        Gu || (Gu = !0,
        rh = n),
        qf(t, e)
    }
    ,
    r
}
function j0(t, e, r) {
    r = tn(-1, r),
    r.tag = 3;
    var n = t.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var s = e.value;
        r.payload = function() {
            return n(s)
        }
        ,
        r.callback = function() {
            qf(t, e)
        }
    }
    var i = t.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (r.callback = function() {
        qf(t, e),
        typeof n != "function" && (Wn === null ? Wn = new Set([this]) : Wn.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    r
}
function jg(t, e, r) {
    var n = t.pingCache;
    if (n === null) {
        n = t.pingCache = new V1;
        var s = new Set;
        n.set(e, s)
    } else
        s = n.get(e),
        s === void 0 && (s = new Set,
        n.set(e, s));
    s.has(r) || (s.add(r),
    t = tC.bind(null, t, e, r),
    e.then(t, t))
}
function Ng(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function Ig(t, e, r, n, s) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = s,
    t) : (t === e ? t.flags |= 65536 : (t.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (e = tn(-1, 1),
    e.tag = 2,
    zn(r, e, 1))),
    r.lanes |= 1),
    t)
}
var B1 = fn.ReactCurrentOwner
  , Tt = !1;
function mt(t, e, r, n) {
    e.child = t === null ? a0(e, null, r, n) : uo(e, t.child, r, n)
}
function Dg(t, e, r, n, s) {
    r = r.render;
    var i = e.ref;
    return Li(e, s),
    n = Op(t, e, r, n, i, s),
    r = Pp(),
    t !== null && !Tt ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    an(t, e, s)) : (Ae && r && gp(e),
    e.flags |= 1,
    mt(t, e, n, s),
    e.child)
}
function Mg(t, e, r, n, s) {
    if (t === null) {
        var i = r.type;
        return typeof i == "function" && !Fp(i) && i.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15,
        e.type = i,
        N0(t, e, i, n, s)) : (t = wu(r.type, null, n, e, e.mode, s),
        t.ref = e.ref,
        t.return = e,
        e.child = t)
    }
    if (i = t.child,
    !(t.lanes & s)) {
        var o = i.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : Ca,
        r(o, n) && t.ref === e.ref)
            return an(t, e, s)
    }
    return e.flags |= 1,
    t = qn(i, n),
    t.ref = e.ref,
    t.return = e,
    e.child = t
}
function N0(t, e, r, n, s) {
    if (t !== null) {
        var i = t.memoizedProps;
        if (Ca(i, n) && t.ref === e.ref)
            if (Tt = !1,
            e.pendingProps = n = i,
            (t.lanes & s) !== 0)
                t.flags & 131072 && (Tt = !0);
            else
                return e.lanes = t.lanes,
                an(t, e, s)
    }
    return Kf(t, e, r, n, s)
}
function I0(t, e, r) {
    var n = e.pendingProps
      , s = n.children
      , i = t !== null ? t.memoizedState : null;
    if (n.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Ce(Ri, It),
            It |= r;
        else {
            if (!(r & 1073741824))
                return t = i !== null ? i.baseLanes | r : r,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                Ce(Ri, It),
                It |= t,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            n = i !== null ? i.baseLanes : r,
            Ce(Ri, It),
            It |= n
        }
    else
        i !== null ? (n = i.baseLanes | r,
        e.memoizedState = null) : n = r,
        Ce(Ri, It),
        It |= n;
    return mt(t, e, s, r),
    e.child
}
function D0(t, e) {
    var r = e.ref;
    (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 512,
    e.flags |= 2097152)
}
function Kf(t, e, r, n, s) {
    var i = Pt(r) ? Ms : ct.current;
    return i = ao(e, i),
    Li(e, s),
    r = Op(t, e, r, n, i, s),
    n = Pp(),
    t !== null && !Tt ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    an(t, e, s)) : (Ae && n && gp(e),
    e.flags |= 1,
    mt(t, e, r, s),
    e.child)
}
function Lg(t, e, r, n, s) {
    if (Pt(r)) {
        var i = !0;
        $u(e)
    } else
        i = !1;
    if (Li(e, s),
    e.stateNode === null)
        gu(t, e),
        R0(e, r, n),
        Hf(e, r, n, s),
        n = !0;
    else if (t === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , u = r.contextType;
        typeof u == "object" && u !== null ? u = er(u) : (u = Pt(r) ? Ms : ct.current,
        u = ao(e, u));
        var c = r.getDerivedStateFromProps
          , d = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== u) && Ag(e, o, n, u),
        Sn = !1;
        var f = e.memoizedState;
        o.state = f,
        zu(e, n, o, s),
        l = e.memoizedState,
        a !== n || f !== l || Ot.current || Sn ? (typeof c == "function" && (Wf(e, r, c, n),
        l = e.memoizedState),
        (a = Sn || Rg(e, r, a, n, f, l, u)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = n,
        e.memoizedState = l),
        o.props = n,
        o.state = l,
        o.context = u,
        n = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        n = !1)
    } else {
        o = e.stateNode,
        u0(t, e),
        a = e.memoizedProps,
        u = e.type === e.elementType ? a : or(e.type, a),
        o.props = u,
        d = e.pendingProps,
        f = o.context,
        l = r.contextType,
        typeof l == "object" && l !== null ? l = er(l) : (l = Pt(r) ? Ms : ct.current,
        l = ao(e, l));
        var p = r.getDerivedStateFromProps;
        (c = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || f !== l) && Ag(e, o, n, l),
        Sn = !1,
        f = e.memoizedState,
        o.state = f,
        zu(e, n, o, s);
        var g = e.memoizedState;
        a !== d || f !== g || Ot.current || Sn ? (typeof p == "function" && (Wf(e, r, p, n),
        g = e.memoizedState),
        (u = Sn || Rg(e, r, u, n, f, g, l) || !1) ? (c || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, g, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, g, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024),
        e.memoizedProps = n,
        e.memoizedState = g),
        o.props = n,
        o.state = g,
        o.context = l,
        n = u) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024),
        n = !1)
    }
    return Gf(t, e, r, n, i, s)
}
function Gf(t, e, r, n, s, i) {
    D0(t, e);
    var o = (e.flags & 128) !== 0;
    if (!n && !o)
        return s && xg(e, r, !1),
        an(t, e, i);
    n = e.stateNode,
    B1.current = e;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return e.flags |= 1,
    t !== null && o ? (e.child = uo(e, t.child, null, i),
    e.child = uo(e, null, a, i)) : mt(t, e, a, i),
    e.memoizedState = n.state,
    s && xg(e, r, !0),
    e.child
}
function M0(t) {
    var e = t.stateNode;
    e.pendingContext ? bg(t, e.pendingContext, e.pendingContext !== e.context) : e.context && bg(t, e.context, !1),
    Ep(t, e.containerInfo)
}
function $g(t, e, r, n, s) {
    return lo(),
    yp(s),
    e.flags |= 256,
    mt(t, e, r, n),
    e.child
}
var Qf = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Zf(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function L0(t, e, r) {
    var n = e.pendingProps, s = Ie.current, i = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (s & 2) !== 0),
    a ? (i = !0,
    e.flags &= -129) : (t === null || t.memoizedState !== null) && (s |= 1),
    Ce(Ie, s & 1),
    t === null)
        return Bf(e),
        t = e.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = n.children,
        t = n.fallback,
        i ? (n = e.mode,
        i = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(n & 1) && i !== null ? (i.childLanes = 0,
        i.pendingProps = o) : i = $c(o, n, 0, null),
        t = Is(t, n, r, null),
        i.return = e,
        t.return = e,
        i.sibling = t,
        e.child = i,
        e.child.memoizedState = Zf(r),
        e.memoizedState = Qf,
        t) : jp(e, o));
    if (s = t.memoizedState,
    s !== null && (a = s.dehydrated,
    a !== null))
        return z1(t, e, o, n, a, s, r);
    if (i) {
        i = n.fallback,
        o = e.mode,
        s = t.child,
        a = s.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(o & 1) && e.child !== s ? (n = e.child,
        n.childLanes = 0,
        n.pendingProps = l,
        e.deletions = null) : (n = qn(s, l),
        n.subtreeFlags = s.subtreeFlags & 14680064),
        a !== null ? i = qn(a, i) : (i = Is(i, o, r, null),
        i.flags |= 2),
        i.return = e,
        n.return = e,
        n.sibling = i,
        e.child = n,
        n = i,
        i = e.child,
        o = t.child.memoizedState,
        o = o === null ? Zf(r) : {
            baseLanes: o.baseLanes | r,
            cachePool: null,
            transitions: o.transitions
        },
        i.memoizedState = o,
        i.childLanes = t.childLanes & ~r,
        e.memoizedState = Qf,
        n
    }
    return i = t.child,
    t = i.sibling,
    n = qn(i, {
        mode: "visible",
        children: n.children
    }),
    !(e.mode & 1) && (n.lanes = r),
    n.return = e,
    n.sibling = null,
    t !== null && (r = e.deletions,
    r === null ? (e.deletions = [t],
    e.flags |= 16) : r.push(t)),
    e.child = n,
    e.memoizedState = null,
    n
}
function jp(t, e) {
    return e = $c({
        mode: "visible",
        children: e
    }, t.mode, 0, null),
    e.return = t,
    t.child = e
}
function $l(t, e, r, n) {
    return n !== null && yp(n),
    uo(e, t.child, null, r),
    t = jp(e, e.pendingProps.children),
    t.flags |= 2,
    e.memoizedState = null,
    t
}
function z1(t, e, r, n, s, i, o) {
    if (r)
        return e.flags & 256 ? (e.flags &= -257,
        n = Dd(Error(I(422))),
        $l(t, e, o, n)) : e.memoizedState !== null ? (e.child = t.child,
        e.flags |= 128,
        null) : (i = n.fallback,
        s = e.mode,
        n = $c({
            mode: "visible",
            children: n.children
        }, s, 0, null),
        i = Is(i, s, o, null),
        i.flags |= 2,
        n.return = e,
        i.return = e,
        n.sibling = i,
        e.child = n,
        e.mode & 1 && uo(e, t.child, null, o),
        e.child.memoizedState = Zf(o),
        e.memoizedState = Qf,
        i);
    if (!(e.mode & 1))
        return $l(t, e, o, null);
    if (s.data === "$!") {
        if (n = s.nextSibling && s.nextSibling.dataset,
        n)
            var a = n.dgst;
        return n = a,
        i = Error(I(419)),
        n = Dd(i, n, void 0),
        $l(t, e, o, n)
    }
    if (a = (o & t.childLanes) !== 0,
    Tt || a) {
        if (n = Je,
        n !== null) {
            switch (o & -o) {
            case 4:
                s = 2;
                break;
            case 16:
                s = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                s = 32;
                break;
            case 536870912:
                s = 268435456;
                break;
            default:
                s = 0
            }
            s = s & (n.suspendedLanes | o) ? 0 : s,
            s !== 0 && s !== i.retryLane && (i.retryLane = s,
            on(t, s),
            yr(n, t, s, -1))
        }
        return $p(),
        n = Dd(Error(I(421))),
        $l(t, e, o, n)
    }
    return s.data === "$?" ? (e.flags |= 128,
    e.child = t.child,
    e = rC.bind(null, t),
    s._reactRetry = e,
    null) : (t = i.treeContext,
    Ut = Bn(s.nextSibling),
    Vt = e,
    Ae = !0,
    dr = null,
    t !== null && (Qt[Zt++] = Xr,
    Qt[Zt++] = en,
    Qt[Zt++] = Ls,
    Xr = t.id,
    en = t.overflow,
    Ls = e),
    e = jp(e, n.children),
    e.flags |= 4096,
    e)
}
function Fg(t, e, r) {
    t.lanes |= e;
    var n = t.alternate;
    n !== null && (n.lanes |= e),
    zf(t.return, e, r)
}
function Md(t, e, r, n, s) {
    var i = t.memoizedState;
    i === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: s
    } : (i.isBackwards = e,
    i.rendering = null,
    i.renderingStartTime = 0,
    i.last = n,
    i.tail = r,
    i.tailMode = s)
}
function $0(t, e, r) {
    var n = e.pendingProps
      , s = n.revealOrder
      , i = n.tail;
    if (mt(t, e, n.children, r),
    n = Ie.current,
    n & 2)
        n = n & 1 | 2,
        e.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && Fg(t, r, e);
                else if (t.tag === 19)
                    Fg(t, r, e);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === e)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === e)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        n &= 1
    }
    if (Ce(Ie, n),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (s) {
        case "forwards":
            for (r = e.child,
            s = null; r !== null; )
                t = r.alternate,
                t !== null && Wu(t) === null && (s = r),
                r = r.sibling;
            r = s,
            r === null ? (s = e.child,
            e.child = null) : (s = r.sibling,
            r.sibling = null),
            Md(e, !1, s, r, i);
            break;
        case "backwards":
            for (r = null,
            s = e.child,
            e.child = null; s !== null; ) {
                if (t = s.alternate,
                t !== null && Wu(t) === null) {
                    e.child = s;
                    break
                }
                t = s.sibling,
                s.sibling = r,
                r = s,
                s = t
            }
            Md(e, !0, r, null, i);
            break;
        case "together":
            Md(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function gu(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function an(t, e, r) {
    if (t !== null && (e.dependencies = t.dependencies),
    Fs |= e.lanes,
    !(r & e.childLanes))
        return null;
    if (t !== null && e.child !== t.child)
        throw Error(I(153));
    if (e.child !== null) {
        for (t = e.child,
        r = qn(t, t.pendingProps),
        e.child = r,
        r.return = e; t.sibling !== null; )
            t = t.sibling,
            r = r.sibling = qn(t, t.pendingProps),
            r.return = e;
        r.sibling = null
    }
    return e.child
}
function W1(t, e, r) {
    switch (e.tag) {
    case 3:
        M0(e),
        lo();
        break;
    case 5:
        c0(e);
        break;
    case 1:
        Pt(e.type) && $u(e);
        break;
    case 4:
        Ep(e, e.stateNode.containerInfo);
        break;
    case 10:
        var n = e.type._context
          , s = e.memoizedProps.value;
        Ce(Vu, n._currentValue),
        n._currentValue = s;
        break;
    case 13:
        if (n = e.memoizedState,
        n !== null)
            return n.dehydrated !== null ? (Ce(Ie, Ie.current & 1),
            e.flags |= 128,
            null) : r & e.child.childLanes ? L0(t, e, r) : (Ce(Ie, Ie.current & 1),
            t = an(t, e, r),
            t !== null ? t.sibling : null);
        Ce(Ie, Ie.current & 1);
        break;
    case 19:
        if (n = (r & e.childLanes) !== 0,
        t.flags & 128) {
            if (n)
                return $0(t, e, r);
            e.flags |= 128
        }
        if (s = e.memoizedState,
        s !== null && (s.rendering = null,
        s.tail = null,
        s.lastEffect = null),
        Ce(Ie, Ie.current),
        n)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        I0(t, e, r)
    }
    return an(t, e, r)
}
var F0, Yf, U0, V0;
F0 = function(t, e) {
    for (var r = e.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            t.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === e)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === e)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
Yf = function() {}
;
U0 = function(t, e, r, n) {
    var s = t.memoizedProps;
    if (s !== n) {
        t = e.stateNode,
        Ss(Mr.current);
        var i = null;
        switch (r) {
        case "input":
            s = wf(t, s),
            n = wf(t, n),
            i = [];
            break;
        case "select":
            s = Me({}, s, {
                value: void 0
            }),
            n = Me({}, n, {
                value: void 0
            }),
            i = [];
            break;
        case "textarea":
            s = xf(t, s),
            n = xf(t, n),
            i = [];
            break;
        default:
            typeof s.onClick != "function" && typeof n.onClick == "function" && (t.onclick = Mu)
        }
        Ef(r, n);
        var o;
        r = null;
        for (u in s)
            if (!n.hasOwnProperty(u) && s.hasOwnProperty(u) && s[u] != null)
                if (u === "style") {
                    var a = s[u];
                    for (o in a)
                        a.hasOwnProperty(o) && (r || (r = {}),
                        r[o] = "")
                } else
                    u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (wa.hasOwnProperty(u) ? i || (i = []) : (i = i || []).push(u, null));
        for (u in n) {
            var l = n[u];
            if (a = s != null ? s[u] : void 0,
            n.hasOwnProperty(u) && l !== a && (l != null || a != null))
                if (u === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}),
                            r[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}),
                            r[o] = l[o])
                    } else
                        r || (i || (i = []),
                        i.push(u, r)),
                        r = l;
                else
                    u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (i = i || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (wa.hasOwnProperty(u) ? (l != null && u === "onScroll" && Oe("scroll", t),
                    i || a === l || (i = [])) : (i = i || []).push(u, l))
        }
        r && (i = i || []).push("style", r);
        var u = i;
        (e.updateQueue = u) && (e.flags |= 4)
    }
}
;
V0 = function(t, e, r, n) {
    r !== n && (e.flags |= 4)
}
;
function Bo(t, e) {
    if (!Ae)
        switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var r = null; e !== null; )
                e.alternate !== null && (r = e),
                e = e.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = t.tail;
            for (var n = null; r !== null; )
                r.alternate !== null && (n = r),
                r = r.sibling;
            n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null
        }
}
function at(t) {
    var e = t.alternate !== null && t.alternate.child === t.child
      , r = 0
      , n = 0;
    if (e)
        for (var s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags & 14680064,
            n |= s.flags & 14680064,
            s.return = t,
            s = s.sibling;
    else
        for (s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags,
            n |= s.flags,
            s.return = t,
            s = s.sibling;
    return t.subtreeFlags |= n,
    t.childLanes = r,
    e
}
function H1(t, e, r) {
    var n = e.pendingProps;
    switch (vp(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return at(e),
        null;
    case 1:
        return Pt(e.type) && Lu(),
        at(e),
        null;
    case 3:
        return n = e.stateNode,
        co(),
        Re(Ot),
        Re(ct),
        Cp(),
        n.pendingContext && (n.context = n.pendingContext,
        n.pendingContext = null),
        (t === null || t.child === null) && (Ml(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        dr !== null && (ih(dr),
        dr = null))),
        Yf(t, e),
        at(e),
        null;
    case 5:
        kp(e);
        var s = Ss(Aa.current);
        if (r = e.type,
        t !== null && e.stateNode != null)
            U0(t, e, r, n, s),
            t.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!n) {
                if (e.stateNode === null)
                    throw Error(I(166));
                return at(e),
                null
            }
            if (t = Ss(Mr.current),
            Ml(e)) {
                n = e.stateNode,
                r = e.type;
                var i = e.memoizedProps;
                switch (n[jr] = e,
                n[Pa] = i,
                t = (e.mode & 1) !== 0,
                r) {
                case "dialog":
                    Oe("cancel", n),
                    Oe("close", n);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Oe("load", n);
                    break;
                case "video":
                case "audio":
                    for (s = 0; s < ea.length; s++)
                        Oe(ea[s], n);
                    break;
                case "source":
                    Oe("error", n);
                    break;
                case "img":
                case "image":
                case "link":
                    Oe("error", n),
                    Oe("load", n);
                    break;
                case "details":
                    Oe("toggle", n);
                    break;
                case "input":
                    Gm(n, i),
                    Oe("invalid", n);
                    break;
                case "select":
                    n._wrapperState = {
                        wasMultiple: !!i.multiple
                    },
                    Oe("invalid", n);
                    break;
                case "textarea":
                    Zm(n, i),
                    Oe("invalid", n)
                }
                Ef(r, i),
                s = null;
                for (var o in i)
                    if (i.hasOwnProperty(o)) {
                        var a = i[o];
                        o === "children" ? typeof a == "string" ? n.textContent !== a && (i.suppressHydrationWarning !== !0 && Dl(n.textContent, a, t),
                        s = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && Dl(n.textContent, a, t),
                        s = ["children", "" + a]) : wa.hasOwnProperty(o) && a != null && o === "onScroll" && Oe("scroll", n)
                    }
                switch (r) {
                case "input":
                    Tl(n),
                    Qm(n, i, !0);
                    break;
                case "textarea":
                    Tl(n),
                    Ym(n);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof i.onClick == "function" && (n.onclick = Mu)
                }
                n = s,
                e.updateQueue = n,
                n !== null && (e.flags |= 4)
            } else {
                o = s.nodeType === 9 ? s : s.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = mw(r)),
                t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = o.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = o.createElement(r, {
                    is: n.is
                }) : (t = o.createElement(r),
                r === "select" && (o = t,
                n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : t = o.createElementNS(t, r),
                t[jr] = e,
                t[Pa] = n,
                F0(t, e, !1, !1),
                e.stateNode = t;
                e: {
                    switch (o = kf(r, n),
                    r) {
                    case "dialog":
                        Oe("cancel", t),
                        Oe("close", t),
                        s = n;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Oe("load", t),
                        s = n;
                        break;
                    case "video":
                    case "audio":
                        for (s = 0; s < ea.length; s++)
                            Oe(ea[s], t);
                        s = n;
                        break;
                    case "source":
                        Oe("error", t),
                        s = n;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Oe("error", t),
                        Oe("load", t),
                        s = n;
                        break;
                    case "details":
                        Oe("toggle", t),
                        s = n;
                        break;
                    case "input":
                        Gm(t, n),
                        s = wf(t, n),
                        Oe("invalid", t);
                        break;
                    case "option":
                        s = n;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!n.multiple
                        },
                        s = Me({}, n, {
                            value: void 0
                        }),
                        Oe("invalid", t);
                        break;
                    case "textarea":
                        Zm(t, n),
                        s = xf(t, n),
                        Oe("invalid", t);
                        break;
                    default:
                        s = n
                    }
                    Ef(r, s),
                    a = s;
                    for (i in a)
                        if (a.hasOwnProperty(i)) {
                            var l = a[i];
                            i === "style" ? yw(t, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && gw(t, l)) : i === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && _a(t, l) : typeof l == "number" && _a(t, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (wa.hasOwnProperty(i) ? l != null && i === "onScroll" && Oe("scroll", t) : l != null && rp(t, i, l, o))
                        }
                    switch (r) {
                    case "input":
                        Tl(t),
                        Qm(t, n, !1);
                        break;
                    case "textarea":
                        Tl(t),
                        Ym(t);
                        break;
                    case "option":
                        n.value != null && t.setAttribute("value", "" + Kn(n.value));
                        break;
                    case "select":
                        t.multiple = !!n.multiple,
                        i = n.value,
                        i != null ? Ni(t, !!n.multiple, i, !1) : n.defaultValue != null && Ni(t, !!n.multiple, n.defaultValue, !0);
                        break;
                    default:
                        typeof s.onClick == "function" && (t.onclick = Mu)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!n.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                }
                n && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return at(e),
        null;
    case 6:
        if (t && e.stateNode != null)
            V0(t, e, t.memoizedProps, n);
        else {
            if (typeof n != "string" && e.stateNode === null)
                throw Error(I(166));
            if (r = Ss(Aa.current),
            Ss(Mr.current),
            Ml(e)) {
                if (n = e.stateNode,
                r = e.memoizedProps,
                n[jr] = e,
                (i = n.nodeValue !== r) && (t = Vt,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        Dl(n.nodeValue, r, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && Dl(n.nodeValue, r, (t.mode & 1) !== 0)
                    }
                i && (e.flags |= 4)
            } else
                n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n),
                n[jr] = e,
                e.stateNode = n
        }
        return at(e),
        null;
    case 13:
        if (Re(Ie),
        n = e.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (Ae && Ut !== null && e.mode & 1 && !(e.flags & 128))
                i0(),
                lo(),
                e.flags |= 98560,
                i = !1;
            else if (i = Ml(e),
            n !== null && n.dehydrated !== null) {
                if (t === null) {
                    if (!i)
                        throw Error(I(318));
                    if (i = e.memoizedState,
                    i = i !== null ? i.dehydrated : null,
                    !i)
                        throw Error(I(317));
                    i[jr] = e
                } else
                    lo(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                at(e),
                i = !1
            } else
                dr !== null && (ih(dr),
                dr = null),
                i = !0;
            if (!i)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = r,
        e) : (n = n !== null,
        n !== (t !== null && t.memoizedState !== null) && n && (e.child.flags |= 8192,
        e.mode & 1 && (t === null || Ie.current & 1 ? Ze === 0 && (Ze = 3) : $p())),
        e.updateQueue !== null && (e.flags |= 4),
        at(e),
        null);
    case 4:
        return co(),
        Yf(t, e),
        t === null && Ta(e.stateNode.containerInfo),
        at(e),
        null;
    case 10:
        return bp(e.type._context),
        at(e),
        null;
    case 17:
        return Pt(e.type) && Lu(),
        at(e),
        null;
    case 19:
        if (Re(Ie),
        i = e.memoizedState,
        i === null)
            return at(e),
            null;
        if (n = (e.flags & 128) !== 0,
        o = i.rendering,
        o === null)
            if (n)
                Bo(i, !1);
            else {
                if (Ze !== 0 || t !== null && t.flags & 128)
                    for (t = e.child; t !== null; ) {
                        if (o = Wu(t),
                        o !== null) {
                            for (e.flags |= 128,
                            Bo(i, !1),
                            n = o.updateQueue,
                            n !== null && (e.updateQueue = n,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            n = r,
                            r = e.child; r !== null; )
                                i = r,
                                t = n,
                                i.flags &= 14680066,
                                o = i.alternate,
                                o === null ? (i.childLanes = 0,
                                i.lanes = t,
                                i.child = null,
                                i.subtreeFlags = 0,
                                i.memoizedProps = null,
                                i.memoizedState = null,
                                i.updateQueue = null,
                                i.dependencies = null,
                                i.stateNode = null) : (i.childLanes = o.childLanes,
                                i.lanes = o.lanes,
                                i.child = o.child,
                                i.subtreeFlags = 0,
                                i.deletions = null,
                                i.memoizedProps = o.memoizedProps,
                                i.memoizedState = o.memoizedState,
                                i.updateQueue = o.updateQueue,
                                i.type = o.type,
                                t = o.dependencies,
                                i.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                r = r.sibling;
                            return Ce(Ie, Ie.current & 1 | 2),
                            e.child
                        }
                        t = t.sibling
                    }
                i.tail !== null && Ue() > ho && (e.flags |= 128,
                n = !0,
                Bo(i, !1),
                e.lanes = 4194304)
            }
        else {
            if (!n)
                if (t = Wu(o),
                t !== null) {
                    if (e.flags |= 128,
                    n = !0,
                    r = t.updateQueue,
                    r !== null && (e.updateQueue = r,
                    e.flags |= 4),
                    Bo(i, !0),
                    i.tail === null && i.tailMode === "hidden" && !o.alternate && !Ae)
                        return at(e),
                        null
                } else
                    2 * Ue() - i.renderingStartTime > ho && r !== 1073741824 && (e.flags |= 128,
                    n = !0,
                    Bo(i, !1),
                    e.lanes = 4194304);
            i.isBackwards ? (o.sibling = e.child,
            e.child = o) : (r = i.last,
            r !== null ? r.sibling = o : e.child = o,
            i.last = o)
        }
        return i.tail !== null ? (e = i.tail,
        i.rendering = e,
        i.tail = e.sibling,
        i.renderingStartTime = Ue(),
        e.sibling = null,
        r = Ie.current,
        Ce(Ie, n ? r & 1 | 2 : r & 1),
        e) : (at(e),
        null);
    case 22:
    case 23:
        return Lp(),
        n = e.memoizedState !== null,
        t !== null && t.memoizedState !== null !== n && (e.flags |= 8192),
        n && e.mode & 1 ? It & 1073741824 && (at(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : at(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(I(156, e.tag))
}
function q1(t, e) {
    switch (vp(e),
    e.tag) {
    case 1:
        return Pt(e.type) && Lu(),
        t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 3:
        return co(),
        Re(Ot),
        Re(ct),
        Cp(),
        t = e.flags,
        t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128,
        e) : null;
    case 5:
        return kp(e),
        null;
    case 13:
        if (Re(Ie),
        t = e.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(I(340));
            lo()
        }
        return t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 19:
        return Re(Ie),
        null;
    case 4:
        return co(),
        null;
    case 10:
        return bp(e.type._context),
        null;
    case 22:
    case 23:
        return Lp(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Fl = !1
  , ut = !1
  , K1 = typeof WeakSet == "function" ? WeakSet : Set
  , K = null;
function Pi(t, e) {
    var r = t.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (n) {
                $e(t, e, n)
            }
        else
            r.current = null
}
function Jf(t, e, r) {
    try {
        r()
    } catch (n) {
        $e(t, e, n)
    }
}
var Ug = !1;
function G1(t, e) {
    if (Df = Nu,
    t = qw(),
    mp(t)) {
        if ("selectionStart"in t)
            var r = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                r = (r = t.ownerDocument) && r.defaultView || window;
                var n = r.getSelection && r.getSelection();
                if (n && n.rangeCount !== 0) {
                    r = n.anchorNode;
                    var s = n.anchorOffset
                      , i = n.focusNode;
                    n = n.focusOffset;
                    try {
                        r.nodeType,
                        i.nodeType
                    } catch {
                        r = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , u = 0
                      , c = 0
                      , d = t
                      , f = null;
                    t: for (; ; ) {
                        for (var p; d !== r || s !== 0 && d.nodeType !== 3 || (a = o + s),
                        d !== i || n !== 0 && d.nodeType !== 3 || (l = o + n),
                        d.nodeType === 3 && (o += d.nodeValue.length),
                        (p = d.firstChild) !== null; )
                            f = d,
                            d = p;
                        for (; ; ) {
                            if (d === t)
                                break t;
                            if (f === r && ++u === s && (a = o),
                            f === i && ++c === n && (l = o),
                            (p = d.nextSibling) !== null)
                                break;
                            d = f,
                            f = d.parentNode
                        }
                        d = p
                    }
                    r = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (Mf = {
        focusedElem: t,
        selectionRange: r
    },
    Nu = !1,
    K = e; K !== null; )
        if (e = K,
        t = e.child,
        (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e,
            K = t;
        else
            for (; K !== null; ) {
                e = K;
                try {
                    var g = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (g !== null) {
                                var h = g.memoizedProps
                                  , w = g.memoizedState
                                  , v = e.stateNode
                                  , m = v.getSnapshotBeforeUpdate(e.elementType === e.type ? h : or(e.type, h), w);
                                v.__reactInternalSnapshotBeforeUpdate = m
                            }
                            break;
                        case 3:
                            var _ = e.stateNode.containerInfo;
                            _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(I(163))
                        }
                } catch (x) {
                    $e(e, e.return, x)
                }
                if (t = e.sibling,
                t !== null) {
                    t.return = e.return,
                    K = t;
                    break
                }
                K = e.return
            }
    return g = Ug,
    Ug = !1,
    g
}
function da(t, e, r) {
    var n = e.updateQueue;
    if (n = n !== null ? n.lastEffect : null,
    n !== null) {
        var s = n = n.next;
        do {
            if ((s.tag & t) === t) {
                var i = s.destroy;
                s.destroy = void 0,
                i !== void 0 && Jf(e, r, i)
            }
            s = s.next
        } while (s !== n)
    }
}
function Mc(t, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var r = e = e.next;
        do {
            if ((r.tag & t) === t) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== e)
    }
}
function Xf(t) {
    var e = t.ref;
    if (e !== null) {
        var r = t.stateNode;
        switch (t.tag) {
        case 5:
            t = r;
            break;
        default:
            t = r
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}
function B0(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null,
    B0(e)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (e = t.stateNode,
    e !== null && (delete e[jr],
    delete e[Pa],
    delete e[Ff],
    delete e[R1],
    delete e[A1])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function z0(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function Vg(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || z0(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function eh(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode,
        e.insertBefore(t, r)) : (e = r,
        e.appendChild(t)),
        r = r._reactRootContainer,
        r != null || e.onclick !== null || (e.onclick = Mu));
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (eh(t, e, r),
        t = t.sibling; t !== null; )
            eh(t, e, r),
            t = t.sibling
}
function th(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.insertBefore(t, e) : r.appendChild(t);
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (th(t, e, r),
        t = t.sibling; t !== null; )
            th(t, e, r),
            t = t.sibling
}
var tt = null
  , ur = !1;
function mn(t, e, r) {
    for (r = r.child; r !== null; )
        W0(t, e, r),
        r = r.sibling
}
function W0(t, e, r) {
    if (Dr && typeof Dr.onCommitFiberUnmount == "function")
        try {
            Dr.onCommitFiberUnmount(Oc, r)
        } catch {}
    switch (r.tag) {
    case 5:
        ut || Pi(r, e);
    case 6:
        var n = tt
          , s = ur;
        tt = null,
        mn(t, e, r),
        tt = n,
        ur = s,
        tt !== null && (ur ? (t = tt,
        r = r.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : tt.removeChild(r.stateNode));
        break;
    case 18:
        tt !== null && (ur ? (t = tt,
        r = r.stateNode,
        t.nodeType === 8 ? Pd(t.parentNode, r) : t.nodeType === 1 && Pd(t, r),
        Ea(t)) : Pd(tt, r.stateNode));
        break;
    case 4:
        n = tt,
        s = ur,
        tt = r.stateNode.containerInfo,
        ur = !0,
        mn(t, e, r),
        tt = n,
        ur = s;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!ut && (n = r.updateQueue,
        n !== null && (n = n.lastEffect,
        n !== null))) {
            s = n = n.next;
            do {
                var i = s
                  , o = i.destroy;
                i = i.tag,
                o !== void 0 && (i & 2 || i & 4) && Jf(r, e, o),
                s = s.next
            } while (s !== n)
        }
        mn(t, e, r);
        break;
    case 1:
        if (!ut && (Pi(r, e),
        n = r.stateNode,
        typeof n.componentWillUnmount == "function"))
            try {
                n.props = r.memoizedProps,
                n.state = r.memoizedState,
                n.componentWillUnmount()
            } catch (a) {
                $e(r, e, a)
            }
        mn(t, e, r);
        break;
    case 21:
        mn(t, e, r);
        break;
    case 22:
        r.mode & 1 ? (ut = (n = ut) || r.memoizedState !== null,
        mn(t, e, r),
        ut = n) : mn(t, e, r);
        break;
    default:
        mn(t, e, r)
    }
}
function Bg(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var r = t.stateNode;
        r === null && (r = t.stateNode = new K1),
        e.forEach(function(n) {
            var s = nC.bind(null, t, n);
            r.has(n) || (r.add(n),
            n.then(s, s))
        })
    }
}
function sr(t, e) {
    var r = e.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var s = r[n];
            try {
                var i = t
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        tt = a.stateNode,
                        ur = !1;
                        break e;
                    case 3:
                        tt = a.stateNode.containerInfo,
                        ur = !0;
                        break e;
                    case 4:
                        tt = a.stateNode.containerInfo,
                        ur = !0;
                        break e
                    }
                    a = a.return
                }
                if (tt === null)
                    throw Error(I(160));
                W0(i, o, s),
                tt = null,
                ur = !1;
                var l = s.alternate;
                l !== null && (l.return = null),
                s.return = null
            } catch (u) {
                $e(s, e, u)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            H0(e, t),
            e = e.sibling
}
function H0(t, e) {
    var r = t.alternate
      , n = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (sr(e, t),
        Cr(t),
        n & 4) {
            try {
                da(3, t, t.return),
                Mc(3, t)
            } catch (h) {
                $e(t, t.return, h)
            }
            try {
                da(5, t, t.return)
            } catch (h) {
                $e(t, t.return, h)
            }
        }
        break;
    case 1:
        sr(e, t),
        Cr(t),
        n & 512 && r !== null && Pi(r, r.return);
        break;
    case 5:
        if (sr(e, t),
        Cr(t),
        n & 512 && r !== null && Pi(r, r.return),
        t.flags & 32) {
            var s = t.stateNode;
            try {
                _a(s, "")
            } catch (h) {
                $e(t, t.return, h)
            }
        }
        if (n & 4 && (s = t.stateNode,
        s != null)) {
            var i = t.memoizedProps
              , o = r !== null ? r.memoizedProps : i
              , a = t.type
              , l = t.updateQueue;
            if (t.updateQueue = null,
            l !== null)
                try {
                    a === "input" && i.type === "radio" && i.name != null && hw(s, i),
                    kf(a, o);
                    var u = kf(a, i);
                    for (o = 0; o < l.length; o += 2) {
                        var c = l[o]
                          , d = l[o + 1];
                        c === "style" ? yw(s, d) : c === "dangerouslySetInnerHTML" ? gw(s, d) : c === "children" ? _a(s, d) : rp(s, c, d, u)
                    }
                    switch (a) {
                    case "input":
                        _f(s, i);
                        break;
                    case "textarea":
                        pw(s, i);
                        break;
                    case "select":
                        var f = s._wrapperState.wasMultiple;
                        s._wrapperState.wasMultiple = !!i.multiple;
                        var p = i.value;
                        p != null ? Ni(s, !!i.multiple, p, !1) : f !== !!i.multiple && (i.defaultValue != null ? Ni(s, !!i.multiple, i.defaultValue, !0) : Ni(s, !!i.multiple, i.multiple ? [] : "", !1))
                    }
                    s[Pa] = i
                } catch (h) {
                    $e(t, t.return, h)
                }
        }
        break;
    case 6:
        if (sr(e, t),
        Cr(t),
        n & 4) {
            if (t.stateNode === null)
                throw Error(I(162));
            s = t.stateNode,
            i = t.memoizedProps;
            try {
                s.nodeValue = i
            } catch (h) {
                $e(t, t.return, h)
            }
        }
        break;
    case 3:
        if (sr(e, t),
        Cr(t),
        n & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                Ea(e.containerInfo)
            } catch (h) {
                $e(t, t.return, h)
            }
        break;
    case 4:
        sr(e, t),
        Cr(t);
        break;
    case 13:
        sr(e, t),
        Cr(t),
        s = t.child,
        s.flags & 8192 && (i = s.memoizedState !== null,
        s.stateNode.isHidden = i,
        !i || s.alternate !== null && s.alternate.memoizedState !== null || (Dp = Ue())),
        n & 4 && Bg(t);
        break;
    case 22:
        if (c = r !== null && r.memoizedState !== null,
        t.mode & 1 ? (ut = (u = ut) || c,
        sr(e, t),
        ut = u) : sr(e, t),
        Cr(t),
        n & 8192) {
            if (u = t.memoizedState !== null,
            (t.stateNode.isHidden = u) && !c && t.mode & 1)
                for (K = t,
                c = t.child; c !== null; ) {
                    for (d = K = c; K !== null; ) {
                        switch (f = K,
                        p = f.child,
                        f.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            da(4, f, f.return);
                            break;
                        case 1:
                            Pi(f, f.return);
                            var g = f.stateNode;
                            if (typeof g.componentWillUnmount == "function") {
                                n = f,
                                r = f.return;
                                try {
                                    e = n,
                                    g.props = e.memoizedProps,
                                    g.state = e.memoizedState,
                                    g.componentWillUnmount()
                                } catch (h) {
                                    $e(n, r, h)
                                }
                            }
                            break;
                        case 5:
                            Pi(f, f.return);
                            break;
                        case 22:
                            if (f.memoizedState !== null) {
                                Wg(d);
                                continue
                            }
                        }
                        p !== null ? (p.return = f,
                        K = p) : Wg(d)
                    }
                    c = c.sibling
                }
            e: for (c = null,
            d = t; ; ) {
                if (d.tag === 5) {
                    if (c === null) {
                        c = d;
                        try {
                            s = d.stateNode,
                            u ? (i = s.style,
                            typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = d.stateNode,
                            l = d.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = vw("display", o))
                        } catch (h) {
                            $e(t, t.return, h)
                        }
                    }
                } else if (d.tag === 6) {
                    if (c === null)
                        try {
                            d.stateNode.nodeValue = u ? "" : d.memoizedProps
                        } catch (h) {
                            $e(t, t.return, h)
                        }
                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === t)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === t)
                        break e;
                    c === d && (c = null),
                    d = d.return
                }
                c === d && (c = null),
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        break;
    case 19:
        sr(e, t),
        Cr(t),
        n & 4 && Bg(t);
        break;
    case 21:
        break;
    default:
        sr(e, t),
        Cr(t)
    }
}
function Cr(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var r = t.return; r !== null; ) {
                    if (z0(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(I(160))
            }
            switch (n.tag) {
            case 5:
                var s = n.stateNode;
                n.flags & 32 && (_a(s, ""),
                n.flags &= -33);
                var i = Vg(t);
                th(t, i, s);
                break;
            case 3:
            case 4:
                var o = n.stateNode.containerInfo
                  , a = Vg(t);
                eh(t, a, o);
                break;
            default:
                throw Error(I(161))
            }
        } catch (l) {
            $e(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}
function Q1(t, e, r) {
    K = t,
    q0(t)
}
function q0(t, e, r) {
    for (var n = (t.mode & 1) !== 0; K !== null; ) {
        var s = K
          , i = s.child;
        if (s.tag === 22 && n) {
            var o = s.memoizedState !== null || Fl;
            if (!o) {
                var a = s.alternate
                  , l = a !== null && a.memoizedState !== null || ut;
                a = Fl;
                var u = ut;
                if (Fl = o,
                (ut = l) && !u)
                    for (K = s; K !== null; )
                        o = K,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? Hg(s) : l !== null ? (l.return = o,
                        K = l) : Hg(s);
                for (; i !== null; )
                    K = i,
                    q0(i),
                    i = i.sibling;
                K = s,
                Fl = a,
                ut = u
            }
            zg(t)
        } else
            s.subtreeFlags & 8772 && i !== null ? (i.return = s,
            K = i) : zg(t)
    }
}
function zg(t) {
    for (; K !== null; ) {
        var e = K;
        if (e.flags & 8772) {
            var r = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        ut || Mc(5, e);
                        break;
                    case 1:
                        var n = e.stateNode;
                        if (e.flags & 4 && !ut)
                            if (r === null)
                                n.componentDidMount();
                            else {
                                var s = e.elementType === e.type ? r.memoizedProps : or(e.type, r.memoizedProps);
                                n.componentDidUpdate(s, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var i = e.updateQueue;
                        i !== null && Tg(e, i, n);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (r = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    r = e.child.stateNode;
                                    break;
                                case 1:
                                    r = e.child.stateNode
                                }
                            Tg(e, o, r)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (r === null && e.flags & 4) {
                            r = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && r.focus();
                                break;
                            case "img":
                                l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var u = e.alternate;
                            if (u !== null) {
                                var c = u.memoizedState;
                                if (c !== null) {
                                    var d = c.dehydrated;
                                    d !== null && Ea(d)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(I(163))
                    }
                ut || e.flags & 512 && Xf(e)
            } catch (f) {
                $e(e, e.return, f)
            }
        }
        if (e === t) {
            K = null;
            break
        }
        if (r = e.sibling,
        r !== null) {
            r.return = e.return,
            K = r;
            break
        }
        K = e.return
    }
}
function Wg(t) {
    for (; K !== null; ) {
        var e = K;
        if (e === t) {
            K = null;
            break
        }
        var r = e.sibling;
        if (r !== null) {
            r.return = e.return,
            K = r;
            break
        }
        K = e.return
    }
}
function Hg(t) {
    for (; K !== null; ) {
        var e = K;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var r = e.return;
                try {
                    Mc(4, e)
                } catch (l) {
                    $e(e, r, l)
                }
                break;
            case 1:
                var n = e.stateNode;
                if (typeof n.componentDidMount == "function") {
                    var s = e.return;
                    try {
                        n.componentDidMount()
                    } catch (l) {
                        $e(e, s, l)
                    }
                }
                var i = e.return;
                try {
                    Xf(e)
                } catch (l) {
                    $e(e, i, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    Xf(e)
                } catch (l) {
                    $e(e, o, l)
                }
            }
        } catch (l) {
            $e(e, e.return, l)
        }
        if (e === t) {
            K = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            K = a;
            break
        }
        K = e.return
    }
}
var Z1 = Math.ceil
  , Ku = fn.ReactCurrentDispatcher
  , Np = fn.ReactCurrentOwner
  , Xt = fn.ReactCurrentBatchConfig
  , ge = 0
  , Je = null
  , He = null
  , rt = 0
  , It = 0
  , Ri = ss(0)
  , Ze = 0
  , Da = null
  , Fs = 0
  , Lc = 0
  , Ip = 0
  , fa = null
  , Ct = null
  , Dp = 0
  , ho = 1 / 0
  , Kr = null
  , Gu = !1
  , rh = null
  , Wn = null
  , Ul = !1
  , $n = null
  , Qu = 0
  , ha = 0
  , nh = null
  , vu = -1
  , yu = 0;
function yt() {
    return ge & 6 ? Ue() : vu !== -1 ? vu : vu = Ue()
}
function Hn(t) {
    return t.mode & 1 ? ge & 2 && rt !== 0 ? rt & -rt : N1.transition !== null ? (yu === 0 && (yu = Rw()),
    yu) : (t = Se,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : Lw(t.type)),
    t) : 1
}
function yr(t, e, r, n) {
    if (50 < ha)
        throw ha = 0,
        nh = null,
        Error(I(185));
    ll(t, r, n),
    (!(ge & 2) || t !== Je) && (t === Je && (!(ge & 2) && (Lc |= r),
    Ze === 4 && kn(t, rt)),
    Rt(t, n),
    r === 1 && ge === 0 && !(e.mode & 1) && (ho = Ue() + 500,
    Nc && is()))
}
function Rt(t, e) {
    var r = t.callbackNode;
    Nk(t, e);
    var n = ju(t, t === Je ? rt : 0);
    if (n === 0)
        r !== null && eg(r),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (e = n & -n,
    t.callbackPriority !== e) {
        if (r != null && eg(r),
        e === 1)
            t.tag === 0 ? j1(qg.bind(null, t)) : r0(qg.bind(null, t)),
            O1(function() {
                !(ge & 6) && is()
            }),
            r = null;
        else {
            switch (Aw(n)) {
            case 1:
                r = ap;
                break;
            case 4:
                r = Ow;
                break;
            case 16:
                r = Au;
                break;
            case 536870912:
                r = Pw;
                break;
            default:
                r = Au
            }
            r = e_(r, K0.bind(null, t))
        }
        t.callbackPriority = e,
        t.callbackNode = r
    }
}
function K0(t, e) {
    if (vu = -1,
    yu = 0,
    ge & 6)
        throw Error(I(327));
    var r = t.callbackNode;
    if ($i() && t.callbackNode !== r)
        return null;
    var n = ju(t, t === Je ? rt : 0);
    if (n === 0)
        return null;
    if (n & 30 || n & t.expiredLanes || e)
        e = Zu(t, n);
    else {
        e = n;
        var s = ge;
        ge |= 2;
        var i = Q0();
        (Je !== t || rt !== e) && (Kr = null,
        ho = Ue() + 500,
        Ns(t, e));
        do
            try {
                X1();
                break
            } catch (a) {
                G0(t, a)
            }
        while (!0);
        _p(),
        Ku.current = i,
        ge = s,
        He !== null ? e = 0 : (Je = null,
        rt = 0,
        e = Ze)
    }
    if (e !== 0) {
        if (e === 2 && (s = Rf(t),
        s !== 0 && (n = s,
        e = sh(t, s))),
        e === 1)
            throw r = Da,
            Ns(t, 0),
            kn(t, n),
            Rt(t, Ue()),
            r;
        if (e === 6)
            kn(t, n);
        else {
            if (s = t.current.alternate,
            !(n & 30) && !Y1(s) && (e = Zu(t, n),
            e === 2 && (i = Rf(t),
            i !== 0 && (n = i,
            e = sh(t, i))),
            e === 1))
                throw r = Da,
                Ns(t, 0),
                kn(t, n),
                Rt(t, Ue()),
                r;
            switch (t.finishedWork = s,
            t.finishedLanes = n,
            e) {
            case 0:
            case 1:
                throw Error(I(345));
            case 2:
                ms(t, Ct, Kr);
                break;
            case 3:
                if (kn(t, n),
                (n & 130023424) === n && (e = Dp + 500 - Ue(),
                10 < e)) {
                    if (ju(t, 0) !== 0)
                        break;
                    if (s = t.suspendedLanes,
                    (s & n) !== n) {
                        yt(),
                        t.pingedLanes |= t.suspendedLanes & s;
                        break
                    }
                    t.timeoutHandle = $f(ms.bind(null, t, Ct, Kr), e);
                    break
                }
                ms(t, Ct, Kr);
                break;
            case 4:
                if (kn(t, n),
                (n & 4194240) === n)
                    break;
                for (e = t.eventTimes,
                s = -1; 0 < n; ) {
                    var o = 31 - vr(n);
                    i = 1 << o,
                    o = e[o],
                    o > s && (s = o),
                    n &= ~i
                }
                if (n = s,
                n = Ue() - n,
                n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Z1(n / 1960)) - n,
                10 < n) {
                    t.timeoutHandle = $f(ms.bind(null, t, Ct, Kr), n);
                    break
                }
                ms(t, Ct, Kr);
                break;
            case 5:
                ms(t, Ct, Kr);
                break;
            default:
                throw Error(I(329))
            }
        }
    }
    return Rt(t, Ue()),
    t.callbackNode === r ? K0.bind(null, t) : null
}
function sh(t, e) {
    var r = fa;
    return t.current.memoizedState.isDehydrated && (Ns(t, e).flags |= 256),
    t = Zu(t, e),
    t !== 2 && (e = Ct,
    Ct = r,
    e !== null && ih(e)),
    t
}
function ih(t) {
    Ct === null ? Ct = t : Ct.push.apply(Ct, t)
}
function Y1(t) {
    for (var e = t; ; ) {
        if (e.flags & 16384) {
            var r = e.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var n = 0; n < r.length; n++) {
                    var s = r[n]
                      , i = s.getSnapshot;
                    s = s.value;
                    try {
                        if (!_r(i(), s))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = e.child,
        e.subtreeFlags & 16384 && r !== null)
            r.return = e,
            e = r;
        else {
            if (e === t)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function kn(t, e) {
    for (e &= ~Ip,
    e &= ~Lc,
    t.suspendedLanes |= e,
    t.pingedLanes &= ~e,
    t = t.expirationTimes; 0 < e; ) {
        var r = 31 - vr(e)
          , n = 1 << r;
        t[r] = -1,
        e &= ~n
    }
}
function qg(t) {
    if (ge & 6)
        throw Error(I(327));
    $i();
    var e = ju(t, 0);
    if (!(e & 1))
        return Rt(t, Ue()),
        null;
    var r = Zu(t, e);
    if (t.tag !== 0 && r === 2) {
        var n = Rf(t);
        n !== 0 && (e = n,
        r = sh(t, n))
    }
    if (r === 1)
        throw r = Da,
        Ns(t, 0),
        kn(t, e),
        Rt(t, Ue()),
        r;
    if (r === 6)
        throw Error(I(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = e,
    ms(t, Ct, Kr),
    Rt(t, Ue()),
    null
}
function Mp(t, e) {
    var r = ge;
    ge |= 1;
    try {
        return t(e)
    } finally {
        ge = r,
        ge === 0 && (ho = Ue() + 500,
        Nc && is())
    }
}
function Us(t) {
    $n !== null && $n.tag === 0 && !(ge & 6) && $i();
    var e = ge;
    ge |= 1;
    var r = Xt.transition
      , n = Se;
    try {
        if (Xt.transition = null,
        Se = 1,
        t)
            return t()
    } finally {
        Se = n,
        Xt.transition = r,
        ge = e,
        !(ge & 6) && is()
    }
}
function Lp() {
    It = Ri.current,
    Re(Ri)
}
function Ns(t, e) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var r = t.timeoutHandle;
    if (r !== -1 && (t.timeoutHandle = -1,
    T1(r)),
    He !== null)
        for (r = He.return; r !== null; ) {
            var n = r;
            switch (vp(n),
            n.tag) {
            case 1:
                n = n.type.childContextTypes,
                n != null && Lu();
                break;
            case 3:
                co(),
                Re(Ot),
                Re(ct),
                Cp();
                break;
            case 5:
                kp(n);
                break;
            case 4:
                co();
                break;
            case 13:
                Re(Ie);
                break;
            case 19:
                Re(Ie);
                break;
            case 10:
                bp(n.type._context);
                break;
            case 22:
            case 23:
                Lp()
            }
            r = r.return
        }
    if (Je = t,
    He = t = qn(t.current, null),
    rt = It = e,
    Ze = 0,
    Da = null,
    Ip = Lc = Fs = 0,
    Ct = fa = null,
    xs !== null) {
        for (e = 0; e < xs.length; e++)
            if (r = xs[e],
            n = r.interleaved,
            n !== null) {
                r.interleaved = null;
                var s = n.next
                  , i = r.pending;
                if (i !== null) {
                    var o = i.next;
                    i.next = s,
                    n.next = o
                }
                r.pending = n
            }
        xs = null
    }
    return t
}
function G0(t, e) {
    do {
        var r = He;
        try {
            if (_p(),
            pu.current = qu,
            Hu) {
                for (var n = De.memoizedState; n !== null; ) {
                    var s = n.queue;
                    s !== null && (s.pending = null),
                    n = n.next
                }
                Hu = !1
            }
            if ($s = 0,
            Ye = Ge = De = null,
            ca = !1,
            ja = 0,
            Np.current = null,
            r === null || r.return === null) {
                Ze = 1,
                Da = e,
                He = null;
                break
            }
            e: {
                var i = t
                  , o = r.return
                  , a = r
                  , l = e;
                if (e = rt,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var u = l
                      , c = a
                      , d = c.tag;
                    if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                        var f = c.alternate;
                        f ? (c.updateQueue = f.updateQueue,
                        c.memoizedState = f.memoizedState,
                        c.lanes = f.lanes) : (c.updateQueue = null,
                        c.memoizedState = null)
                    }
                    var p = Ng(o);
                    if (p !== null) {
                        p.flags &= -257,
                        Ig(p, o, a, i, e),
                        p.mode & 1 && jg(i, u, e),
                        e = p,
                        l = u;
                        var g = e.updateQueue;
                        if (g === null) {
                            var h = new Set;
                            h.add(l),
                            e.updateQueue = h
                        } else
                            g.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            jg(i, u, e),
                            $p();
                            break e
                        }
                        l = Error(I(426))
                    }
                } else if (Ae && a.mode & 1) {
                    var w = Ng(o);
                    if (w !== null) {
                        !(w.flags & 65536) && (w.flags |= 256),
                        Ig(w, o, a, i, e),
                        yp(fo(l, a));
                        break e
                    }
                }
                i = l = fo(l, a),
                Ze !== 4 && (Ze = 2),
                fa === null ? fa = [i] : fa.push(i),
                i = o;
                do {
                    switch (i.tag) {
                    case 3:
                        i.flags |= 65536,
                        e &= -e,
                        i.lanes |= e;
                        var v = A0(i, l, e);
                        Cg(i, v);
                        break e;
                    case 1:
                        a = l;
                        var m = i.type
                          , _ = i.stateNode;
                        if (!(i.flags & 128) && (typeof m.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (Wn === null || !Wn.has(_)))) {
                            i.flags |= 65536,
                            e &= -e,
                            i.lanes |= e;
                            var x = j0(i, a, e);
                            Cg(i, x);
                            break e
                        }
                    }
                    i = i.return
                } while (i !== null)
            }
            Y0(r)
        } catch (k) {
            e = k,
            He === r && r !== null && (He = r = r.return);
            continue
        }
        break
    } while (!0)
}
function Q0() {
    var t = Ku.current;
    return Ku.current = qu,
    t === null ? qu : t
}
function $p() {
    (Ze === 0 || Ze === 3 || Ze === 2) && (Ze = 4),
    Je === null || !(Fs & 268435455) && !(Lc & 268435455) || kn(Je, rt)
}
function Zu(t, e) {
    var r = ge;
    ge |= 2;
    var n = Q0();
    (Je !== t || rt !== e) && (Kr = null,
    Ns(t, e));
    do
        try {
            J1();
            break
        } catch (s) {
            G0(t, s)
        }
    while (!0);
    if (_p(),
    ge = r,
    Ku.current = n,
    He !== null)
        throw Error(I(261));
    return Je = null,
    rt = 0,
    Ze
}
function J1() {
    for (; He !== null; )
        Z0(He)
}
function X1() {
    for (; He !== null && !Ek(); )
        Z0(He)
}
function Z0(t) {
    var e = X0(t.alternate, t, It);
    t.memoizedProps = t.pendingProps,
    e === null ? Y0(t) : He = e,
    Np.current = null
}
function Y0(t) {
    var e = t;
    do {
        var r = e.alternate;
        if (t = e.return,
        e.flags & 32768) {
            if (r = q1(r, e),
            r !== null) {
                r.flags &= 32767,
                He = r;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                Ze = 6,
                He = null;
                return
            }
        } else if (r = H1(r, e, It),
        r !== null) {
            He = r;
            return
        }
        if (e = e.sibling,
        e !== null) {
            He = e;
            return
        }
        He = e = t
    } while (e !== null);
    Ze === 0 && (Ze = 5)
}
function ms(t, e, r) {
    var n = Se
      , s = Xt.transition;
    try {
        Xt.transition = null,
        Se = 1,
        eC(t, e, r, n)
    } finally {
        Xt.transition = s,
        Se = n
    }
    return null
}
function eC(t, e, r, n) {
    do
        $i();
    while ($n !== null);
    if (ge & 6)
        throw Error(I(327));
    r = t.finishedWork;
    var s = t.finishedLanes;
    if (r === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    r === t.current)
        throw Error(I(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var i = r.lanes | r.childLanes;
    if (Ik(t, i),
    t === Je && (He = Je = null,
    rt = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || Ul || (Ul = !0,
    e_(Au, function() {
        return $i(),
        null
    })),
    i = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || i) {
        i = Xt.transition,
        Xt.transition = null;
        var o = Se;
        Se = 1;
        var a = ge;
        ge |= 4,
        Np.current = null,
        G1(t, r),
        H0(r, t),
        _1(Mf),
        Nu = !!Df,
        Mf = Df = null,
        t.current = r,
        Q1(r),
        kk(),
        ge = a,
        Se = o,
        Xt.transition = i
    } else
        t.current = r;
    if (Ul && (Ul = !1,
    $n = t,
    Qu = s),
    i = t.pendingLanes,
    i === 0 && (Wn = null),
    Ok(r.stateNode),
    Rt(t, Ue()),
    e !== null)
        for (n = t.onRecoverableError,
        r = 0; r < e.length; r++)
            s = e[r],
            n(s.value, {
                componentStack: s.stack,
                digest: s.digest
            });
    if (Gu)
        throw Gu = !1,
        t = rh,
        rh = null,
        t;
    return Qu & 1 && t.tag !== 0 && $i(),
    i = t.pendingLanes,
    i & 1 ? t === nh ? ha++ : (ha = 0,
    nh = t) : ha = 0,
    is(),
    null
}
function $i() {
    if ($n !== null) {
        var t = Aw(Qu)
          , e = Xt.transition
          , r = Se;
        try {
            if (Xt.transition = null,
            Se = 16 > t ? 16 : t,
            $n === null)
                var n = !1;
            else {
                if (t = $n,
                $n = null,
                Qu = 0,
                ge & 6)
                    throw Error(I(331));
                var s = ge;
                for (ge |= 4,
                K = t.current; K !== null; ) {
                    var i = K
                      , o = i.child;
                    if (K.flags & 16) {
                        var a = i.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var u = a[l];
                                for (K = u; K !== null; ) {
                                    var c = K;
                                    switch (c.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        da(8, c, i)
                                    }
                                    var d = c.child;
                                    if (d !== null)
                                        d.return = c,
                                        K = d;
                                    else
                                        for (; K !== null; ) {
                                            c = K;
                                            var f = c.sibling
                                              , p = c.return;
                                            if (B0(c),
                                            c === u) {
                                                K = null;
                                                break
                                            }
                                            if (f !== null) {
                                                f.return = p,
                                                K = f;
                                                break
                                            }
                                            K = p
                                        }
                                }
                            }
                            var g = i.alternate;
                            if (g !== null) {
                                var h = g.child;
                                if (h !== null) {
                                    g.child = null;
                                    do {
                                        var w = h.sibling;
                                        h.sibling = null,
                                        h = w
                                    } while (h !== null)
                                }
                            }
                            K = i
                        }
                    }
                    if (i.subtreeFlags & 2064 && o !== null)
                        o.return = i,
                        K = o;
                    else
                        e: for (; K !== null; ) {
                            if (i = K,
                            i.flags & 2048)
                                switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    da(9, i, i.return)
                                }
                            var v = i.sibling;
                            if (v !== null) {
                                v.return = i.return,
                                K = v;
                                break e
                            }
                            K = i.return
                        }
                }
                var m = t.current;
                for (K = m; K !== null; ) {
                    o = K;
                    var _ = o.child;
                    if (o.subtreeFlags & 2064 && _ !== null)
                        _.return = o,
                        K = _;
                    else
                        e: for (o = m; K !== null; ) {
                            if (a = K,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Mc(9, a)
                                    }
                                } catch (k) {
                                    $e(a, a.return, k)
                                }
                            if (a === o) {
                                K = null;
                                break e
                            }
                            var x = a.sibling;
                            if (x !== null) {
                                x.return = a.return,
                                K = x;
                                break e
                            }
                            K = a.return
                        }
                }
                if (ge = s,
                is(),
                Dr && typeof Dr.onPostCommitFiberRoot == "function")
                    try {
                        Dr.onPostCommitFiberRoot(Oc, t)
                    } catch {}
                n = !0
            }
            return n
        } finally {
            Se = r,
            Xt.transition = e
        }
    }
    return !1
}
function Kg(t, e, r) {
    e = fo(r, e),
    e = A0(t, e, 1),
    t = zn(t, e, 1),
    e = yt(),
    t !== null && (ll(t, 1, e),
    Rt(t, e))
}
function $e(t, e, r) {
    if (t.tag === 3)
        Kg(t, t, r);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                Kg(e, t, r);
                break
            } else if (e.tag === 1) {
                var n = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Wn === null || !Wn.has(n))) {
                    t = fo(r, t),
                    t = j0(e, t, 1),
                    e = zn(e, t, 1),
                    t = yt(),
                    e !== null && (ll(e, 1, t),
                    Rt(e, t));
                    break
                }
            }
            e = e.return
        }
}
function tC(t, e, r) {
    var n = t.pingCache;
    n !== null && n.delete(e),
    e = yt(),
    t.pingedLanes |= t.suspendedLanes & r,
    Je === t && (rt & r) === r && (Ze === 4 || Ze === 3 && (rt & 130023424) === rt && 500 > Ue() - Dp ? Ns(t, 0) : Ip |= r),
    Rt(t, e)
}
function J0(t, e) {
    e === 0 && (t.mode & 1 ? (e = Rl,
    Rl <<= 1,
    !(Rl & 130023424) && (Rl = 4194304)) : e = 1);
    var r = yt();
    t = on(t, e),
    t !== null && (ll(t, e, r),
    Rt(t, r))
}
function rC(t) {
    var e = t.memoizedState
      , r = 0;
    e !== null && (r = e.retryLane),
    J0(t, r)
}
function nC(t, e) {
    var r = 0;
    switch (t.tag) {
    case 13:
        var n = t.stateNode
          , s = t.memoizedState;
        s !== null && (r = s.retryLane);
        break;
    case 19:
        n = t.stateNode;
        break;
    default:
        throw Error(I(314))
    }
    n !== null && n.delete(e),
    J0(t, r)
}
var X0;
X0 = function(t, e, r) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Ot.current)
            Tt = !0;
        else {
            if (!(t.lanes & r) && !(e.flags & 128))
                return Tt = !1,
                W1(t, e, r);
            Tt = !!(t.flags & 131072)
        }
    else
        Tt = !1,
        Ae && e.flags & 1048576 && n0(e, Uu, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var n = e.type;
        gu(t, e),
        t = e.pendingProps;
        var s = ao(e, ct.current);
        Li(e, r),
        s = Op(null, e, n, t, s, r);
        var i = Pp();
        return e.flags |= 1,
        typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Pt(n) ? (i = !0,
        $u(e)) : i = !1,
        e.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null,
        Sp(e),
        s.updater = Dc,
        e.stateNode = s,
        s._reactInternals = e,
        Hf(e, n, t, r),
        e = Gf(null, e, n, !0, i, r)) : (e.tag = 0,
        Ae && i && gp(e),
        mt(null, e, s, r),
        e = e.child),
        e;
    case 16:
        n = e.elementType;
        e: {
            switch (gu(t, e),
            t = e.pendingProps,
            s = n._init,
            n = s(n._payload),
            e.type = n,
            s = e.tag = iC(n),
            t = or(n, t),
            s) {
            case 0:
                e = Kf(null, e, n, t, r);
                break e;
            case 1:
                e = Lg(null, e, n, t, r);
                break e;
            case 11:
                e = Dg(null, e, n, t, r);
                break e;
            case 14:
                e = Mg(null, e, n, or(n.type, t), r);
                break e
            }
            throw Error(I(306, n, ""))
        }
        return e;
    case 0:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : or(n, s),
        Kf(t, e, n, s, r);
    case 1:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : or(n, s),
        Lg(t, e, n, s, r);
    case 3:
        e: {
            if (M0(e),
            t === null)
                throw Error(I(387));
            n = e.pendingProps,
            i = e.memoizedState,
            s = i.element,
            u0(t, e),
            zu(e, n, null, r);
            var o = e.memoizedState;
            if (n = o.element,
            i.isDehydrated)
                if (i = {
                    element: n,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = i,
                e.memoizedState = i,
                e.flags & 256) {
                    s = fo(Error(I(423)), e),
                    e = $g(t, e, n, r, s);
                    break e
                } else if (n !== s) {
                    s = fo(Error(I(424)), e),
                    e = $g(t, e, n, r, s);
                    break e
                } else
                    for (Ut = Bn(e.stateNode.containerInfo.firstChild),
                    Vt = e,
                    Ae = !0,
                    dr = null,
                    r = a0(e, null, n, r),
                    e.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (lo(),
                n === s) {
                    e = an(t, e, r);
                    break e
                }
                mt(t, e, n, r)
            }
            e = e.child
        }
        return e;
    case 5:
        return c0(e),
        t === null && Bf(e),
        n = e.type,
        s = e.pendingProps,
        i = t !== null ? t.memoizedProps : null,
        o = s.children,
        Lf(n, s) ? o = null : i !== null && Lf(n, i) && (e.flags |= 32),
        D0(t, e),
        mt(t, e, o, r),
        e.child;
    case 6:
        return t === null && Bf(e),
        null;
    case 13:
        return L0(t, e, r);
    case 4:
        return Ep(e, e.stateNode.containerInfo),
        n = e.pendingProps,
        t === null ? e.child = uo(e, null, n, r) : mt(t, e, n, r),
        e.child;
    case 11:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : or(n, s),
        Dg(t, e, n, s, r);
    case 7:
        return mt(t, e, e.pendingProps, r),
        e.child;
    case 8:
        return mt(t, e, e.pendingProps.children, r),
        e.child;
    case 12:
        return mt(t, e, e.pendingProps.children, r),
        e.child;
    case 10:
        e: {
            if (n = e.type._context,
            s = e.pendingProps,
            i = e.memoizedProps,
            o = s.value,
            Ce(Vu, n._currentValue),
            n._currentValue = o,
            i !== null)
                if (_r(i.value, o)) {
                    if (i.children === s.children && !Ot.current) {
                        e = an(t, e, r);
                        break e
                    }
                } else
                    for (i = e.child,
                    i !== null && (i.return = e); i !== null; ) {
                        var a = i.dependencies;
                        if (a !== null) {
                            o = i.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === n) {
                                    if (i.tag === 1) {
                                        l = tn(-1, r & -r),
                                        l.tag = 2;
                                        var u = i.updateQueue;
                                        if (u !== null) {
                                            u = u.shared;
                                            var c = u.pending;
                                            c === null ? l.next = l : (l.next = c.next,
                                            c.next = l),
                                            u.pending = l
                                        }
                                    }
                                    i.lanes |= r,
                                    l = i.alternate,
                                    l !== null && (l.lanes |= r),
                                    zf(i.return, r, e),
                                    a.lanes |= r;
                                    break
                                }
                                l = l.next
                            }
                        } else if (i.tag === 10)
                            o = i.type === e.type ? null : i.child;
                        else if (i.tag === 18) {
                            if (o = i.return,
                            o === null)
                                throw Error(I(341));
                            o.lanes |= r,
                            a = o.alternate,
                            a !== null && (a.lanes |= r),
                            zf(o, r, e),
                            o = i.sibling
                        } else
                            o = i.child;
                        if (o !== null)
                            o.return = i;
                        else
                            for (o = i; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (i = o.sibling,
                                i !== null) {
                                    i.return = o.return,
                                    o = i;
                                    break
                                }
                                o = o.return
                            }
                        i = o
                    }
            mt(t, e, s.children, r),
            e = e.child
        }
        return e;
    case 9:
        return s = e.type,
        n = e.pendingProps.children,
        Li(e, r),
        s = er(s),
        n = n(s),
        e.flags |= 1,
        mt(t, e, n, r),
        e.child;
    case 14:
        return n = e.type,
        s = or(n, e.pendingProps),
        s = or(n.type, s),
        Mg(t, e, n, s, r);
    case 15:
        return N0(t, e, e.type, e.pendingProps, r);
    case 17:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : or(n, s),
        gu(t, e),
        e.tag = 1,
        Pt(n) ? (t = !0,
        $u(e)) : t = !1,
        Li(e, r),
        R0(e, n, s),
        Hf(e, n, s, r),
        Gf(null, e, n, !0, t, r);
    case 19:
        return $0(t, e, r);
    case 22:
        return I0(t, e, r)
    }
    throw Error(I(156, e.tag))
}
;
function e_(t, e) {
    return Tw(t, e)
}
function sC(t, e, r, n) {
    this.tag = t,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = n,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Jt(t, e, r, n) {
    return new sC(t,e,r,n)
}
function Fp(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function iC(t) {
    if (typeof t == "function")
        return Fp(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === sp)
            return 11;
        if (t === ip)
            return 14
    }
    return 2
}
function qn(t, e) {
    var r = t.alternate;
    return r === null ? (r = Jt(t.tag, e, t.key, t.mode),
    r.elementType = t.elementType,
    r.type = t.type,
    r.stateNode = t.stateNode,
    r.alternate = t,
    t.alternate = r) : (r.pendingProps = e,
    r.type = t.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = t.flags & 14680064,
    r.childLanes = t.childLanes,
    r.lanes = t.lanes,
    r.child = t.child,
    r.memoizedProps = t.memoizedProps,
    r.memoizedState = t.memoizedState,
    r.updateQueue = t.updateQueue,
    e = t.dependencies,
    r.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    r.sibling = t.sibling,
    r.index = t.index,
    r.ref = t.ref,
    r
}
function wu(t, e, r, n, s, i) {
    var o = 2;
    if (n = t,
    typeof t == "function")
        Fp(t) && (o = 1);
    else if (typeof t == "string")
        o = 5;
    else
        e: switch (t) {
        case _i:
            return Is(r.children, s, i, e);
        case np:
            o = 8,
            s |= 8;
            break;
        case mf:
            return t = Jt(12, r, e, s | 2),
            t.elementType = mf,
            t.lanes = i,
            t;
        case gf:
            return t = Jt(13, r, e, s),
            t.elementType = gf,
            t.lanes = i,
            t;
        case vf:
            return t = Jt(19, r, e, s),
            t.elementType = vf,
            t.lanes = i,
            t;
        case cw:
            return $c(r, s, i, e);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case lw:
                    o = 10;
                    break e;
                case uw:
                    o = 9;
                    break e;
                case sp:
                    o = 11;
                    break e;
                case ip:
                    o = 14;
                    break e;
                case xn:
                    o = 16,
                    n = null;
                    break e
                }
            throw Error(I(130, t == null ? t : typeof t, ""))
        }
    return e = Jt(o, r, e, s),
    e.elementType = t,
    e.type = n,
    e.lanes = i,
    e
}
function Is(t, e, r, n) {
    return t = Jt(7, t, n, e),
    t.lanes = r,
    t
}
function $c(t, e, r, n) {
    return t = Jt(22, t, n, e),
    t.elementType = cw,
    t.lanes = r,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function Ld(t, e, r) {
    return t = Jt(6, t, null, e),
    t.lanes = r,
    t
}
function $d(t, e, r) {
    return e = Jt(4, t.children !== null ? t.children : [], t.key, e),
    e.lanes = r,
    e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    e
}
function oC(t, e, r, n, s) {
    this.tag = e,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = yd(0),
    this.expirationTimes = yd(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = yd(0),
    this.identifierPrefix = n,
    this.onRecoverableError = s,
    this.mutableSourceEagerHydrationData = null
}
function Up(t, e, r, n, s, i, o, a, l) {
    return t = new oC(t,e,r,a,l),
    e === 1 ? (e = 1,
    i === !0 && (e |= 8)) : e = 0,
    i = Jt(3, null, null, e),
    t.current = i,
    i.stateNode = t,
    i.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Sp(i),
    t
}
function aC(t, e, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wi,
        key: n == null ? null : "" + n,
        children: t,
        containerInfo: e,
        implementation: r
    }
}
function t_(t) {
    if (!t)
        return Gn;
    t = t._reactInternals;
    e: {
        if (Qs(t) !== t || t.tag !== 1)
            throw Error(I(170));
        var e = t;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Pt(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(I(171))
    }
    if (t.tag === 1) {
        var r = t.type;
        if (Pt(r))
            return t0(t, r, e)
    }
    return e
}
function r_(t, e, r, n, s, i, o, a, l) {
    return t = Up(r, n, !0, t, s, i, o, a, l),
    t.context = t_(null),
    r = t.current,
    n = yt(),
    s = Hn(r),
    i = tn(n, s),
    i.callback = e ?? null,
    zn(r, i, s),
    t.current.lanes = s,
    ll(t, s, n),
    Rt(t, n),
    t
}
function Fc(t, e, r, n) {
    var s = e.current
      , i = yt()
      , o = Hn(s);
    return r = t_(r),
    e.context === null ? e.context = r : e.pendingContext = r,
    e = tn(i, o),
    e.payload = {
        element: t
    },
    n = n === void 0 ? null : n,
    n !== null && (e.callback = n),
    t = zn(s, e, o),
    t !== null && (yr(t, s, o, i),
    hu(t, s, o)),
    o
}
function Yu(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function Gg(t, e) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < e ? r : e
    }
}
function Vp(t, e) {
    Gg(t, e),
    (t = t.alternate) && Gg(t, e)
}
function lC() {
    return null
}
var n_ = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function Bp(t) {
    this._internalRoot = t
}
Uc.prototype.render = Bp.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(I(409));
    Fc(t, e, null, null)
}
;
Uc.prototype.unmount = Bp.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        Us(function() {
            Fc(null, t, null, null)
        }),
        e[sn] = null
    }
}
;
function Uc(t) {
    this._internalRoot = t
}
Uc.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = Iw();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var r = 0; r < En.length && e !== 0 && e < En[r].priority; r++)
            ;
        En.splice(r, 0, t),
        r === 0 && Mw(t)
    }
}
;
function zp(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function Vc(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function Qg() {}
function uC(t, e, r, n, s) {
    if (s) {
        if (typeof n == "function") {
            var i = n;
            n = function() {
                var u = Yu(o);
                i.call(u)
            }
        }
        var o = r_(e, n, t, 0, null, !1, !1, "", Qg);
        return t._reactRootContainer = o,
        t[sn] = o.current,
        Ta(t.nodeType === 8 ? t.parentNode : t),
        Us(),
        o
    }
    for (; s = t.lastChild; )
        t.removeChild(s);
    if (typeof n == "function") {
        var a = n;
        n = function() {
            var u = Yu(l);
            a.call(u)
        }
    }
    var l = Up(t, 0, !1, null, null, !1, !1, "", Qg);
    return t._reactRootContainer = l,
    t[sn] = l.current,
    Ta(t.nodeType === 8 ? t.parentNode : t),
    Us(function() {
        Fc(e, l, r, n)
    }),
    l
}
function Bc(t, e, r, n, s) {
    var i = r._reactRootContainer;
    if (i) {
        var o = i;
        if (typeof s == "function") {
            var a = s;
            s = function() {
                var l = Yu(o);
                a.call(l)
            }
        }
        Fc(e, o, t, s)
    } else
        o = uC(r, e, t, s, n);
    return Yu(o)
}
jw = function(t) {
    switch (t.tag) {
    case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var r = Xo(e.pendingLanes);
            r !== 0 && (lp(e, r | 1),
            Rt(e, Ue()),
            !(ge & 6) && (ho = Ue() + 500,
            is()))
        }
        break;
    case 13:
        Us(function() {
            var n = on(t, 1);
            if (n !== null) {
                var s = yt();
                yr(n, t, 1, s)
            }
        }),
        Vp(t, 1)
    }
}
;
up = function(t) {
    if (t.tag === 13) {
        var e = on(t, 134217728);
        if (e !== null) {
            var r = yt();
            yr(e, t, 134217728, r)
        }
        Vp(t, 134217728)
    }
}
;
Nw = function(t) {
    if (t.tag === 13) {
        var e = Hn(t)
          , r = on(t, e);
        if (r !== null) {
            var n = yt();
            yr(r, t, e, n)
        }
        Vp(t, e)
    }
}
;
Iw = function() {
    return Se
}
;
Dw = function(t, e) {
    var r = Se;
    try {
        return Se = t,
        e()
    } finally {
        Se = r
    }
}
;
Tf = function(t, e, r) {
    switch (e) {
    case "input":
        if (_f(t, r),
        e = r.name,
        r.type === "radio" && e != null) {
            for (r = t; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < r.length; e++) {
                var n = r[e];
                if (n !== t && n.form === t.form) {
                    var s = jc(n);
                    if (!s)
                        throw Error(I(90));
                    fw(n),
                    _f(n, s)
                }
            }
        }
        break;
    case "textarea":
        pw(t, r);
        break;
    case "select":
        e = r.value,
        e != null && Ni(t, !!r.multiple, e, !1)
    }
}
;
bw = Mp;
xw = Us;
var cC = {
    usingClientEntryPoint: !1,
    Events: [cl, Ei, jc, ww, _w, Mp]
}
  , zo = {
    findFiberByHostInstance: bs,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , dC = {
    bundleType: zo.bundleType,
    version: zo.version,
    rendererPackageName: zo.rendererPackageName,
    rendererConfig: zo.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: fn.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = kw(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: zo.findFiberByHostInstance || lC,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Vl.isDisabled && Vl.supportsFiber)
        try {
            Oc = Vl.inject(dC),
            Dr = Vl
        } catch {}
}
Ht.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cC;
Ht.createPortal = function(t, e) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!zp(e))
        throw Error(I(200));
    return aC(t, e, null, r)
}
;
Ht.createRoot = function(t, e) {
    if (!zp(t))
        throw Error(I(299));
    var r = !1
      , n = ""
      , s = n_;
    return e != null && (e.unstable_strictMode === !0 && (r = !0),
    e.identifierPrefix !== void 0 && (n = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (s = e.onRecoverableError)),
    e = Up(t, 1, !1, null, null, r, !1, n, s),
    t[sn] = e.current,
    Ta(t.nodeType === 8 ? t.parentNode : t),
    new Bp(e)
}
;
Ht.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var e = t._reactInternals;
    if (e === void 0)
        throw typeof t.render == "function" ? Error(I(188)) : (t = Object.keys(t).join(","),
        Error(I(268, t)));
    return t = kw(e),
    t = t === null ? null : t.stateNode,
    t
}
;
Ht.flushSync = function(t) {
    return Us(t)
}
;
Ht.hydrate = function(t, e, r) {
    if (!Vc(e))
        throw Error(I(200));
    return Bc(null, t, e, !0, r)
}
;
Ht.hydrateRoot = function(t, e, r) {
    if (!zp(t))
        throw Error(I(405));
    var n = r != null && r.hydratedSources || null
      , s = !1
      , i = ""
      , o = n_;
    if (r != null && (r.unstable_strictMode === !0 && (s = !0),
    r.identifierPrefix !== void 0 && (i = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (o = r.onRecoverableError)),
    e = r_(e, null, t, 1, r ?? null, s, !1, i, o),
    t[sn] = e.current,
    Ta(t),
    n)
        for (t = 0; t < n.length; t++)
            r = n[t],
            s = r._getVersion,
            s = s(r._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, s] : e.mutableSourceEagerHydrationData.push(r, s);
    return new Uc(e)
}
;
Ht.render = function(t, e, r) {
    if (!Vc(e))
        throw Error(I(200));
    return Bc(null, t, e, !1, r)
}
;
Ht.unmountComponentAtNode = function(t) {
    if (!Vc(t))
        throw Error(I(40));
    return t._reactRootContainer ? (Us(function() {
        Bc(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[sn] = null
        })
    }),
    !0) : !1
}
;
Ht.unstable_batchedUpdates = Mp;
Ht.unstable_renderSubtreeIntoContainer = function(t, e, r, n) {
    if (!Vc(r))
        throw Error(I(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(I(38));
    return Bc(t, e, r, !1, n)
}
;
Ht.version = "18.3.1-next-f1338f8080-20240426";
function s_() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(s_)
        } catch (t) {
            console.error(t)
        }
}
s_(),
sw.exports = Ht;
var fl = sw.exports;
const fC = Hy(fl);
var i_, Zg = fl;
i_ = Zg.createRoot,
Zg.hydrateRoot;
function hC(t, e) {
    if (t instanceof RegExp)
        return {
            keys: !1,
            pattern: t
        };
    var r, n, s, i, o = [], a = "", l = t.split("/");
    for (l[0] || l.shift(); s = l.shift(); )
        r = s[0],
        r === "*" ? (o.push(r),
        a += s[1] === "?" ? "(?:/(.*))?" : "/(.*)") : r === ":" ? (n = s.indexOf("?", 1),
        i = s.indexOf(".", 1),
        o.push(s.substring(1, ~n ? n : ~i ? i : s.length)),
        a += ~n && !~i ? "(?:/([^/]+?))?" : "/([^/]+?)",
        ~i && (a += (~n ? "?" : "") + "\\" + s.substring(i))) : a += "/" + s;
    return {
        keys: o,
        pattern: new RegExp("^" + a + (e ? "(?=$|/)" : "/?$"),"i")
    }
}
var o_ = {
    exports: {}
}
  , a_ = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var po = b;
function pC(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var mC = typeof Object.is == "function" ? Object.is : pC
  , gC = po.useState
  , vC = po.useEffect
  , yC = po.useLayoutEffect
  , wC = po.useDebugValue;
function _C(t, e) {
    var r = e()
      , n = gC({
        inst: {
            value: r,
            getSnapshot: e
        }
    })
      , s = n[0].inst
      , i = n[1];
    return yC(function() {
        s.value = r,
        s.getSnapshot = e,
        Fd(s) && i({
            inst: s
        })
    }, [t, r, e]),
    vC(function() {
        return Fd(s) && i({
            inst: s
        }),
        t(function() {
            Fd(s) && i({
                inst: s
            })
        })
    }, [t]),
    wC(r),
    r
}
function Fd(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !mC(t, r)
    } catch {
        return !0
    }
}
function bC(t, e) {
    return e()
}
var xC = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? bC : _C;
a_.useSyncExternalStore = po.useSyncExternalStore !== void 0 ? po.useSyncExternalStore : xC;
o_.exports = a_;
var SC = o_.exports;
const EC = rw.useInsertionEffect
  , kC = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , CC = kC ? b.useLayoutEffect : b.useEffect
  , TC = EC || CC
  , l_ = t => {
    const e = b.useRef([t, (...r) => e[0](...r)]).current;
    return TC( () => {
        e[0] = t
    }
    ),
    e[1]
}
  , OC = "popstate"
  , Wp = "pushState"
  , Hp = "replaceState"
  , PC = "hashchange"
  , Yg = [OC, Wp, Hp, PC]
  , RC = t => {
    for (const e of Yg)
        addEventListener(e, t);
    return () => {
        for (const e of Yg)
            removeEventListener(e, t)
    }
}
  , u_ = (t, e) => SC.useSyncExternalStore(RC, t, e)
  , AC = () => location.search
  , jC = ({ssrSearch: t=""}={}) => u_(AC, () => t)
  , Jg = () => location.pathname
  , NC = ({ssrPath: t}={}) => u_(Jg, t ? () => t : Jg)
  , IC = (t, {replace: e=!1, state: r=null}={}) => history[e ? Hp : Wp](r, "", t)
  , DC = (t={}) => [NC(t), IC]
  , Xg = Symbol.for("wouter_v3");
if (typeof history < "u" && typeof window[Xg] > "u") {
    for (const t of [Wp, Hp]) {
        const e = history[t];
        history[t] = function() {
            const r = e.apply(this, arguments)
              , n = new Event(t);
            return n.arguments = arguments,
            dispatchEvent(n),
            r
        }
    }
    Object.defineProperty(window, Xg, {
        value: !0
    })
}
const MC = (t, e) => e.toLowerCase().indexOf(t.toLowerCase()) ? "~" + e : e.slice(t.length) || "/"
  , c_ = (t="") => t === "/" ? "" : t
  , LC = (t, e) => t[0] === "~" ? t.slice(1) : c_(e) + t
  , $C = (t="", e) => MC(ev(c_(t)), ev(e))
  , ev = t => {
    try {
        return decodeURI(t)
    } catch {
        return t
    }
}
  , d_ = {
    hook: DC,
    searchHook: jC,
    parser: hC,
    base: "",
    ssrPath: void 0,
    ssrSearch: void 0,
    hrefs: t => t
}
  , f_ = b.createContext(d_)
  , hl = () => b.useContext(f_)
  , h_ = {}
  , p_ = b.createContext(h_)
  , m_ = () => b.useContext(p_)
  , zc = t => {
    const [e,r] = t.hook(t);
    return [$C(t.base, e), l_( (n, s) => r(LC(n, t.base), s))]
}
  , Zs = () => zc(hl())
  , g_ = (t, e, r, n) => {
    const {pattern: s, keys: i} = e instanceof RegExp ? {
        keys: !1,
        pattern: e
    } : t(e || "*", n)
      , o = s.exec(r) || []
      , [a,...l] = o;
    return a !== void 0 ? [!0, ( () => {
        const u = i !== !1 ? Object.fromEntries(i.map( (d, f) => [d, l[f]])) : o.groups;
        let c = {
            ...l
        };
        return u && Object.assign(c, u),
        c
    }
    )(), ...n ? [a] : []] : [!1, null]
}
  , FC = ({children: t, ...e}) => {
    var c, d;
    const r = hl()
      , n = e.hook ? d_ : r;
    let s = n;
    const [i,o] = ((c = e.ssrPath) == null ? void 0 : c.split("?")) ?? [];
    o && (e.ssrSearch = o,
    e.ssrPath = i),
    e.hrefs = e.hrefs ?? ((d = e.hook) == null ? void 0 : d.hrefs);
    let a = b.useRef({})
      , l = a.current
      , u = l;
    for (let f in n) {
        const p = f === "base" ? n[f] + (e[f] || "") : e[f] || n[f];
        l === u && p !== u[f] && (a.current = u = {
            ...u
        }),
        u[f] = p,
        p !== n[f] && (s = u)
    }
    return b.createElement(f_.Provider, {
        value: s,
        children: t
    })
}
  , tv = ({children: t, component: e}, r) => e ? b.createElement(e, {
    params: r
}) : typeof t == "function" ? t(r) : t
  , UC = t => {
    let e = b.useRef(h_)
      , r = e.current;
    for (const n in t)
        t[n] !== r[n] && (r = t);
    return Object.keys(t).length === 0 && (r = t),
    e.current = r
}
  , ti = ({path: t, nest: e, match: r, ...n}) => {
    const s = hl()
      , [i] = zc(s)
      , [o,a,l] = r ?? g_(s.parser, t, i, e)
      , u = UC({
        ...m_(),
        ...a
    });
    if (!o)
        return null;
    const c = l ? b.createElement(FC, {
        base: l
    }, tv(n, u)) : tv(n, u);
    return b.createElement(p_.Provider, {
        value: u,
        children: c
    })
}
;
b.forwardRef( (t, e) => {
    const r = hl()
      , [n,s] = zc(r)
      , {to: i="", href: o=i, onClick: a, asChild: l, children: u, className: c, replace: d, state: f, ...p} = t
      , g = l_(w => {
        w.ctrlKey || w.metaKey || w.altKey || w.shiftKey || w.button !== 0 || (a == null || a(w),
        w.defaultPrevented || (w.preventDefault(),
        s(o, t)))
    }
    )
      , h = r.hrefs(o[0] === "~" ? o.slice(1) : r.base + o, r);
    return l && b.isValidElement(u) ? b.cloneElement(u, {
        onClick: g,
        href: h
    }) : b.createElement("a", {
        ...p,
        onClick: g,
        href: h,
        className: c != null && c.call ? c(n === o) : c,
        children: u,
        ref: e
    })
}
);
const v_ = t => Array.isArray(t) ? t.flatMap(e => v_(e && e.type === b.Fragment ? e.props.children : e)) : [t]
  , VC = ({children: t, location: e}) => {
    const r = hl()
      , [n] = zc(r);
    for (const s of v_(t)) {
        let i = 0;
        if (b.isValidElement(s) && (i = g_(r.parser, s.props.path, e || n, s.props.nest))[0])
            return b.cloneElement(s, {
                match: i
            })
    }
    return null
}
;
var Eo = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(t) {
        return this.listeners.add(t),
        this.onSubscribe(),
        () => {
            this.listeners.delete(t),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , Vs = typeof window > "u" || "Deno"in globalThis;
function Gt() {}
function BC(t, e) {
    return typeof t == "function" ? t(e) : t
}
function oh(t) {
    return typeof t == "number" && t >= 0 && t !== 1 / 0
}
function y_(t, e) {
    return Math.max(t + (e || 0) - Date.now(), 0)
}
function Fi(t, e) {
    return typeof t == "function" ? t(e) : t
}
function fr(t, e) {
    return typeof t == "function" ? t(e) : t
}
function rv(t, e) {
    const {type: r="all", exact: n, fetchStatus: s, predicate: i, queryKey: o, stale: a} = t;
    if (o) {
        if (n) {
            if (e.queryHash !== qp(o, e.options))
                return !1
        } else if (!Ma(e.queryKey, o))
            return !1
    }
    if (r !== "all") {
        const l = e.isActive();
        if (r === "active" && !l || r === "inactive" && l)
            return !1
    }
    return !(typeof a == "boolean" && e.isStale() !== a || s && s !== e.state.fetchStatus || i && !i(e))
}
function nv(t, e) {
    const {exact: r, status: n, predicate: s, mutationKey: i} = t;
    if (i) {
        if (!e.options.mutationKey)
            return !1;
        if (r) {
            if (Bs(e.options.mutationKey) !== Bs(i))
                return !1
        } else if (!Ma(e.options.mutationKey, i))
            return !1
    }
    return !(n && e.state.status !== n || s && !s(e))
}
function qp(t, e) {
    return ((e == null ? void 0 : e.queryKeyHashFn) || Bs)(t)
}
function Bs(t) {
    return JSON.stringify(t, (e, r) => ah(r) ? Object.keys(r).sort().reduce( (n, s) => (n[s] = r[s],
    n), {}) : r)
}
function Ma(t, e) {
    return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? !Object.keys(e).some(r => !Ma(t[r], e[r])) : !1
}
function w_(t, e) {
    if (t === e)
        return t;
    const r = sv(t) && sv(e);
    if (r || ah(t) && ah(e)) {
        const n = r ? t : Object.keys(t)
          , s = n.length
          , i = r ? e : Object.keys(e)
          , o = i.length
          , a = r ? [] : {};
        let l = 0;
        for (let u = 0; u < o; u++) {
            const c = r ? u : i[u];
            (!r && n.includes(c) || r) && t[c] === void 0 && e[c] === void 0 ? (a[c] = void 0,
            l++) : (a[c] = w_(t[c], e[c]),
            a[c] === t[c] && t[c] !== void 0 && l++)
        }
        return s === o && l === s ? t : a
    }
    return e
}
function Ju(t, e) {
    if (!e || Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const r in t)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function sv(t) {
    return Array.isArray(t) && t.length === Object.keys(t).length
}
function ah(t) {
    if (!iv(t))
        return !1;
    const e = t.constructor;
    if (e === void 0)
        return !0;
    const r = e.prototype;
    return !(!iv(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype)
}
function iv(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}
function zC(t) {
    return new Promise(e => {
        setTimeout(e, t)
    }
    )
}
function lh(t, e, r) {
    return typeof r.structuralSharing == "function" ? r.structuralSharing(t, e) : r.structuralSharing !== !1 ? w_(t, e) : e
}
function WC(t, e, r=0) {
    const n = [...t, e];
    return r && n.length > r ? n.slice(1) : n
}
function HC(t, e, r=0) {
    const n = [e, ...t];
    return r && n.length > r ? n.slice(0, -1) : n
}
var Kp = Symbol();
function __(t, e) {
    return !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === Kp ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn
}
var Cs, On, Ki, Iy, qC = (Iy = class extends Eo {
    constructor() {
        super();
        ee(this, Cs);
        ee(this, On);
        ee(this, Ki);
        z(this, Ki, e => {
            if (!Vs && window.addEventListener) {
                const r = () => e();
                return window.addEventListener("visibilitychange", r, !1),
                () => {
                    window.removeEventListener("visibilitychange", r)
                }
            }
        }
        )
    }
    onSubscribe() {
        E(this, On) || this.setEventListener(E(this, Ki))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = E(this, On)) == null || e.call(this),
        z(this, On, void 0))
    }
    setEventListener(e) {
        var r;
        z(this, Ki, e),
        (r = E(this, On)) == null || r.call(this),
        z(this, On, e(n => {
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus()
        }
        ))
    }
    setFocused(e) {
        E(this, Cs) !== e && (z(this, Cs, e),
        this.onFocus())
    }
    onFocus() {
        const e = this.isFocused();
        this.listeners.forEach(r => {
            r(e)
        }
        )
    }
    isFocused() {
        var e;
        return typeof E(this, Cs) == "boolean" ? E(this, Cs) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden"
    }
}
,
Cs = new WeakMap,
On = new WeakMap,
Ki = new WeakMap,
Iy), Gp = new qC, Gi, Pn, Qi, Dy, KC = (Dy = class extends Eo {
    constructor() {
        super();
        ee(this, Gi, !0);
        ee(this, Pn);
        ee(this, Qi);
        z(this, Qi, e => {
            if (!Vs && window.addEventListener) {
                const r = () => e(!0)
                  , n = () => e(!1);
                return window.addEventListener("online", r, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", r),
                    window.removeEventListener("offline", n)
                }
            }
        }
        )
    }
    onSubscribe() {
        E(this, Pn) || this.setEventListener(E(this, Qi))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = E(this, Pn)) == null || e.call(this),
        z(this, Pn, void 0))
    }
    setEventListener(e) {
        var r;
        z(this, Qi, e),
        (r = E(this, Pn)) == null || r.call(this),
        z(this, Pn, e(this.setOnline.bind(this)))
    }
    setOnline(e) {
        E(this, Gi) !== e && (z(this, Gi, e),
        this.listeners.forEach(n => {
            n(e)
        }
        ))
    }
    isOnline() {
        return E(this, Gi)
    }
}
,
Gi = new WeakMap,
Pn = new WeakMap,
Qi = new WeakMap,
Dy), Xu = new KC;
function uh() {
    let t, e;
    const r = new Promise( (s, i) => {
        t = s,
        e = i
    }
    );
    r.status = "pending",
    r.catch( () => {}
    );
    function n(s) {
        Object.assign(r, s),
        delete r.resolve,
        delete r.reject
    }
    return r.resolve = s => {
        n({
            status: "fulfilled",
            value: s
        }),
        t(s)
    }
    ,
    r.reject = s => {
        n({
            status: "rejected",
            reason: s
        }),
        e(s)
    }
    ,
    r
}
function GC(t) {
    return Math.min(1e3 * 2 ** t, 3e4)
}
function b_(t) {
    return (t ?? "online") === "online" ? Xu.isOnline() : !0
}
var x_ = class extends Error {
    constructor(t) {
        super("CancelledError"),
        this.revert = t == null ? void 0 : t.revert,
        this.silent = t == null ? void 0 : t.silent
    }
}
;
function Ud(t) {
    return t instanceof x_
}
function S_(t) {
    let e = !1, r = 0, n = !1, s;
    const i = uh()
      , o = h => {
        var w;
        n || (f(new x_(h)),
        (w = t.abort) == null || w.call(t))
    }
      , a = () => {
        e = !0
    }
      , l = () => {
        e = !1
    }
      , u = () => Gp.isFocused() && (t.networkMode === "always" || Xu.isOnline()) && t.canRun()
      , c = () => b_(t.networkMode) && t.canRun()
      , d = h => {
        var w;
        n || (n = !0,
        (w = t.onSuccess) == null || w.call(t, h),
        s == null || s(),
        i.resolve(h))
    }
      , f = h => {
        var w;
        n || (n = !0,
        (w = t.onError) == null || w.call(t, h),
        s == null || s(),
        i.reject(h))
    }
      , p = () => new Promise(h => {
        var w;
        s = v => {
            (n || u()) && h(v)
        }
        ,
        (w = t.onPause) == null || w.call(t)
    }
    ).then( () => {
        var h;
        s = void 0,
        n || (h = t.onContinue) == null || h.call(t)
    }
    )
      , g = () => {
        if (n)
            return;
        let h;
        const w = r === 0 ? t.initialPromise : void 0;
        try {
            h = w ?? t.fn()
        } catch (v) {
            h = Promise.reject(v)
        }
        Promise.resolve(h).then(d).catch(v => {
            var T;
            if (n)
                return;
            const m = t.retry ?? (Vs ? 0 : 3)
              , _ = t.retryDelay ?? GC
              , x = typeof _ == "function" ? _(r, v) : _
              , k = m === !0 || typeof m == "number" && r < m || typeof m == "function" && m(r, v);
            if (e || !k) {
                f(v);
                return
            }
            r++,
            (T = t.onFail) == null || T.call(t, r, v),
            zC(x).then( () => u() ? void 0 : p()).then( () => {
                e ? f(v) : g()
            }
            )
        }
        )
    }
    ;
    return {
        promise: i,
        cancel: o,
        continue: () => (s == null || s(),
        i),
        cancelRetry: a,
        continueRetry: l,
        canStart: c,
        start: () => (c() ? g() : p().then(g),
        i)
    }
}
function QC() {
    let t = []
      , e = 0
      , r = a => {
        a()
    }
      , n = a => {
        a()
    }
      , s = a => setTimeout(a, 0);
    const i = a => {
        e ? t.push(a) : s( () => {
            r(a)
        }
        )
    }
      , o = () => {
        const a = t;
        t = [],
        a.length && s( () => {
            n( () => {
                a.forEach(l => {
                    r(l)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: a => {
            let l;
            e++;
            try {
                l = a()
            } finally {
                e--,
                e || o()
            }
            return l
        }
        ,
        batchCalls: a => (...l) => {
            i( () => {
                a(...l)
            }
            )
        }
        ,
        schedule: i,
        setNotifyFunction: a => {
            r = a
        }
        ,
        setBatchNotifyFunction: a => {
            n = a
        }
        ,
        setScheduler: a => {
            s = a
        }
    }
}
var Qe = QC(), Ts, My, E_ = (My = class {
    constructor() {
        ee(this, Ts)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        oh(this.gcTime) && z(this, Ts, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(t) {
        this.gcTime = Math.max(this.gcTime || 0, t ?? (Vs ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        E(this, Ts) && (clearTimeout(E(this, Ts)),
        z(this, Ts, void 0))
    }
}
,
Ts = new WeakMap,
My), Zi, Yi, Kt, lt, nl, Os, lr, Hr, Ly, ZC = (Ly = class extends E_ {
    constructor(e) {
        super();
        ee(this, lr);
        ee(this, Zi);
        ee(this, Yi);
        ee(this, Kt);
        ee(this, lt);
        ee(this, nl);
        ee(this, Os);
        z(this, Os, !1),
        z(this, nl, e.defaultOptions),
        this.setOptions(e.options),
        this.observers = [],
        z(this, Kt, e.cache),
        this.queryKey = e.queryKey,
        this.queryHash = e.queryHash,
        z(this, Zi, YC(this.options)),
        this.state = e.state ?? E(this, Zi),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var e;
        return (e = E(this, lt)) == null ? void 0 : e.promise
    }
    setOptions(e) {
        this.options = {
            ...E(this, nl),
            ...e
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && E(this, Kt).remove(this)
    }
    setData(e, r) {
        const n = lh(this.state.data, e, this.options);
        return de(this, lr, Hr).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }),
        n
    }
    setState(e, r) {
        de(this, lr, Hr).call(this, {
            type: "setState",
            state: e,
            setStateOptions: r
        })
    }
    cancel(e) {
        var n, s;
        const r = (n = E(this, lt)) == null ? void 0 : n.promise;
        return (s = E(this, lt)) == null || s.cancel(e),
        r ? r.then(Gt).catch(Gt) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(E(this, Zi))
    }
    isActive() {
        return this.observers.some(e => fr(e.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Kp || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(e=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !y_(this.state.dataUpdatedAt, e)
    }
    onFocus() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnWindowFocus());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = E(this, lt)) == null || r.continue()
    }
    onOnline() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnReconnect());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = E(this, lt)) == null || r.continue()
    }
    addObserver(e) {
        this.observers.includes(e) || (this.observers.push(e),
        this.clearGcTimeout(),
        E(this, Kt).notify({
            type: "observerAdded",
            query: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.observers.includes(e) && (this.observers = this.observers.filter(r => r !== e),
        this.observers.length || (E(this, lt) && (E(this, Os) ? E(this, lt).cancel({
            revert: !0
        }) : E(this, lt).cancelRetry()),
        this.scheduleGc()),
        E(this, Kt).notify({
            type: "observerRemoved",
            query: this,
            observer: e
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || de(this, lr, Hr).call(this, {
            type: "invalidate"
        })
    }
    fetch(e, r) {
        var l, u, c;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (E(this, lt))
                return E(this, lt).continueRetry(),
                E(this, lt).promise
        }
        if (e && this.setOptions(e),
        !this.options.queryFn) {
            const d = this.observers.find(f => f.options.queryFn);
            d && this.setOptions(d.options)
        }
        const n = new AbortController
          , s = d => {
            Object.defineProperty(d, "signal", {
                enumerable: !0,
                get: () => (z(this, Os, !0),
                n.signal)
            })
        }
          , i = () => {
            const d = __(this.options, r)
              , f = {
                queryKey: this.queryKey,
                meta: this.meta
            };
            return s(f),
            z(this, Os, !1),
            this.options.persister ? this.options.persister(d, f, this) : d(f)
        }
          , o = {
            fetchOptions: r,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: i
        };
        s(o),
        (l = this.options.behavior) == null || l.onFetch(o, this),
        z(this, Yi, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = o.fetchOptions) == null ? void 0 : u.meta)) && de(this, lr, Hr).call(this, {
            type: "fetch",
            meta: (c = o.fetchOptions) == null ? void 0 : c.meta
        });
        const a = d => {
            var f, p, g, h;
            Ud(d) && d.silent || de(this, lr, Hr).call(this, {
                type: "error",
                error: d
            }),
            Ud(d) || ((p = (f = E(this, Kt).config).onError) == null || p.call(f, d, this),
            (h = (g = E(this, Kt).config).onSettled) == null || h.call(g, this.state.data, d, this)),
            this.scheduleGc()
        }
        ;
        return z(this, lt, S_({
            initialPromise: r == null ? void 0 : r.initialPromise,
            fn: o.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: d => {
                var f, p, g, h;
                if (d === void 0) {
                    a(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(d)
                } catch (w) {
                    a(w);
                    return
                }
                (p = (f = E(this, Kt).config).onSuccess) == null || p.call(f, d, this),
                (h = (g = E(this, Kt).config).onSettled) == null || h.call(g, d, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: a,
            onFail: (d, f) => {
                de(this, lr, Hr).call(this, {
                    type: "failed",
                    failureCount: d,
                    error: f
                })
            }
            ,
            onPause: () => {
                de(this, lr, Hr).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                de(this, lr, Hr).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: o.options.retry,
            retryDelay: o.options.retryDelay,
            networkMode: o.options.networkMode,
            canRun: () => !0
        })),
        E(this, lt).start()
    }
}
,
Zi = new WeakMap,
Yi = new WeakMap,
Kt = new WeakMap,
lt = new WeakMap,
nl = new WeakMap,
Os = new WeakMap,
lr = new WeakSet,
Hr = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                fetchFailureCount: e.failureCount,
                fetchFailureReason: e.error
            };
        case "pause":
            return {
                ...n,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...n,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...n,
                ...k_(n.data, this.options),
                fetchMeta: e.meta ?? null
            };
        case "success":
            return {
                ...n,
                data: e.data,
                dataUpdateCount: n.dataUpdateCount + 1,
                dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!e.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const s = e.error;
            return Ud(s) && s.revert && E(this, Yi) ? {
                ...E(this, Yi),
                fetchStatus: "idle"
            } : {
                ...n,
                error: s,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: s,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...n,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...n,
                ...e.state
            }
        }
    }
    ;
    this.state = r(this.state),
    Qe.batch( () => {
        this.observers.forEach(n => {
            n.onQueryUpdate()
        }
        ),
        E(this, Kt).notify({
            query: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
Ly);
function k_(t, e) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: b_(e.networkMode) ? "fetching" : "paused",
        ...t === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function YC(t) {
    const e = typeof t.initialData == "function" ? t.initialData() : t.initialData
      , r = e !== void 0
      , n = r ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
    return {
        data: e,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var Or, $y, JC = ($y = class extends Eo {
    constructor(e={}) {
        super();
        ee(this, Or);
        this.config = e,
        z(this, Or, new Map)
    }
    build(e, r, n) {
        const s = r.queryKey
          , i = r.queryHash ?? qp(s, r);
        let o = this.get(i);
        return o || (o = new ZC({
            cache: this,
            queryKey: s,
            queryHash: i,
            options: e.defaultQueryOptions(r),
            state: n,
            defaultOptions: e.getQueryDefaults(s)
        }),
        this.add(o)),
        o
    }
    add(e) {
        E(this, Or).has(e.queryHash) || (E(this, Or).set(e.queryHash, e),
        this.notify({
            type: "added",
            query: e
        }))
    }
    remove(e) {
        const r = E(this, Or).get(e.queryHash);
        r && (e.destroy(),
        r === e && E(this, Or).delete(e.queryHash),
        this.notify({
            type: "removed",
            query: e
        }))
    }
    clear() {
        Qe.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    get(e) {
        return E(this, Or).get(e)
    }
    getAll() {
        return [...E(this, Or).values()]
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => rv(r, n))
    }
    findAll(e={}) {
        const r = this.getAll();
        return Object.keys(e).length > 0 ? r.filter(n => rv(e, n)) : r
    }
    notify(e) {
        Qe.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    onFocus() {
        Qe.batch( () => {
            this.getAll().forEach(e => {
                e.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        Qe.batch( () => {
            this.getAll().forEach(e => {
                e.onOnline()
            }
            )
        }
        )
    }
}
,
Or = new WeakMap,
$y), Pr, ft, Ps, Rr, _n, Fy, XC = (Fy = class extends E_ {
    constructor(e) {
        super();
        ee(this, Rr);
        ee(this, Pr);
        ee(this, ft);
        ee(this, Ps);
        this.mutationId = e.mutationId,
        z(this, ft, e.mutationCache),
        z(this, Pr, []),
        this.state = e.state || C_(),
        this.setOptions(e.options),
        this.scheduleGc()
    }
    setOptions(e) {
        this.options = e,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(e) {
        E(this, Pr).includes(e) || (E(this, Pr).push(e),
        this.clearGcTimeout(),
        E(this, ft).notify({
            type: "observerAdded",
            mutation: this,
            observer: e
        }))
    }
    removeObserver(e) {
        z(this, Pr, E(this, Pr).filter(r => r !== e)),
        this.scheduleGc(),
        E(this, ft).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e
        })
    }
    optionalRemove() {
        E(this, Pr).length || (this.state.status === "pending" ? this.scheduleGc() : E(this, ft).remove(this))
    }
    continue() {
        var e;
        return ((e = E(this, Ps)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables)
    }
    async execute(e) {
        var s, i, o, a, l, u, c, d, f, p, g, h, w, v, m, _, x, k, T, C;
        z(this, Ps, S_({
            fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
            onFail: (P, j) => {
                de(this, Rr, _n).call(this, {
                    type: "failed",
                    failureCount: P,
                    error: j
                })
            }
            ,
            onPause: () => {
                de(this, Rr, _n).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                de(this, Rr, _n).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => E(this, ft).canRun(this)
        }));
        const r = this.state.status === "pending"
          , n = !E(this, Ps).canStart();
        try {
            if (!r) {
                de(this, Rr, _n).call(this, {
                    type: "pending",
                    variables: e,
                    isPaused: n
                }),
                await ((i = (s = E(this, ft).config).onMutate) == null ? void 0 : i.call(s, e, this));
                const j = await ((a = (o = this.options).onMutate) == null ? void 0 : a.call(o, e));
                j !== this.state.context && de(this, Rr, _n).call(this, {
                    type: "pending",
                    context: j,
                    variables: e,
                    isPaused: n
                })
            }
            const P = await E(this, Ps).start();
            return await ((u = (l = E(this, ft).config).onSuccess) == null ? void 0 : u.call(l, P, e, this.state.context, this)),
            await ((d = (c = this.options).onSuccess) == null ? void 0 : d.call(c, P, e, this.state.context)),
            await ((p = (f = E(this, ft).config).onSettled) == null ? void 0 : p.call(f, P, null, this.state.variables, this.state.context, this)),
            await ((h = (g = this.options).onSettled) == null ? void 0 : h.call(g, P, null, e, this.state.context)),
            de(this, Rr, _n).call(this, {
                type: "success",
                data: P
            }),
            P
        } catch (P) {
            try {
                throw await ((v = (w = E(this, ft).config).onError) == null ? void 0 : v.call(w, P, e, this.state.context, this)),
                await ((_ = (m = this.options).onError) == null ? void 0 : _.call(m, P, e, this.state.context)),
                await ((k = (x = E(this, ft).config).onSettled) == null ? void 0 : k.call(x, void 0, P, this.state.variables, this.state.context, this)),
                await ((C = (T = this.options).onSettled) == null ? void 0 : C.call(T, void 0, P, e, this.state.context)),
                P
            } finally {
                de(this, Rr, _n).call(this, {
                    type: "error",
                    error: P
                })
            }
        } finally {
            E(this, ft).runNext(this)
        }
    }
}
,
Pr = new WeakMap,
ft = new WeakMap,
Ps = new WeakMap,
Rr = new WeakSet,
_n = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                failureCount: e.failureCount,
                failureReason: e.error
            };
        case "pause":
            return {
                ...n,
                isPaused: !0
            };
        case "continue":
            return {
                ...n,
                isPaused: !1
            };
        case "pending":
            return {
                ...n,
                context: e.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: e.isPaused,
                status: "pending",
                variables: e.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...n,
                data: e.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...n,
                data: void 0,
                error: e.error,
                failureCount: n.failureCount + 1,
                failureReason: e.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = r(this.state),
    Qe.batch( () => {
        E(this, Pr).forEach(n => {
            n.onMutationUpdate(e)
        }
        ),
        E(this, ft).notify({
            mutation: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
Fy);
function C_() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var Nt, sl, Uy, eT = (Uy = class extends Eo {
    constructor(e={}) {
        super();
        ee(this, Nt);
        ee(this, sl);
        this.config = e,
        z(this, Nt, new Map),
        z(this, sl, Date.now())
    }
    build(e, r, n) {
        const s = new XC({
            mutationCache: this,
            mutationId: ++El(this, sl)._,
            options: e.defaultMutationOptions(r),
            state: n
        });
        return this.add(s),
        s
    }
    add(e) {
        const r = Bl(e)
          , n = E(this, Nt).get(r) ?? [];
        n.push(e),
        E(this, Nt).set(r, n),
        this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        var n;
        const r = Bl(e);
        if (E(this, Nt).has(r)) {
            const s = (n = E(this, Nt).get(r)) == null ? void 0 : n.filter(i => i !== e);
            s && (s.length === 0 ? E(this, Nt).delete(r) : E(this, Nt).set(r, s))
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        var n;
        const r = (n = E(this, Nt).get(Bl(e))) == null ? void 0 : n.find(s => s.state.status === "pending");
        return !r || r === e
    }
    runNext(e) {
        var n;
        const r = (n = E(this, Nt).get(Bl(e))) == null ? void 0 : n.find(s => s !== e && s.state.isPaused);
        return (r == null ? void 0 : r.continue()) ?? Promise.resolve()
    }
    clear() {
        Qe.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    getAll() {
        return [...E(this, Nt).values()].flat()
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => nv(r, n))
    }
    findAll(e={}) {
        return this.getAll().filter(r => nv(e, r))
    }
    notify(e) {
        Qe.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const e = this.getAll().filter(r => r.state.isPaused);
        return Qe.batch( () => Promise.all(e.map(r => r.continue().catch(Gt))))
    }
}
,
Nt = new WeakMap,
sl = new WeakMap,
Uy);
function Bl(t) {
    var e;
    return ((e = t.options.scope) == null ? void 0 : e.id) ?? String(t.mutationId)
}
function ov(t) {
    return {
        onFetch: (e, r) => {
            var c, d, f, p, g;
            const n = e.options
              , s = (f = (d = (c = e.fetchOptions) == null ? void 0 : c.meta) == null ? void 0 : d.fetchMore) == null ? void 0 : f.direction
              , i = ((p = e.state.data) == null ? void 0 : p.pages) || []
              , o = ((g = e.state.data) == null ? void 0 : g.pageParams) || [];
            let a = {
                pages: [],
                pageParams: []
            }
              , l = 0;
            const u = async () => {
                let h = !1;
                const w = _ => {
                    Object.defineProperty(_, "signal", {
                        enumerable: !0,
                        get: () => (e.signal.aborted ? h = !0 : e.signal.addEventListener("abort", () => {
                            h = !0
                        }
                        ),
                        e.signal)
                    })
                }
                  , v = __(e.options, e.fetchOptions)
                  , m = async (_, x, k) => {
                    if (h)
                        return Promise.reject();
                    if (x == null && _.pages.length)
                        return Promise.resolve(_);
                    const T = {
                        queryKey: e.queryKey,
                        pageParam: x,
                        direction: k ? "backward" : "forward",
                        meta: e.options.meta
                    };
                    w(T);
                    const C = await v(T)
                      , {maxPages: P} = e.options
                      , j = k ? HC : WC;
                    return {
                        pages: j(_.pages, C, P),
                        pageParams: j(_.pageParams, x, P)
                    }
                }
                ;
                if (s && i.length) {
                    const _ = s === "backward"
                      , x = _ ? tT : av
                      , k = {
                        pages: i,
                        pageParams: o
                    }
                      , T = x(n, k);
                    a = await m(k, T, _)
                } else {
                    const _ = t ?? i.length;
                    do {
                        const x = l === 0 ? o[0] ?? n.initialPageParam : av(n, a);
                        if (l > 0 && x == null)
                            break;
                        a = await m(a, x),
                        l++
                    } while (l < _)
                }
                return a
            }
            ;
            e.options.persister ? e.fetchFn = () => {
                var h, w;
                return (w = (h = e.options).persister) == null ? void 0 : w.call(h, u, {
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal
                }, r)
            }
            : e.fetchFn = u
        }
    }
}
function av(t, {pages: e, pageParams: r}) {
    const n = e.length - 1;
    return e.length > 0 ? t.getNextPageParam(e[n], e, r[n], r) : void 0
}
function tT(t, {pages: e, pageParams: r}) {
    var n;
    return e.length > 0 ? (n = t.getPreviousPageParam) == null ? void 0 : n.call(t, e[0], e, r[0], r) : void 0
}
var Le, Rn, An, Ji, Xi, jn, eo, to, Vy, rT = (Vy = class {
    constructor(t={}) {
        ee(this, Le);
        ee(this, Rn);
        ee(this, An);
        ee(this, Ji);
        ee(this, Xi);
        ee(this, jn);
        ee(this, eo);
        ee(this, to);
        z(this, Le, t.queryCache || new JC),
        z(this, Rn, t.mutationCache || new eT),
        z(this, An, t.defaultOptions || {}),
        z(this, Ji, new Map),
        z(this, Xi, new Map),
        z(this, jn, 0)
    }
    mount() {
        El(this, jn)._++,
        E(this, jn) === 1 && (z(this, eo, Gp.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            E(this, Le).onFocus())
        }
        )),
        z(this, to, Xu.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            E(this, Le).onOnline())
        }
        )))
    }
    unmount() {
        var t, e;
        El(this, jn)._--,
        E(this, jn) === 0 && ((t = E(this, eo)) == null || t.call(this),
        z(this, eo, void 0),
        (e = E(this, to)) == null || e.call(this),
        z(this, to, void 0))
    }
    isFetching(t) {
        return E(this, Le).findAll({
            ...t,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(t) {
        return E(this, Rn).findAll({
            ...t,
            status: "pending"
        }).length
    }
    getQueryData(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = E(this, Le).get(e.queryHash)) == null ? void 0 : r.state.data
    }
    ensureQueryData(t) {
        const e = this.getQueryData(t.queryKey);
        if (e === void 0)
            return this.fetchQuery(t);
        {
            const r = this.defaultQueryOptions(t)
              , n = E(this, Le).build(this, r);
            return t.revalidateIfStale && n.isStaleByTime(Fi(r.staleTime, n)) && this.prefetchQuery(r),
            Promise.resolve(e)
        }
    }
    getQueriesData(t) {
        return E(this, Le).findAll(t).map( ({queryKey: e, state: r}) => {
            const n = r.data;
            return [e, n]
        }
        )
    }
    setQueryData(t, e, r) {
        const n = this.defaultQueryOptions({
            queryKey: t
        })
          , s = E(this, Le).get(n.queryHash)
          , i = s == null ? void 0 : s.state.data
          , o = BC(e, i);
        if (o !== void 0)
            return E(this, Le).build(this, n).setData(o, {
                ...r,
                manual: !0
            })
    }
    setQueriesData(t, e, r) {
        return Qe.batch( () => E(this, Le).findAll(t).map( ({queryKey: n}) => [n, this.setQueryData(n, e, r)]))
    }
    getQueryState(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = E(this, Le).get(e.queryHash)) == null ? void 0 : r.state
    }
    removeQueries(t) {
        const e = E(this, Le);
        Qe.batch( () => {
            e.findAll(t).forEach(r => {
                e.remove(r)
            }
            )
        }
        )
    }
    resetQueries(t, e) {
        const r = E(this, Le)
          , n = {
            type: "active",
            ...t
        };
        return Qe.batch( () => (r.findAll(t).forEach(s => {
            s.reset()
        }
        ),
        this.refetchQueries(n, e)))
    }
    cancelQueries(t={}, e={}) {
        const r = {
            revert: !0,
            ...e
        }
          , n = Qe.batch( () => E(this, Le).findAll(t).map(s => s.cancel(r)));
        return Promise.all(n).then(Gt).catch(Gt)
    }
    invalidateQueries(t={}, e={}) {
        return Qe.batch( () => {
            if (E(this, Le).findAll(t).forEach(n => {
                n.invalidate()
            }
            ),
            t.refetchType === "none")
                return Promise.resolve();
            const r = {
                ...t,
                type: t.refetchType ?? t.type ?? "active"
            };
            return this.refetchQueries(r, e)
        }
        )
    }
    refetchQueries(t={}, e) {
        const r = {
            ...e,
            cancelRefetch: (e == null ? void 0 : e.cancelRefetch) ?? !0
        }
          , n = Qe.batch( () => E(this, Le).findAll(t).filter(s => !s.isDisabled()).map(s => {
            let i = s.fetch(void 0, r);
            return r.throwOnError || (i = i.catch(Gt)),
            s.state.fetchStatus === "paused" ? Promise.resolve() : i
        }
        ));
        return Promise.all(n).then(Gt)
    }
    fetchQuery(t) {
        const e = this.defaultQueryOptions(t);
        e.retry === void 0 && (e.retry = !1);
        const r = E(this, Le).build(this, e);
        return r.isStaleByTime(Fi(e.staleTime, r)) ? r.fetch(e) : Promise.resolve(r.state.data)
    }
    prefetchQuery(t) {
        return this.fetchQuery(t).then(Gt).catch(Gt)
    }
    fetchInfiniteQuery(t) {
        return t.behavior = ov(t.pages),
        this.fetchQuery(t)
    }
    prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then(Gt).catch(Gt)
    }
    ensureInfiniteQueryData(t) {
        return t.behavior = ov(t.pages),
        this.ensureQueryData(t)
    }
    resumePausedMutations() {
        return Xu.isOnline() ? E(this, Rn).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return E(this, Le)
    }
    getMutationCache() {
        return E(this, Rn)
    }
    getDefaultOptions() {
        return E(this, An)
    }
    setDefaultOptions(t) {
        z(this, An, t)
    }
    setQueryDefaults(t, e) {
        E(this, Ji).set(Bs(t), {
            queryKey: t,
            defaultOptions: e
        })
    }
    getQueryDefaults(t) {
        const e = [...E(this, Ji).values()];
        let r = {};
        return e.forEach(n => {
            Ma(t, n.queryKey) && (r = {
                ...r,
                ...n.defaultOptions
            })
        }
        ),
        r
    }
    setMutationDefaults(t, e) {
        E(this, Xi).set(Bs(t), {
            mutationKey: t,
            defaultOptions: e
        })
    }
    getMutationDefaults(t) {
        const e = [...E(this, Xi).values()];
        let r = {};
        return e.forEach(n => {
            Ma(t, n.mutationKey) && (r = {
                ...r,
                ...n.defaultOptions
            })
        }
        ),
        r
    }
    defaultQueryOptions(t) {
        if (t._defaulted)
            return t;
        const e = {
            ...E(this, An).queries,
            ...this.getQueryDefaults(t.queryKey),
            ...t,
            _defaulted: !0
        };
        return e.queryHash || (e.queryHash = qp(e.queryKey, e)),
        e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"),
        e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
        !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
        e.enabled !== !0 && e.queryFn === Kp && (e.enabled = !1),
        e
    }
    defaultMutationOptions(t) {
        return t != null && t._defaulted ? t : {
            ...E(this, An).mutations,
            ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
            ...t,
            _defaulted: !0
        }
    }
    clear() {
        E(this, Le).clear(),
        E(this, Rn).clear()
    }
}
,
Le = new WeakMap,
Rn = new WeakMap,
An = new WeakMap,
Ji = new WeakMap,
Xi = new WeakMap,
jn = new WeakMap,
eo = new WeakMap,
to = new WeakMap,
Vy), Et, pe, il, ht, Rs, ro, Nn, Ar, ol, no, so, As, js, In, io, _e, ta, ch, dh, fh, hh, ph, mh, gh, T_, By, nT = (By = class extends Eo {
    constructor(e, r) {
        super();
        ee(this, _e);
        ee(this, Et);
        ee(this, pe);
        ee(this, il);
        ee(this, ht);
        ee(this, Rs);
        ee(this, ro);
        ee(this, Nn);
        ee(this, Ar);
        ee(this, ol);
        ee(this, no);
        ee(this, so);
        ee(this, As);
        ee(this, js);
        ee(this, In);
        ee(this, io, new Set);
        this.options = r,
        z(this, Et, e),
        z(this, Ar, null),
        z(this, Nn, uh()),
        this.options.experimental_prefetchInRender || E(this, Nn).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(r)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (E(this, pe).addObserver(this),
        lv(E(this, pe), this.options) ? de(this, _e, ta).call(this) : this.updateResult(),
        de(this, _e, hh).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return vh(E(this, pe), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return vh(E(this, pe), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        de(this, _e, ph).call(this),
        de(this, _e, mh).call(this),
        E(this, pe).removeObserver(this)
    }
    setOptions(e, r) {
        const n = this.options
          , s = E(this, pe);
        if (this.options = E(this, Et).defaultQueryOptions(e),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof fr(this.options.enabled, E(this, pe)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        de(this, _e, gh).call(this),
        E(this, pe).setOptions(this.options),
        n._defaulted && !Ju(this.options, n) && E(this, Et).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: E(this, pe),
            observer: this
        });
        const i = this.hasListeners();
        i && uv(E(this, pe), s, this.options, n) && de(this, _e, ta).call(this),
        this.updateResult(r),
        i && (E(this, pe) !== s || fr(this.options.enabled, E(this, pe)) !== fr(n.enabled, E(this, pe)) || Fi(this.options.staleTime, E(this, pe)) !== Fi(n.staleTime, E(this, pe))) && de(this, _e, ch).call(this);
        const o = de(this, _e, dh).call(this);
        i && (E(this, pe) !== s || fr(this.options.enabled, E(this, pe)) !== fr(n.enabled, E(this, pe)) || o !== E(this, In)) && de(this, _e, fh).call(this, o)
    }
    getOptimisticResult(e) {
        const r = E(this, Et).getQueryCache().build(E(this, Et), e)
          , n = this.createResult(r, e);
        return iT(this, n) && (z(this, ht, n),
        z(this, ro, this.options),
        z(this, Rs, E(this, pe).state)),
        n
    }
    getCurrentResult() {
        return E(this, ht)
    }
    trackResult(e, r) {
        const n = {};
        return Object.keys(e).forEach(s => {
            Object.defineProperty(n, s, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(s),
                r == null || r(s),
                e[s])
            })
        }
        ),
        n
    }
    trackProp(e) {
        E(this, io).add(e)
    }
    getCurrentQuery() {
        return E(this, pe)
    }
    refetch({...e}={}) {
        return this.fetch({
            ...e
        })
    }
    fetchOptimistic(e) {
        const r = E(this, Et).defaultQueryOptions(e)
          , n = E(this, Et).getQueryCache().build(E(this, Et), r);
        return n.fetch().then( () => this.createResult(n, r))
    }
    fetch(e) {
        return de(this, _e, ta).call(this, {
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        E(this, ht)))
    }
    createResult(e, r) {
        var P;
        const n = E(this, pe)
          , s = this.options
          , i = E(this, ht)
          , o = E(this, Rs)
          , a = E(this, ro)
          , u = e !== n ? e.state : E(this, il)
          , {state: c} = e;
        let d = {
            ...c
        }, f = !1, p;
        if (r._optimisticResults) {
            const j = this.hasListeners()
              , $ = !j && lv(e, r)
              , X = j && uv(e, n, r, s);
            ($ || X) && (d = {
                ...d,
                ...k_(c.data, e.options)
            }),
            r._optimisticResults === "isRestoring" && (d.fetchStatus = "idle")
        }
        let {error: g, errorUpdatedAt: h, status: w} = d;
        if (r.select && d.data !== void 0)
            if (i && d.data === (o == null ? void 0 : o.data) && r.select === E(this, ol))
                p = E(this, no);
            else
                try {
                    z(this, ol, r.select),
                    p = r.select(d.data),
                    p = lh(i == null ? void 0 : i.data, p, r),
                    z(this, no, p),
                    z(this, Ar, null)
                } catch (j) {
                    z(this, Ar, j)
                }
        else
            p = d.data;
        if (r.placeholderData !== void 0 && p === void 0 && w === "pending") {
            let j;
            if (i != null && i.isPlaceholderData && r.placeholderData === (a == null ? void 0 : a.placeholderData))
                j = i.data;
            else if (j = typeof r.placeholderData == "function" ? r.placeholderData((P = E(this, so)) == null ? void 0 : P.state.data, E(this, so)) : r.placeholderData,
            r.select && j !== void 0)
                try {
                    j = r.select(j),
                    z(this, Ar, null)
                } catch ($) {
                    z(this, Ar, $)
                }
            j !== void 0 && (w = "success",
            p = lh(i == null ? void 0 : i.data, j, r),
            f = !0)
        }
        E(this, Ar) && (g = E(this, Ar),
        p = E(this, no),
        h = Date.now(),
        w = "error");
        const v = d.fetchStatus === "fetching"
          , m = w === "pending"
          , _ = w === "error"
          , x = m && v
          , k = p !== void 0
          , C = {
            status: w,
            fetchStatus: d.fetchStatus,
            isPending: m,
            isSuccess: w === "success",
            isError: _,
            isInitialLoading: x,
            isLoading: x,
            data: p,
            dataUpdatedAt: d.dataUpdatedAt,
            error: g,
            errorUpdatedAt: h,
            failureCount: d.fetchFailureCount,
            failureReason: d.fetchFailureReason,
            errorUpdateCount: d.errorUpdateCount,
            isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
            isFetchedAfterMount: d.dataUpdateCount > u.dataUpdateCount || d.errorUpdateCount > u.errorUpdateCount,
            isFetching: v,
            isRefetching: v && !m,
            isLoadingError: _ && !k,
            isPaused: d.fetchStatus === "paused",
            isPlaceholderData: f,
            isRefetchError: _ && k,
            isStale: Qp(e, r),
            refetch: this.refetch,
            promise: E(this, Nn)
        };
        if (this.options.experimental_prefetchInRender) {
            const j = D => {
                C.status === "error" ? D.reject(C.error) : C.data !== void 0 && D.resolve(C.data)
            }
              , $ = () => {
                const D = z(this, Nn, C.promise = uh());
                j(D)
            }
              , X = E(this, Nn);
            switch (X.status) {
            case "pending":
                e.queryHash === n.queryHash && j(X);
                break;
            case "fulfilled":
                (C.status === "error" || C.data !== X.value) && $();
                break;
            case "rejected":
                (C.status !== "error" || C.error !== X.reason) && $();
                break
            }
        }
        return C
    }
    updateResult(e) {
        const r = E(this, ht)
          , n = this.createResult(E(this, pe), this.options);
        if (z(this, Rs, E(this, pe).state),
        z(this, ro, this.options),
        E(this, Rs).data !== void 0 && z(this, so, E(this, pe)),
        Ju(n, r))
            return;
        z(this, ht, n);
        const s = {}
          , i = () => {
            if (!r)
                return !0;
            const {notifyOnChangeProps: o} = this.options
              , a = typeof o == "function" ? o() : o;
            if (a === "all" || !a && !E(this, io).size)
                return !0;
            const l = new Set(a ?? E(this, io));
            return this.options.throwOnError && l.add("error"),
            Object.keys(E(this, ht)).some(u => {
                const c = u;
                return E(this, ht)[c] !== r[c] && l.has(c)
            }
            )
        }
        ;
        (e == null ? void 0 : e.listeners) !== !1 && i() && (s.listeners = !0),
        de(this, _e, T_).call(this, {
            ...s,
            ...e
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && de(this, _e, hh).call(this)
    }
}
,
Et = new WeakMap,
pe = new WeakMap,
il = new WeakMap,
ht = new WeakMap,
Rs = new WeakMap,
ro = new WeakMap,
Nn = new WeakMap,
Ar = new WeakMap,
ol = new WeakMap,
no = new WeakMap,
so = new WeakMap,
As = new WeakMap,
js = new WeakMap,
In = new WeakMap,
io = new WeakMap,
_e = new WeakSet,
ta = function(e) {
    de(this, _e, gh).call(this);
    let r = E(this, pe).fetch(this.options, e);
    return e != null && e.throwOnError || (r = r.catch(Gt)),
    r
}
,
ch = function() {
    de(this, _e, ph).call(this);
    const e = Fi(this.options.staleTime, E(this, pe));
    if (Vs || E(this, ht).isStale || !oh(e))
        return;
    const n = y_(E(this, ht).dataUpdatedAt, e) + 1;
    z(this, As, setTimeout( () => {
        E(this, ht).isStale || this.updateResult()
    }
    , n))
}
,
dh = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(E(this, pe)) : this.options.refetchInterval) ?? !1
}
,
fh = function(e) {
    de(this, _e, mh).call(this),
    z(this, In, e),
    !(Vs || fr(this.options.enabled, E(this, pe)) === !1 || !oh(E(this, In)) || E(this, In) === 0) && z(this, js, setInterval( () => {
        (this.options.refetchIntervalInBackground || Gp.isFocused()) && de(this, _e, ta).call(this)
    }
    , E(this, In)))
}
,
hh = function() {
    de(this, _e, ch).call(this),
    de(this, _e, fh).call(this, de(this, _e, dh).call(this))
}
,
ph = function() {
    E(this, As) && (clearTimeout(E(this, As)),
    z(this, As, void 0))
}
,
mh = function() {
    E(this, js) && (clearInterval(E(this, js)),
    z(this, js, void 0))
}
,
gh = function() {
    const e = E(this, Et).getQueryCache().build(E(this, Et), this.options);
    if (e === E(this, pe))
        return;
    const r = E(this, pe);
    z(this, pe, e),
    z(this, il, e.state),
    this.hasListeners() && (r == null || r.removeObserver(this),
    e.addObserver(this))
}
,
T_ = function(e) {
    Qe.batch( () => {
        e.listeners && this.listeners.forEach(r => {
            r(E(this, ht))
        }
        ),
        E(this, Et).getQueryCache().notify({
            query: E(this, pe),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
By);
function sT(t, e) {
    return fr(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1)
}
function lv(t, e) {
    return sT(t, e) || t.state.data !== void 0 && vh(t, e, e.refetchOnMount)
}
function vh(t, e, r) {
    if (fr(e.enabled, t) !== !1) {
        const n = typeof r == "function" ? r(t) : r;
        return n === "always" || n !== !1 && Qp(t, e)
    }
    return !1
}
function uv(t, e, r, n) {
    return (t !== e || fr(n.enabled, t) === !1) && (!r.suspense || t.state.status !== "error") && Qp(t, r)
}
function Qp(t, e) {
    return fr(e.enabled, t) !== !1 && t.isStaleByTime(Fi(e.staleTime, t))
}
function iT(t, e) {
    return !Ju(t.getCurrentResult(), e)
}
var Dn, Mn, kt, Yr, rn, _u, yh, zy, oT = (zy = class extends Eo {
    constructor(r, n) {
        super();
        ee(this, rn);
        ee(this, Dn);
        ee(this, Mn);
        ee(this, kt);
        ee(this, Yr);
        z(this, Dn, r),
        this.setOptions(n),
        this.bindMethods(),
        de(this, rn, _u).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(r) {
        var s;
        const n = this.options;
        this.options = E(this, Dn).defaultMutationOptions(r),
        Ju(this.options, n) || E(this, Dn).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: E(this, kt),
            observer: this
        }),
        n != null && n.mutationKey && this.options.mutationKey && Bs(n.mutationKey) !== Bs(this.options.mutationKey) ? this.reset() : ((s = E(this, kt)) == null ? void 0 : s.state.status) === "pending" && E(this, kt).setOptions(this.options)
    }
    onUnsubscribe() {
        var r;
        this.hasListeners() || (r = E(this, kt)) == null || r.removeObserver(this)
    }
    onMutationUpdate(r) {
        de(this, rn, _u).call(this),
        de(this, rn, yh).call(this, r)
    }
    getCurrentResult() {
        return E(this, Mn)
    }
    reset() {
        var r;
        (r = E(this, kt)) == null || r.removeObserver(this),
        z(this, kt, void 0),
        de(this, rn, _u).call(this),
        de(this, rn, yh).call(this)
    }
    mutate(r, n) {
        var s;
        return z(this, Yr, n),
        (s = E(this, kt)) == null || s.removeObserver(this),
        z(this, kt, E(this, Dn).getMutationCache().build(E(this, Dn), this.options)),
        E(this, kt).addObserver(this),
        E(this, kt).execute(r)
    }
}
,
Dn = new WeakMap,
Mn = new WeakMap,
kt = new WeakMap,
Yr = new WeakMap,
rn = new WeakSet,
_u = function() {
    var n;
    const r = ((n = E(this, kt)) == null ? void 0 : n.state) ?? C_();
    z(this, Mn, {
        ...r,
        isPending: r.status === "pending",
        isSuccess: r.status === "success",
        isError: r.status === "error",
        isIdle: r.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
yh = function(r) {
    Qe.batch( () => {
        var n, s, i, o, a, l, u, c;
        if (E(this, Yr) && this.hasListeners()) {
            const d = E(this, Mn).variables
              , f = E(this, Mn).context;
            (r == null ? void 0 : r.type) === "success" ? ((s = (n = E(this, Yr)).onSuccess) == null || s.call(n, r.data, d, f),
            (o = (i = E(this, Yr)).onSettled) == null || o.call(i, r.data, null, d, f)) : (r == null ? void 0 : r.type) === "error" && ((l = (a = E(this, Yr)).onError) == null || l.call(a, r.error, d, f),
            (c = (u = E(this, Yr)).onSettled) == null || c.call(u, void 0, r.error, d, f))
        }
        this.listeners.forEach(d => {
            d(E(this, Mn))
        }
        )
    }
    )
}
,
zy), O_ = b.createContext(void 0), P_ = t => {
    const e = b.useContext(O_);
    if (!e)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e
}
, aT = ({client: t, children: e}) => (b.useEffect( () => (t.mount(),
() => {
    t.unmount()
}
), [t]),
y.jsx(O_.Provider, {
    value: t,
    children: e
})), R_ = b.createContext(!1), lT = () => b.useContext(R_);
R_.Provider;
function uT() {
    let t = !1;
    return {
        clearReset: () => {
            t = !1
        }
        ,
        reset: () => {
            t = !0
        }
        ,
        isReset: () => t
    }
}
var cT = b.createContext(uT())
  , dT = () => b.useContext(cT);
function A_(t, e) {
    return typeof t == "function" ? t(...e) : !!t
}
function wh() {}
var fT = (t, e) => {
    (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1))
}
  , hT = t => {
    b.useEffect( () => {
        t.clearReset()
    }
    , [t])
}
  , pT = ({result: t, errorResetBoundary: e, throwOnError: r, query: n}) => t.isError && !e.isReset() && !t.isFetching && n && A_(r, [t.error, n])
  , mT = t => {
    t.suspense && (t.staleTime === void 0 && (t.staleTime = 1e3),
    typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)))
}
  , gT = (t, e) => t.isLoading && t.isFetching && !e
  , vT = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending
  , cv = (t, e, r) => e.fetchOptimistic(t).catch( () => {
    r.clearReset()
}
);
function yT(t, e, r) {
    var c, d, f, p, g;
    const n = P_()
      , s = lT()
      , i = dT()
      , o = n.defaultQueryOptions(t);
    (d = (c = n.getDefaultOptions().queries) == null ? void 0 : c._experimental_beforeQuery) == null || d.call(c, o),
    o._optimisticResults = s ? "isRestoring" : "optimistic",
    mT(o),
    fT(o, i),
    hT(i);
    const a = !n.getQueryCache().get(o.queryHash)
      , [l] = b.useState( () => new e(n,o))
      , u = l.getOptimisticResult(o);
    if (b.useSyncExternalStore(b.useCallback(h => {
        const w = s ? wh : l.subscribe(Qe.batchCalls(h));
        return l.updateResult(),
        w
    }
    , [l, s]), () => l.getCurrentResult(), () => l.getCurrentResult()),
    b.useEffect( () => {
        l.setOptions(o, {
            listeners: !1
        })
    }
    , [o, l]),
    vT(o, u))
        throw cv(o, l, i);
    if (pT({
        result: u,
        errorResetBoundary: i,
        throwOnError: o.throwOnError,
        query: n.getQueryCache().get(o.queryHash)
    }))
        throw u.error;
    if ((p = (f = n.getDefaultOptions().queries) == null ? void 0 : f._experimental_afterQuery) == null || p.call(f, o, u),
    o.experimental_prefetchInRender && !Vs && gT(u, s)) {
        const h = a ? cv(o, l, i) : (g = n.getQueryCache().get(o.queryHash)) == null ? void 0 : g.promise;
        h == null || h.catch(wh).finally( () => {
            l.updateResult()
        }
        )
    }
    return o.notifyOnChangeProps ? u : l.trackResult(u)
}
function j_(t, e) {
    return yT(t, nT)
}
function ec(t, e) {
    const r = P_()
      , [n] = b.useState( () => new oT(r,t));
    b.useEffect( () => {
        n.setOptions(t)
    }
    , [n, t]);
    const s = b.useSyncExternalStore(b.useCallback(o => n.subscribe(Qe.batchCalls(o)), [n]), () => n.getCurrentResult(), () => n.getCurrentResult())
      , i = b.useCallback( (o, a) => {
        n.mutate(o, a).catch(wh)
    }
    , [n]);
    if (s.error && A_(n.options.throwOnError, [s.error]))
        throw s.error;
    return {
        ...s,
        mutate: i,
        mutateAsync: s.mutate
    }
}
async function wT(t) {
    if (!t.ok) {
        const e = await t.text() || t.statusText;
        throw new Error(`${t.status}: ${e}`)
    }
}
const _T = ({on401: t}) => async ({queryKey: e}) => {
    const r = await fetch(e.join("/"), {
        credentials: "include"
    });
    return t === "returnNull" && r.status === 401 ? null : (await wT(r),
    await r.json())
}
  , Nr = new rT({
    defaultOptions: {
        queries: {
            queryFn: _T({
                on401: "throw"
            }),
            refetchInterval: !1,
            refetchOnWindowFocus: !1,
            staleTime: 1 / 0,
            retry: !1
        },
        mutations: {
            retry: !1
        }
    }
})
  , bT = 1
  , xT = 1e6;
let Vd = 0;
function ST() {
    return Vd = (Vd + 1) % Number.MAX_SAFE_INTEGER,
    Vd.toString()
}
const Bd = new Map
  , dv = t => {
    if (Bd.has(t))
        return;
    const e = setTimeout( () => {
        Bd.delete(t),
        pa({
            type: "REMOVE_TOAST",
            toastId: t
        })
    }
    , xT);
    Bd.set(t, e)
}
  , ET = (t, e) => {
    switch (e.type) {
    case "ADD_TOAST":
        return {
            ...t,
            toasts: [e.toast, ...t.toasts].slice(0, bT)
        };
    case "UPDATE_TOAST":
        return {
            ...t,
            toasts: t.toasts.map(r => r.id === e.toast.id ? {
                ...r,
                ...e.toast
            } : r)
        };
    case "DISMISS_TOAST":
        {
            const {toastId: r} = e;
            return r ? dv(r) : t.toasts.forEach(n => {
                dv(n.id)
            }
            ),
            {
                ...t,
                toasts: t.toasts.map(n => n.id === r || r === void 0 ? {
                    ...n,
                    open: !1
                } : n)
            }
        }
    case "REMOVE_TOAST":
        return e.toastId === void 0 ? {
            ...t,
            toasts: []
        } : {
            ...t,
            toasts: t.toasts.filter(r => r.id !== e.toastId)
        }
    }
}
  , bu = [];
let xu = {
    toasts: []
};
function pa(t) {
    xu = ET(xu, t),
    bu.forEach(e => {
        e(xu)
    }
    )
}
function kT({...t}) {
    const e = ST()
      , r = s => pa({
        type: "UPDATE_TOAST",
        toast: {
            ...s,
            id: e
        }
    })
      , n = () => pa({
        type: "DISMISS_TOAST",
        toastId: e
    });
    return pa({
        type: "ADD_TOAST",
        toast: {
            ...t,
            id: e,
            open: !0,
            onOpenChange: s => {
                s || n()
            }
        }
    }),
    {
        id: e,
        dismiss: n,
        update: r
    }
}
function ko() {
    const [t,e] = b.useState(xu);
    return b.useEffect( () => (bu.push(e),
    () => {
        const r = bu.indexOf(e);
        r > -1 && bu.splice(r, 1)
    }
    ), [t]),
    {
        ...t,
        toast: kT,
        dismiss: r => pa({
            type: "DISMISS_TOAST",
            toastId: r
        })
    }
}
function Pe(t, e, {checkForDefaultPrevented: r=!0}={}) {
    return function(s) {
        if (t == null || t(s),
        r === !1 || !s.defaultPrevented)
            return e == null ? void 0 : e(s)
    }
}
function fv(t, e) {
    if (typeof t == "function")
        return t(e);
    t != null && (t.current = e)
}
function N_(...t) {
    return e => {
        let r = !1;
        const n = t.map(s => {
            const i = fv(s, e);
            return !r && typeof i == "function" && (r = !0),
            i
        }
        );
        if (r)
            return () => {
                for (let s = 0; s < n.length; s++) {
                    const i = n[s];
                    typeof i == "function" ? i() : fv(t[s], null)
                }
            }
    }
}
function st(...t) {
    return b.useCallback(N_(...t), t)
}
function CT(t, e) {
    const r = b.createContext(e)
      , n = i => {
        const {children: o, ...a} = i
          , l = b.useMemo( () => a, Object.values(a));
        return y.jsx(r.Provider, {
            value: l,
            children: o
        })
    }
    ;
    n.displayName = t + "Provider";
    function s(i) {
        const o = b.useContext(r);
        if (o)
            return o;
        if (e !== void 0)
            return e;
        throw new Error(`\`${i}\` must be used within \`${t}\``)
    }
    return [n, s]
}
function Co(t, e=[]) {
    let r = [];
    function n(i, o) {
        const a = b.createContext(o)
          , l = r.length;
        r = [...r, o];
        const u = d => {
            var v;
            const {scope: f, children: p, ...g} = d
              , h = ((v = f == null ? void 0 : f[t]) == null ? void 0 : v[l]) || a
              , w = b.useMemo( () => g, Object.values(g));
            return y.jsx(h.Provider, {
                value: w,
                children: p
            })
        }
        ;
        u.displayName = i + "Provider";
        function c(d, f) {
            var h;
            const p = ((h = f == null ? void 0 : f[t]) == null ? void 0 : h[l]) || a
              , g = b.useContext(p);
            if (g)
                return g;
            if (o !== void 0)
                return o;
            throw new Error(`\`${d}\` must be used within \`${i}\``)
        }
        return [u, c]
    }
    const s = () => {
        const i = r.map(o => b.createContext(o));
        return function(a) {
            const l = (a == null ? void 0 : a[t]) || i;
            return b.useMemo( () => ({
                [`__scope${t}`]: {
                    ...a,
                    [t]: l
                }
            }), [a, l])
        }
    }
    ;
    return s.scopeName = t,
    [n, TT(s, ...e)]
}
function TT(...t) {
    const e = t[0];
    if (t.length === 1)
        return e;
    const r = () => {
        const n = t.map(s => ({
            useScope: s(),
            scopeName: s.scopeName
        }));
        return function(i) {
            const o = n.reduce( (a, {useScope: l, scopeName: u}) => {
                const d = l(i)[`__scope${u}`];
                return {
                    ...a,
                    ...d
                }
            }
            , {});
            return b.useMemo( () => ({
                [`__scope${e.scopeName}`]: o
            }), [o])
        }
    }
    ;
    return r.scopeName = e.scopeName,
    r
}
function La(t) {
    const e = OT(t)
      , r = b.forwardRef( (n, s) => {
        const {children: i, ...o} = n
          , a = b.Children.toArray(i)
          , l = a.find(PT);
        if (l) {
            const u = l.props.children
              , c = a.map(d => d === l ? b.Children.count(u) > 1 ? b.Children.only(null) : b.isValidElement(u) ? u.props.children : null : d);
            return y.jsx(e, {
                ...o,
                ref: s,
                children: b.isValidElement(u) ? b.cloneElement(u, void 0, c) : null
            })
        }
        return y.jsx(e, {
            ...o,
            ref: s,
            children: i
        })
    }
    );
    return r.displayName = `${t}.Slot`,
    r
}
var I_ = La("Slot");
function OT(t) {
    const e = b.forwardRef( (r, n) => {
        const {children: s, ...i} = r;
        if (b.isValidElement(s)) {
            const o = AT(s)
              , a = RT(i, s.props);
            return s.type !== b.Fragment && (a.ref = n ? N_(n, o) : o),
            b.cloneElement(s, a)
        }
        return b.Children.count(s) > 1 ? b.Children.only(null) : null
    }
    );
    return e.displayName = `${t}.SlotClone`,
    e
}
var D_ = Symbol("radix.slottable");
function M_(t) {
    const e = ({children: r}) => y.jsx(y.Fragment, {
        children: r
    });
    return e.displayName = `${t}.Slottable`,
    e.__radixId = D_,
    e
}
function PT(t) {
    return b.isValidElement(t) && typeof t.type == "function" && "__radixId"in t.type && t.type.__radixId === D_
}
function RT(t, e) {
    const r = {
        ...e
    };
    for (const n in e) {
        const s = t[n]
          , i = e[n];
        /^on[A-Z]/.test(n) ? s && i ? r[n] = (...a) => {
            i(...a),
            s(...a)
        }
        : s && (r[n] = s) : n === "style" ? r[n] = {
            ...s,
            ...i
        } : n === "className" && (r[n] = [s, i].filter(Boolean).join(" "))
    }
    return {
        ...t,
        ...r
    }
}
function AT(t) {
    var n, s;
    let e = (n = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : n.get
      , r = e && "isReactWarning"in e && e.isReactWarning;
    return r ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get,
    r = e && "isReactWarning"in e && e.isReactWarning,
    r ? t.props.ref : t.props.ref || t.ref)
}
function jT(t) {
    const e = t + "CollectionProvider"
      , [r,n] = Co(e)
      , [s,i] = r(e, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , o = h => {
        const {scope: w, children: v} = h
          , m = le.useRef(null)
          , _ = le.useRef(new Map).current;
        return y.jsx(s, {
            scope: w,
            itemMap: _,
            collectionRef: m,
            children: v
        })
    }
    ;
    o.displayName = e;
    const a = t + "CollectionSlot"
      , l = La(a)
      , u = le.forwardRef( (h, w) => {
        const {scope: v, children: m} = h
          , _ = i(a, v)
          , x = st(w, _.collectionRef);
        return y.jsx(l, {
            ref: x,
            children: m
        })
    }
    );
    u.displayName = a;
    const c = t + "CollectionItemSlot"
      , d = "data-radix-collection-item"
      , f = La(c)
      , p = le.forwardRef( (h, w) => {
        const {scope: v, children: m, ..._} = h
          , x = le.useRef(null)
          , k = st(w, x)
          , T = i(c, v);
        return le.useEffect( () => (T.itemMap.set(x, {
            ref: x,
            ..._
        }),
        () => void T.itemMap.delete(x))),
        y.jsx(f, {
            [d]: "",
            ref: k,
            children: m
        })
    }
    );
    p.displayName = c;
    function g(h) {
        const w = i(t + "CollectionConsumer", h);
        return le.useCallback( () => {
            const m = w.collectionRef.current;
            if (!m)
                return [];
            const _ = Array.from(m.querySelectorAll(`[${d}]`));
            return Array.from(w.itemMap.values()).sort( (T, C) => _.indexOf(T.ref.current) - _.indexOf(C.ref.current))
        }
        , [w.collectionRef, w.itemMap])
    }
    return [{
        Provider: o,
        Slot: u,
        ItemSlot: p
    }, g, n]
}
var NT = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"]
  , Be = NT.reduce( (t, e) => {
    const r = La(`Primitive.${e}`)
      , n = b.forwardRef( (s, i) => {
        const {asChild: o, ...a} = s
          , l = o ? r : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        y.jsx(l, {
            ...a,
            ref: i
        })
    }
    );
    return n.displayName = `Primitive.${e}`,
    {
        ...t,
        [e]: n
    }
}
, {});
function L_(t, e) {
    t && fl.flushSync( () => t.dispatchEvent(e))
}
function rr(t) {
    const e = b.useRef(t);
    return b.useEffect( () => {
        e.current = t
    }
    ),
    b.useMemo( () => (...r) => {
        var n;
        return (n = e.current) == null ? void 0 : n.call(e, ...r)
    }
    , [])
}
function IT(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = rr(t);
    b.useEffect( () => {
        const n = s => {
            s.key === "Escape" && r(s)
        }
        ;
        return e.addEventListener("keydown", n, {
            capture: !0
        }),
        () => e.removeEventListener("keydown", n, {
            capture: !0
        })
    }
    , [r, e])
}
var DT = "DismissableLayer", _h = "dismissableLayer.update", MT = "dismissableLayer.pointerDownOutside", LT = "dismissableLayer.focusOutside", hv, $_ = b.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), Wc = b.forwardRef( (t, e) => {
    const {disableOutsidePointerEvents: r=!1, onEscapeKeyDown: n, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l} = t
      , u = b.useContext($_)
      , [c,d] = b.useState(null)
      , f = (c == null ? void 0 : c.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
      , [,p] = b.useState({})
      , g = st(e, C => d(C))
      , h = Array.from(u.layers)
      , [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1)
      , v = h.indexOf(w)
      , m = c ? h.indexOf(c) : -1
      , _ = u.layersWithOutsidePointerEventsDisabled.size > 0
      , x = m >= v
      , k = FT(C => {
        const P = C.target
          , j = [...u.branches].some($ => $.contains(P));
        !x || j || (s == null || s(C),
        o == null || o(C),
        C.defaultPrevented || a == null || a())
    }
    , f)
      , T = UT(C => {
        const P = C.target;
        [...u.branches].some($ => $.contains(P)) || (i == null || i(C),
        o == null || o(C),
        C.defaultPrevented || a == null || a())
    }
    , f);
    return IT(C => {
        m === u.layers.size - 1 && (n == null || n(C),
        !C.defaultPrevented && a && (C.preventDefault(),
        a()))
    }
    , f),
    b.useEffect( () => {
        if (c)
            return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (hv = f.body.style.pointerEvents,
            f.body.style.pointerEvents = "none"),
            u.layersWithOutsidePointerEventsDisabled.add(c)),
            u.layers.add(c),
            pv(),
            () => {
                r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = hv)
            }
    }
    , [c, f, r, u]),
    b.useEffect( () => () => {
        c && (u.layers.delete(c),
        u.layersWithOutsidePointerEventsDisabled.delete(c),
        pv())
    }
    , [c, u]),
    b.useEffect( () => {
        const C = () => p({});
        return document.addEventListener(_h, C),
        () => document.removeEventListener(_h, C)
    }
    , []),
    y.jsx(Be.div, {
        ...l,
        ref: g,
        style: {
            pointerEvents: _ ? x ? "auto" : "none" : void 0,
            ...t.style
        },
        onFocusCapture: Pe(t.onFocusCapture, T.onFocusCapture),
        onBlurCapture: Pe(t.onBlurCapture, T.onBlurCapture),
        onPointerDownCapture: Pe(t.onPointerDownCapture, k.onPointerDownCapture)
    })
}
);
Wc.displayName = DT;
var $T = "DismissableLayerBranch"
  , F_ = b.forwardRef( (t, e) => {
    const r = b.useContext($_)
      , n = b.useRef(null)
      , s = st(e, n);
    return b.useEffect( () => {
        const i = n.current;
        if (i)
            return r.branches.add(i),
            () => {
                r.branches.delete(i)
            }
    }
    , [r.branches]),
    y.jsx(Be.div, {
        ...t,
        ref: s
    })
}
);
F_.displayName = $T;
function FT(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = rr(t)
      , n = b.useRef(!1)
      , s = b.useRef( () => {}
    );
    return b.useEffect( () => {
        const i = a => {
            if (a.target && !n.current) {
                let l = function() {
                    U_(MT, r, u, {
                        discrete: !0
                    })
                };
                const u = {
                    originalEvent: a
                };
                a.pointerType === "touch" ? (e.removeEventListener("click", s.current),
                s.current = l,
                e.addEventListener("click", s.current, {
                    once: !0
                })) : l()
            } else
                e.removeEventListener("click", s.current);
            n.current = !1
        }
          , o = window.setTimeout( () => {
            e.addEventListener("pointerdown", i)
        }
        , 0);
        return () => {
            window.clearTimeout(o),
            e.removeEventListener("pointerdown", i),
            e.removeEventListener("click", s.current)
        }
    }
    , [e, r]),
    {
        onPointerDownCapture: () => n.current = !0
    }
}
function UT(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = rr(t)
      , n = b.useRef(!1);
    return b.useEffect( () => {
        const s = i => {
            i.target && !n.current && U_(LT, r, {
                originalEvent: i
            }, {
                discrete: !1
            })
        }
        ;
        return e.addEventListener("focusin", s),
        () => e.removeEventListener("focusin", s)
    }
    , [e, r]),
    {
        onFocusCapture: () => n.current = !0,
        onBlurCapture: () => n.current = !1
    }
}
function pv() {
    const t = new CustomEvent(_h);
    document.dispatchEvent(t)
}
function U_(t, e, r, {discrete: n}) {
    const s = r.originalEvent.target
      , i = new CustomEvent(t,{
        bubbles: !1,
        cancelable: !0,
        detail: r
    });
    e && s.addEventListener(t, e, {
        once: !0
    }),
    n ? L_(s, i) : s.dispatchEvent(i)
}
var VT = Wc
  , BT = F_
  , Qn = globalThis != null && globalThis.document ? b.useLayoutEffect : () => {}
  , zT = "Portal"
  , Zp = b.forwardRef( (t, e) => {
    var a;
    const {container: r, ...n} = t
      , [s,i] = b.useState(!1);
    Qn( () => i(!0), []);
    const o = r || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
    return o ? fC.createPortal(y.jsx(Be.div, {
        ...n,
        ref: e
    }), o) : null
}
);
Zp.displayName = zT;
function WT(t, e) {
    return b.useReducer( (r, n) => e[r][n] ?? r, t)
}
var To = t => {
    const {present: e, children: r} = t
      , n = HT(e)
      , s = typeof r == "function" ? r({
        present: n.isPresent
    }) : b.Children.only(r)
      , i = st(n.ref, qT(s));
    return typeof r == "function" || n.isPresent ? b.cloneElement(s, {
        ref: i
    }) : null
}
;
To.displayName = "Presence";
function HT(t) {
    const [e,r] = b.useState()
      , n = b.useRef({})
      , s = b.useRef(t)
      , i = b.useRef("none")
      , o = t ? "mounted" : "unmounted"
      , [a,l] = WT(o, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return b.useEffect( () => {
        const u = zl(n.current);
        i.current = a === "mounted" ? u : "none"
    }
    , [a]),
    Qn( () => {
        const u = n.current
          , c = s.current;
        if (c !== t) {
            const f = i.current
              , p = zl(u);
            t ? l("MOUNT") : p === "none" || (u == null ? void 0 : u.display) === "none" ? l("UNMOUNT") : l(c && f !== p ? "ANIMATION_OUT" : "UNMOUNT"),
            s.current = t
        }
    }
    , [t, l]),
    Qn( () => {
        if (e) {
            let u;
            const c = e.ownerDocument.defaultView ?? window
              , d = p => {
                const h = zl(n.current).includes(p.animationName);
                if (p.target === e && h && (l("ANIMATION_END"),
                !s.current)) {
                    const w = e.style.animationFillMode;
                    e.style.animationFillMode = "forwards",
                    u = c.setTimeout( () => {
                        e.style.animationFillMode === "forwards" && (e.style.animationFillMode = w)
                    }
                    )
                }
            }
              , f = p => {
                p.target === e && (i.current = zl(n.current))
            }
            ;
            return e.addEventListener("animationstart", f),
            e.addEventListener("animationcancel", d),
            e.addEventListener("animationend", d),
            () => {
                c.clearTimeout(u),
                e.removeEventListener("animationstart", f),
                e.removeEventListener("animationcancel", d),
                e.removeEventListener("animationend", d)
            }
        } else
            l("ANIMATION_END")
    }
    , [e, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: b.useCallback(u => {
            u && (n.current = getComputedStyle(u)),
            r(u)
        }
        , [])
    }
}
function zl(t) {
    return (t == null ? void 0 : t.animationName) || "none"
}
function qT(t) {
    var n, s;
    let e = (n = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : n.get
      , r = e && "isReactWarning"in e && e.isReactWarning;
    return r ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get,
    r = e && "isReactWarning"in e && e.isReactWarning,
    r ? t.props.ref : t.props.ref || t.ref)
}
function V_({prop: t, defaultProp: e, onChange: r= () => {}
}) {
    const [n,s] = KT({
        defaultProp: e,
        onChange: r
    })
      , i = t !== void 0
      , o = i ? t : n
      , a = rr(r)
      , l = b.useCallback(u => {
        if (i) {
            const d = typeof u == "function" ? u(t) : u;
            d !== t && a(d)
        } else
            s(u)
    }
    , [i, t, s, a]);
    return [o, l]
}
function KT({defaultProp: t, onChange: e}) {
    const r = b.useState(t)
      , [n] = r
      , s = b.useRef(n)
      , i = rr(e);
    return b.useEffect( () => {
        s.current !== n && (i(n),
        s.current = n)
    }
    , [n, s, i]),
    r
}
var GT = "VisuallyHidden"
  , Hc = b.forwardRef( (t, e) => y.jsx(Be.span, {
    ...t,
    ref: e,
    style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...t.style
    }
}));
Hc.displayName = GT;
var QT = Hc
  , Yp = "ToastProvider"
  , [Jp,ZT,YT] = jT("Toast")
  , [B_,UM] = Co("Toast", [YT])
  , [JT,qc] = B_(Yp)
  , z_ = t => {
    const {__scopeToast: e, label: r="Notification", duration: n=5e3, swipeDirection: s="right", swipeThreshold: i=50, children: o} = t
      , [a,l] = b.useState(null)
      , [u,c] = b.useState(0)
      , d = b.useRef(!1)
      , f = b.useRef(!1);
    return r.trim() || console.error(`Invalid prop \`label\` supplied to \`${Yp}\`. Expected non-empty \`string\`.`),
    y.jsx(Jp.Provider, {
        scope: e,
        children: y.jsx(JT, {
            scope: e,
            label: r,
            duration: n,
            swipeDirection: s,
            swipeThreshold: i,
            toastCount: u,
            viewport: a,
            onViewportChange: l,
            onToastAdd: b.useCallback( () => c(p => p + 1), []),
            onToastRemove: b.useCallback( () => c(p => p - 1), []),
            isFocusedToastEscapeKeyDownRef: d,
            isClosePausedRef: f,
            children: o
        })
    })
}
;
z_.displayName = Yp;
var W_ = "ToastViewport"
  , XT = ["F8"]
  , bh = "toast.viewportPause"
  , xh = "toast.viewportResume"
  , H_ = b.forwardRef( (t, e) => {
    const {__scopeToast: r, hotkey: n=XT, label: s="Notifications ({hotkey})", ...i} = t
      , o = qc(W_, r)
      , a = ZT(r)
      , l = b.useRef(null)
      , u = b.useRef(null)
      , c = b.useRef(null)
      , d = b.useRef(null)
      , f = st(e, d, o.onViewportChange)
      , p = n.join("+").replace(/Key/g, "").replace(/Digit/g, "")
      , g = o.toastCount > 0;
    b.useEffect( () => {
        const w = v => {
            var _;
            n.length !== 0 && n.every(x => v[x] || v.code === x) && ((_ = d.current) == null || _.focus())
        }
        ;
        return document.addEventListener("keydown", w),
        () => document.removeEventListener("keydown", w)
    }
    , [n]),
    b.useEffect( () => {
        const w = l.current
          , v = d.current;
        if (g && w && v) {
            const m = () => {
                if (!o.isClosePausedRef.current) {
                    const T = new CustomEvent(bh);
                    v.dispatchEvent(T),
                    o.isClosePausedRef.current = !0
                }
            }
              , _ = () => {
                if (o.isClosePausedRef.current) {
                    const T = new CustomEvent(xh);
                    v.dispatchEvent(T),
                    o.isClosePausedRef.current = !1
                }
            }
              , x = T => {
                !w.contains(T.relatedTarget) && _()
            }
              , k = () => {
                w.contains(document.activeElement) || _()
            }
            ;
            return w.addEventListener("focusin", m),
            w.addEventListener("focusout", x),
            w.addEventListener("pointermove", m),
            w.addEventListener("pointerleave", k),
            window.addEventListener("blur", m),
            window.addEventListener("focus", _),
            () => {
                w.removeEventListener("focusin", m),
                w.removeEventListener("focusout", x),
                w.removeEventListener("pointermove", m),
                w.removeEventListener("pointerleave", k),
                window.removeEventListener("blur", m),
                window.removeEventListener("focus", _)
            }
        }
    }
    , [g, o.isClosePausedRef]);
    const h = b.useCallback( ({tabbingDirection: w}) => {
        const m = a().map(_ => {
            const x = _.ref.current
              , k = [x, ...fO(x)];
            return w === "forwards" ? k : k.reverse()
        }
        );
        return (w === "forwards" ? m.reverse() : m).flat()
    }
    , [a]);
    return b.useEffect( () => {
        const w = d.current;
        if (w) {
            const v = m => {
                var k, T, C;
                const _ = m.altKey || m.ctrlKey || m.metaKey;
                if (m.key === "Tab" && !_) {
                    const P = document.activeElement
                      , j = m.shiftKey;
                    if (m.target === w && j) {
                        (k = u.current) == null || k.focus();
                        return
                    }
                    const D = h({
                        tabbingDirection: j ? "backwards" : "forwards"
                    })
                      , H = D.findIndex(M => M === P);
                    zd(D.slice(H + 1)) ? m.preventDefault() : j ? (T = u.current) == null || T.focus() : (C = c.current) == null || C.focus()
                }
            }
            ;
            return w.addEventListener("keydown", v),
            () => w.removeEventListener("keydown", v)
        }
    }
    , [a, h]),
    y.jsxs(BT, {
        ref: l,
        role: "region",
        "aria-label": s.replace("{hotkey}", p),
        tabIndex: -1,
        style: {
            pointerEvents: g ? void 0 : "none"
        },
        children: [g && y.jsx(Sh, {
            ref: u,
            onFocusFromOutsideViewport: () => {
                const w = h({
                    tabbingDirection: "forwards"
                });
                zd(w)
            }
        }), y.jsx(Jp.Slot, {
            scope: r,
            children: y.jsx(Be.ol, {
                tabIndex: -1,
                ...i,
                ref: f
            })
        }), g && y.jsx(Sh, {
            ref: c,
            onFocusFromOutsideViewport: () => {
                const w = h({
                    tabbingDirection: "backwards"
                });
                zd(w)
            }
        })]
    })
}
);
H_.displayName = W_;
var q_ = "ToastFocusProxy"
  , Sh = b.forwardRef( (t, e) => {
    const {__scopeToast: r, onFocusFromOutsideViewport: n, ...s} = t
      , i = qc(q_, r);
    return y.jsx(Hc, {
        "aria-hidden": !0,
        tabIndex: 0,
        ...s,
        ref: e,
        style: {
            position: "fixed"
        },
        onFocus: o => {
            var u;
            const a = o.relatedTarget;
            !((u = i.viewport) != null && u.contains(a)) && n()
        }
    })
}
);
Sh.displayName = q_;
var Kc = "Toast"
  , eO = "toast.swipeStart"
  , tO = "toast.swipeMove"
  , rO = "toast.swipeCancel"
  , nO = "toast.swipeEnd"
  , K_ = b.forwardRef( (t, e) => {
    const {forceMount: r, open: n, defaultOpen: s, onOpenChange: i, ...o} = t
      , [a=!0,l] = V_({
        prop: n,
        defaultProp: s,
        onChange: i
    });
    return y.jsx(To, {
        present: r || a,
        children: y.jsx(oO, {
            open: a,
            ...o,
            ref: e,
            onClose: () => l(!1),
            onPause: rr(t.onPause),
            onResume: rr(t.onResume),
            onSwipeStart: Pe(t.onSwipeStart, u => {
                u.currentTarget.setAttribute("data-swipe", "start")
            }
            ),
            onSwipeMove: Pe(t.onSwipeMove, u => {
                const {x: c, y: d} = u.detail.delta;
                u.currentTarget.setAttribute("data-swipe", "move"),
                u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${c}px`),
                u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`)
            }
            ),
            onSwipeCancel: Pe(t.onSwipeCancel, u => {
                u.currentTarget.setAttribute("data-swipe", "cancel"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
            }
            ),
            onSwipeEnd: Pe(t.onSwipeEnd, u => {
                const {x: c, y: d} = u.detail.delta;
                u.currentTarget.setAttribute("data-swipe", "end"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${c}px`),
                u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`),
                l(!1)
            }
            )
        })
    })
}
);
K_.displayName = Kc;
var [sO,iO] = B_(Kc, {
    onClose() {}
})
  , oO = b.forwardRef( (t, e) => {
    const {__scopeToast: r, type: n="foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: u, onSwipeStart: c, onSwipeMove: d, onSwipeCancel: f, onSwipeEnd: p, ...g} = t
      , h = qc(Kc, r)
      , [w,v] = b.useState(null)
      , m = st(e, M => v(M))
      , _ = b.useRef(null)
      , x = b.useRef(null)
      , k = s || h.duration
      , T = b.useRef(0)
      , C = b.useRef(k)
      , P = b.useRef(0)
      , {onToastAdd: j, onToastRemove: $} = h
      , X = rr( () => {
        var ie;
        (w == null ? void 0 : w.contains(document.activeElement)) && ((ie = h.viewport) == null || ie.focus()),
        o()
    }
    )
      , D = b.useCallback(M => {
        !M || M === 1 / 0 || (window.clearTimeout(P.current),
        T.current = new Date().getTime(),
        P.current = window.setTimeout(X, M))
    }
    , [X]);
    b.useEffect( () => {
        const M = h.viewport;
        if (M) {
            const ie = () => {
                D(C.current),
                u == null || u()
            }
              , te = () => {
                const oe = new Date().getTime() - T.current;
                C.current = C.current - oe,
                window.clearTimeout(P.current),
                l == null || l()
            }
            ;
            return M.addEventListener(bh, te),
            M.addEventListener(xh, ie),
            () => {
                M.removeEventListener(bh, te),
                M.removeEventListener(xh, ie)
            }
        }
    }
    , [h.viewport, k, l, u, D]),
    b.useEffect( () => {
        i && !h.isClosePausedRef.current && D(k)
    }
    , [i, k, h.isClosePausedRef, D]),
    b.useEffect( () => (j(),
    () => $()), [j, $]);
    const H = b.useMemo( () => w ? eb(w) : null, [w]);
    return h.viewport ? y.jsxs(y.Fragment, {
        children: [H && y.jsx(aO, {
            __scopeToast: r,
            role: "status",
            "aria-live": n === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: H
        }), y.jsx(sO, {
            scope: r,
            onClose: X,
            children: fl.createPortal(y.jsx(Jp.ItemSlot, {
                scope: r,
                children: y.jsx(VT, {
                    asChild: !0,
                    onEscapeKeyDown: Pe(a, () => {
                        h.isFocusedToastEscapeKeyDownRef.current || X(),
                        h.isFocusedToastEscapeKeyDownRef.current = !1
                    }
                    ),
                    children: y.jsx(Be.li, {
                        role: "status",
                        "aria-live": "off",
                        "aria-atomic": !0,
                        tabIndex: 0,
                        "data-state": i ? "open" : "closed",
                        "data-swipe-direction": h.swipeDirection,
                        ...g,
                        ref: m,
                        style: {
                            userSelect: "none",
                            touchAction: "none",
                            ...t.style
                        },
                        onKeyDown: Pe(t.onKeyDown, M => {
                            M.key === "Escape" && (a == null || a(M.nativeEvent),
                            M.nativeEvent.defaultPrevented || (h.isFocusedToastEscapeKeyDownRef.current = !0,
                            X()))
                        }
                        ),
                        onPointerDown: Pe(t.onPointerDown, M => {
                            M.button === 0 && (_.current = {
                                x: M.clientX,
                                y: M.clientY
                            })
                        }
                        ),
                        onPointerMove: Pe(t.onPointerMove, M => {
                            if (!_.current)
                                return;
                            const ie = M.clientX - _.current.x
                              , te = M.clientY - _.current.y
                              , oe = !!x.current
                              , A = ["left", "right"].includes(h.swipeDirection)
                              , V = ["left", "up"].includes(h.swipeDirection) ? Math.min : Math.max
                              , Y = A ? V(0, ie) : 0
                              , ae = A ? 0 : V(0, te)
                              , Ee = M.pointerType === "touch" ? 10 : 2
                              , xt = {
                                x: Y,
                                y: ae
                            }
                              , St = {
                                originalEvent: M,
                                delta: xt
                            };
                            oe ? (x.current = xt,
                            Wl(tO, d, St, {
                                discrete: !1
                            })) : mv(xt, h.swipeDirection, Ee) ? (x.current = xt,
                            Wl(eO, c, St, {
                                discrete: !1
                            }),
                            M.target.setPointerCapture(M.pointerId)) : (Math.abs(ie) > Ee || Math.abs(te) > Ee) && (_.current = null)
                        }
                        ),
                        onPointerUp: Pe(t.onPointerUp, M => {
                            const ie = x.current
                              , te = M.target;
                            if (te.hasPointerCapture(M.pointerId) && te.releasePointerCapture(M.pointerId),
                            x.current = null,
                            _.current = null,
                            ie) {
                                const oe = M.currentTarget
                                  , A = {
                                    originalEvent: M,
                                    delta: ie
                                };
                                mv(ie, h.swipeDirection, h.swipeThreshold) ? Wl(nO, p, A, {
                                    discrete: !0
                                }) : Wl(rO, f, A, {
                                    discrete: !0
                                }),
                                oe.addEventListener("click", V => V.preventDefault(), {
                                    once: !0
                                })
                            }
                        }
                        )
                    })
                })
            }), h.viewport)
        })]
    }) : null
}
)
  , aO = t => {
    const {__scopeToast: e, children: r, ...n} = t
      , s = qc(Kc, e)
      , [i,o] = b.useState(!1)
      , [a,l] = b.useState(!1);
    return cO( () => o(!0)),
    b.useEffect( () => {
        const u = window.setTimeout( () => l(!0), 1e3);
        return () => window.clearTimeout(u)
    }
    , []),
    a ? null : y.jsx(Zp, {
        asChild: !0,
        children: y.jsx(Hc, {
            ...n,
            children: i && y.jsxs(y.Fragment, {
                children: [s.label, " ", r]
            })
        })
    })
}
  , lO = "ToastTitle"
  , G_ = b.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t;
    return y.jsx(Be.div, {
        ...n,
        ref: e
    })
}
);
G_.displayName = lO;
var uO = "ToastDescription"
  , Q_ = b.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t;
    return y.jsx(Be.div, {
        ...n,
        ref: e
    })
}
);
Q_.displayName = uO;
var Z_ = "ToastAction"
  , Y_ = b.forwardRef( (t, e) => {
    const {altText: r, ...n} = t;
    return r.trim() ? y.jsx(X_, {
        altText: r,
        asChild: !0,
        children: y.jsx(Xp, {
            ...n,
            ref: e
        })
    }) : (console.error(`Invalid prop \`altText\` supplied to \`${Z_}\`. Expected non-empty \`string\`.`),
    null)
}
);
Y_.displayName = Z_;
var J_ = "ToastClose"
  , Xp = b.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t
      , s = iO(J_, r);
    return y.jsx(X_, {
        asChild: !0,
        children: y.jsx(Be.button, {
            type: "button",
            ...n,
            ref: e,
            onClick: Pe(t.onClick, s.onClose)
        })
    })
}
);
Xp.displayName = J_;
var X_ = b.forwardRef( (t, e) => {
    const {__scopeToast: r, altText: n, ...s} = t;
    return y.jsx(Be.div, {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": n || void 0,
        ...s,
        ref: e
    })
}
);
function eb(t) {
    const e = [];
    return Array.from(t.childNodes).forEach(n => {
        if (n.nodeType === n.TEXT_NODE && n.textContent && e.push(n.textContent),
        dO(n)) {
            const s = n.ariaHidden || n.hidden || n.style.display === "none"
              , i = n.dataset.radixToastAnnounceExclude === "";
            if (!s)
                if (i) {
                    const o = n.dataset.radixToastAnnounceAlt;
                    o && e.push(o)
                } else
                    e.push(...eb(n))
        }
    }
    ),
    e
}
function Wl(t, e, r, {discrete: n}) {
    const s = r.originalEvent.currentTarget
      , i = new CustomEvent(t,{
        bubbles: !0,
        cancelable: !0,
        detail: r
    });
    e && s.addEventListener(t, e, {
        once: !0
    }),
    n ? L_(s, i) : s.dispatchEvent(i)
}
var mv = (t, e, r=0) => {
    const n = Math.abs(t.x)
      , s = Math.abs(t.y)
      , i = n > s;
    return e === "left" || e === "right" ? i && n > r : !i && s > r
}
;
function cO(t= () => {}
) {
    const e = rr(t);
    Qn( () => {
        let r = 0
          , n = 0;
        return r = window.requestAnimationFrame( () => n = window.requestAnimationFrame(e)),
        () => {
            window.cancelAnimationFrame(r),
            window.cancelAnimationFrame(n)
        }
    }
    , [e])
}
function dO(t) {
    return t.nodeType === t.ELEMENT_NODE
}
function fO(t) {
    const e = []
      , r = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: n => {
            const s = n.tagName === "INPUT" && n.type === "hidden";
            return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; r.nextNode(); )
        e.push(r.currentNode);
    return e
}
function zd(t) {
    const e = document.activeElement;
    return t.some(r => r === e ? !0 : (r.focus(),
    document.activeElement !== e))
}
var hO = z_
  , tb = H_
  , rb = K_
  , nb = G_
  , sb = Q_
  , ib = Y_
  , ob = Xp;
function ab(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number")
        n += t;
    else if (typeof t == "object")
        if (Array.isArray(t)) {
            var s = t.length;
            for (e = 0; e < s; e++)
                t[e] && (r = ab(t[e])) && (n && (n += " "),
                n += r)
        } else
            for (r in t)
                t[r] && (n && (n += " "),
                n += r);
    return n
}
function lb() {
    for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++)
        (t = arguments[r]) && (e = ab(t)) && (n && (n += " "),
        n += e);
    return n
}
const gv = t => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t
  , vv = lb
  , Gc = (t, e) => r => {
    var n;
    if ((e == null ? void 0 : e.variants) == null)
        return vv(t, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
    const {variants: s, defaultVariants: i} = e
      , o = Object.keys(s).map(u => {
        const c = r == null ? void 0 : r[u]
          , d = i == null ? void 0 : i[u];
        if (c === null)
            return null;
        const f = gv(c) || gv(d);
        return s[u][f]
    }
    )
      , a = r && Object.entries(r).reduce( (u, c) => {
        let[d,f] = c;
        return f === void 0 || (u[d] = f),
        u
    }
    , {})
      , l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce( (u, c) => {
        let {class: d, className: f, ...p} = c;
        return Object.entries(p).every(g => {
            let[h,w] = g;
            return Array.isArray(w) ? w.includes({
                ...i,
                ...a
            }[h]) : {
                ...i,
                ...a
            }[h] === w
        }
        ) ? [...u, d, f] : u
    }
    , []);
    return vv(t, o, l, r == null ? void 0 : r.class, r == null ? void 0 : r.className)
}
;
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pO = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , ub = (...t) => t.filter( (e, r, n) => !!e && n.indexOf(e) === r).join(" ");
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var mO = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gO = b.forwardRef( ({color: t="currentColor", size: e=24, strokeWidth: r=2, absoluteStrokeWidth: n, className: s="", children: i, iconNode: o, ...a}, l) => b.createElement("svg", {
    ref: l,
    ...mO,
    width: e,
    height: e,
    stroke: t,
    strokeWidth: n ? Number(r) * 24 / Number(e) : r,
    className: ub("lucide", s),
    ...a
}, [...o.map( ([u,c]) => b.createElement(u, c)), ...Array.isArray(i) ? i : [i]]));
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const At = (t, e) => {
    const r = b.forwardRef( ({className: n, ...s}, i) => b.createElement(gO, {
        ref: i,
        iconNode: e,
        className: ub(`lucide-${pO(t)}`, n),
        ...s
    }));
    return r.displayName = `${t}`,
    r
}
;
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cb = At("ArrowLeft", [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vO = At("Calendar", [["path", {
    d: "M8 2v4",
    key: "1cmpym"
}], ["path", {
    d: "M16 2v4",
    key: "4m81vk"
}], ["rect", {
    width: "18",
    height: "18",
    x: "3",
    y: "4",
    rx: "2",
    key: "1hopcy"
}], ["path", {
    d: "M3 10h18",
    key: "8toen8"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yO = At("CircleAlert", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "8",
    y2: "12",
    key: "1pkeuh"
}], ["line", {
    x1: "12",
    x2: "12.01",
    y1: "16",
    y2: "16",
    key: "4dfq90"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const db = At("Droplets", [["path", {
    d: "M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z",
    key: "1ptgy4"
}], ["path", {
    d: "M12.56 6.6A10.97 10.97 0 0 0 14 3.02c.5 2.5 2 4.9 4 6.5s3 3.5 3 5.5a6.98 6.98 0 0 1-11.91 4.97",
    key: "1sl1rz"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wO = At("House", [["path", {
    d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",
    key: "5wwlr5"
}], ["path", {
    d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",
    key: "1d0kgt"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fb = At("Leaf", [["path", {
    d: "M11 20A7 7 0 0 1 9.8 6.1C15.5 5 17 4.48 19 2c1 2 2 4.18 2 8 0 5.5-4.78 10-10 10Z",
    key: "nnexq3"
}], ["path", {
    d: "M2 21c0-3 1.85-5.36 5.08-6C9.5 14.52 12 13 13 12",
    key: "mt58a7"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _O = At("LogOut", [["path", {
    d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
    key: "1uf3rs"
}], ["polyline", {
    points: "16 17 21 12 16 7",
    key: "1gabdz"
}], ["line", {
    x1: "21",
    x2: "9",
    y1: "12",
    y2: "12",
    key: "1uyos4"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hb = At("MapPin", [["path", {
    d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
    key: "1r0f0z"
}], ["circle", {
    cx: "12",
    cy: "10",
    r: "3",
    key: "ilqhr7"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bO = At("Plus", [["path", {
    d: "M5 12h14",
    key: "1ays0h"
}], ["path", {
    d: "M12 5v14",
    key: "s699le"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xO = At("Sprout", [["path", {
    d: "M7 20h10",
    key: "e6iznv"
}], ["path", {
    d: "M10 20c5.5-2.5.8-6.4 3-10",
    key: "161w41"
}], ["path", {
    d: "M9.5 9.4c1.1.8 1.8 2.2 2.3 3.7-2 .4-3.5.4-4.8-.3-1.2-.6-2.3-1.9-3-4.2 2.8-.5 4.4 0 5.5.8z",
    key: "9gtqwd"
}], ["path", {
    d: "M14.1 6a7 7 0 0 0-1.1 4c1.9-.1 3.3-.6 4.3-1.4 1-1 1.6-2.3 1.7-4.6-2.7.1-4 1-4.9 2z",
    key: "bkxnd2"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SO = At("Trash2", [["path", {
    d: "M3 6h18",
    key: "d0wm0j"
}], ["path", {
    d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
    key: "4alrt4"
}], ["path", {
    d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
    key: "v07s0e"
}], ["line", {
    x1: "10",
    x2: "10",
    y1: "11",
    y2: "17",
    key: "1uufr5"
}], ["line", {
    x1: "14",
    x2: "14",
    y1: "11",
    y2: "17",
    key: "xtxkd"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EO = At("Upload", [["path", {
    d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
    key: "ih7n3h"
}], ["polyline", {
    points: "17 8 12 3 7 8",
    key: "t8dd8p"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "3",
    y2: "15",
    key: "widbto"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pb = At("User", [["path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
    key: "975kel"
}], ["circle", {
    cx: "12",
    cy: "7",
    r: "4",
    key: "17ys0d"
}]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mb = At("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]])
  , em = "-"
  , kO = t => {
    const e = TO(t)
      , {conflictingClassGroups: r, conflictingClassGroupModifiers: n} = t;
    return {
        getClassGroupId: o => {
            const a = o.split(em);
            return a[0] === "" && a.length !== 1 && a.shift(),
            gb(a, e) || CO(o)
        }
        ,
        getConflictingClassGroupIds: (o, a) => {
            const l = r[o] || [];
            return a && n[o] ? [...l, ...n[o]] : l
        }
    }
}
  , gb = (t, e) => {
    var o;
    if (t.length === 0)
        return e.classGroupId;
    const r = t[0]
      , n = e.nextPart.get(r)
      , s = n ? gb(t.slice(1), n) : void 0;
    if (s)
        return s;
    if (e.validators.length === 0)
        return;
    const i = t.join(em);
    return (o = e.validators.find( ({validator: a}) => a(i))) == null ? void 0 : o.classGroupId
}
  , yv = /^\[(.+)\]$/
  , CO = t => {
    if (yv.test(t)) {
        const e = yv.exec(t)[1]
          , r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
        if (r)
            return "arbitrary.." + r
    }
}
  , TO = t => {
    const {theme: e, prefix: r} = t
      , n = {
        nextPart: new Map,
        validators: []
    };
    return PO(Object.entries(t.classGroups), r).forEach( ([i,o]) => {
        Eh(o, n, i, e)
    }
    ),
    n
}
  , Eh = (t, e, r, n) => {
    t.forEach(s => {
        if (typeof s == "string") {
            const i = s === "" ? e : wv(e, s);
            i.classGroupId = r;
            return
        }
        if (typeof s == "function") {
            if (OO(s)) {
                Eh(s(n), e, r, n);
                return
            }
            e.validators.push({
                validator: s,
                classGroupId: r
            });
            return
        }
        Object.entries(s).forEach( ([i,o]) => {
            Eh(o, wv(e, i), r, n)
        }
        )
    }
    )
}
  , wv = (t, e) => {
    let r = t;
    return e.split(em).forEach(n => {
        r.nextPart.has(n) || r.nextPart.set(n, {
            nextPart: new Map,
            validators: []
        }),
        r = r.nextPart.get(n)
    }
    ),
    r
}
  , OO = t => t.isThemeGetter
  , PO = (t, e) => e ? t.map( ([r,n]) => {
    const s = n.map(i => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map( ([o,a]) => [e + o, a])) : i);
    return [r, s]
}
) : t
  , RO = t => {
    if (t < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , r = new Map
      , n = new Map;
    const s = (i, o) => {
        r.set(i, o),
        e++,
        e > t && (e = 0,
        n = r,
        r = new Map)
    }
    ;
    return {
        get(i) {
            let o = r.get(i);
            if (o !== void 0)
                return o;
            if ((o = n.get(i)) !== void 0)
                return s(i, o),
                o
        },
        set(i, o) {
            r.has(i) ? r.set(i, o) : s(i, o)
        }
    }
}
  , vb = "!"
  , AO = t => {
    const {separator: e, experimentalParseClassName: r} = t
      , n = e.length === 1
      , s = e[0]
      , i = e.length
      , o = a => {
        const l = [];
        let u = 0, c = 0, d;
        for (let w = 0; w < a.length; w++) {
            let v = a[w];
            if (u === 0) {
                if (v === s && (n || a.slice(w, w + i) === e)) {
                    l.push(a.slice(c, w)),
                    c = w + i;
                    continue
                }
                if (v === "/") {
                    d = w;
                    continue
                }
            }
            v === "[" ? u++ : v === "]" && u--
        }
        const f = l.length === 0 ? a : a.substring(c)
          , p = f.startsWith(vb)
          , g = p ? f.substring(1) : f
          , h = d && d > c ? d - c : void 0;
        return {
            modifiers: l,
            hasImportantModifier: p,
            baseClassName: g,
            maybePostfixModifierPosition: h
        }
    }
    ;
    return r ? a => r({
        className: a,
        parseClassName: o
    }) : o
}
  , jO = t => {
    if (t.length <= 1)
        return t;
    const e = [];
    let r = [];
    return t.forEach(n => {
        n[0] === "[" ? (e.push(...r.sort(), n),
        r = []) : r.push(n)
    }
    ),
    e.push(...r.sort()),
    e
}
  , NO = t => ({
    cache: RO(t.cacheSize),
    parseClassName: AO(t),
    ...kO(t)
})
  , IO = /\s+/
  , DO = (t, e) => {
    const {parseClassName: r, getClassGroupId: n, getConflictingClassGroupIds: s} = e
      , i = []
      , o = t.trim().split(IO);
    let a = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
        const u = o[l]
          , {modifiers: c, hasImportantModifier: d, baseClassName: f, maybePostfixModifierPosition: p} = r(u);
        let g = !!p
          , h = n(g ? f.substring(0, p) : f);
        if (!h) {
            if (!g) {
                a = u + (a.length > 0 ? " " + a : a);
                continue
            }
            if (h = n(f),
            !h) {
                a = u + (a.length > 0 ? " " + a : a);
                continue
            }
            g = !1
        }
        const w = jO(c).join(":")
          , v = d ? w + vb : w
          , m = v + h;
        if (i.includes(m))
            continue;
        i.push(m);
        const _ = s(h, g);
        for (let x = 0; x < _.length; ++x) {
            const k = _[x];
            i.push(v + k)
        }
        a = u + (a.length > 0 ? " " + a : a)
    }
    return a
}
;
function MO() {
    let t = 0, e, r, n = "";
    for (; t < arguments.length; )
        (e = arguments[t++]) && (r = yb(e)) && (n && (n += " "),
        n += r);
    return n
}
const yb = t => {
    if (typeof t == "string")
        return t;
    let e, r = "";
    for (let n = 0; n < t.length; n++)
        t[n] && (e = yb(t[n])) && (r && (r += " "),
        r += e);
    return r
}
;
function LO(t, ...e) {
    let r, n, s, i = o;
    function o(l) {
        const u = e.reduce( (c, d) => d(c), t());
        return r = NO(u),
        n = r.cache.get,
        s = r.cache.set,
        i = a,
        a(l)
    }
    function a(l) {
        const u = n(l);
        if (u)
            return u;
        const c = DO(l, r);
        return s(l, c),
        c
    }
    return function() {
        return i(MO.apply(null, arguments))
    }
}
const Te = t => {
    const e = r => r[t] || [];
    return e.isThemeGetter = !0,
    e
}
  , wb = /^\[(?:([a-z-]+):)?(.+)\]$/i
  , $O = /^\d+\/\d+$/
  , FO = new Set(["px", "full", "screen"])
  , UO = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , VO = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , BO = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , zO = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , WO = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , zr = t => Ui(t) || FO.has(t) || $O.test(t)
  , gn = t => Oo(t, "length", JO)
  , Ui = t => !!t && !Number.isNaN(Number(t))
  , Wd = t => Oo(t, "number", Ui)
  , Wo = t => !!t && Number.isInteger(Number(t))
  , HO = t => t.endsWith("%") && Ui(t.slice(0, -1))
  , ce = t => wb.test(t)
  , vn = t => UO.test(t)
  , qO = new Set(["length", "size", "percentage"])
  , KO = t => Oo(t, qO, _b)
  , GO = t => Oo(t, "position", _b)
  , QO = new Set(["image", "url"])
  , ZO = t => Oo(t, QO, eP)
  , YO = t => Oo(t, "", XO)
  , Ho = () => !0
  , Oo = (t, e, r) => {
    const n = wb.exec(t);
    return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1
}
  , JO = t => VO.test(t) && !BO.test(t)
  , _b = () => !1
  , XO = t => zO.test(t)
  , eP = t => WO.test(t)
  , tP = () => {
    const t = Te("colors")
      , e = Te("spacing")
      , r = Te("blur")
      , n = Te("brightness")
      , s = Te("borderColor")
      , i = Te("borderRadius")
      , o = Te("borderSpacing")
      , a = Te("borderWidth")
      , l = Te("contrast")
      , u = Te("grayscale")
      , c = Te("hueRotate")
      , d = Te("invert")
      , f = Te("gap")
      , p = Te("gradientColorStops")
      , g = Te("gradientColorStopPositions")
      , h = Te("inset")
      , w = Te("margin")
      , v = Te("opacity")
      , m = Te("padding")
      , _ = Te("saturate")
      , x = Te("scale")
      , k = Te("sepia")
      , T = Te("skew")
      , C = Te("space")
      , P = Te("translate")
      , j = () => ["auto", "contain", "none"]
      , $ = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , X = () => ["auto", ce, e]
      , D = () => [ce, e]
      , H = () => ["", zr, gn]
      , M = () => ["auto", Ui, ce]
      , ie = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
      , te = () => ["solid", "dashed", "dotted", "double", "none"]
      , oe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , A = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
      , V = () => ["", "0", ce]
      , Y = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , ae = () => [Ui, ce];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [Ho],
            spacing: [zr, gn],
            blur: ["none", "", vn, ce],
            brightness: ae(),
            borderColor: [t],
            borderRadius: ["none", "", "full", vn, ce],
            borderSpacing: D(),
            borderWidth: H(),
            contrast: ae(),
            grayscale: V(),
            hueRotate: ae(),
            invert: V(),
            gap: D(),
            gradientColorStops: [t],
            gradientColorStopPositions: [HO, gn],
            inset: X(),
            margin: X(),
            opacity: ae(),
            padding: D(),
            saturate: ae(),
            scale: ae(),
            sepia: V(),
            skew: ae(),
            space: D(),
            translate: D()
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", ce]
            }],
            container: ["container"],
            columns: [{
                columns: [vn]
            }],
            "break-after": [{
                "break-after": Y()
            }],
            "break-before": [{
                "break-before": Y()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [...ie(), ce]
            }],
            overflow: [{
                overflow: $()
            }],
            "overflow-x": [{
                "overflow-x": $()
            }],
            "overflow-y": [{
                "overflow-y": $()
            }],
            overscroll: [{
                overscroll: j()
            }],
            "overscroll-x": [{
                "overscroll-x": j()
            }],
            "overscroll-y": [{
                "overscroll-y": j()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [h]
            }],
            "inset-x": [{
                "inset-x": [h]
            }],
            "inset-y": [{
                "inset-y": [h]
            }],
            start: [{
                start: [h]
            }],
            end: [{
                end: [h]
            }],
            top: [{
                top: [h]
            }],
            right: [{
                right: [h]
            }],
            bottom: [{
                bottom: [h]
            }],
            left: [{
                left: [h]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: ["auto", Wo, ce]
            }],
            basis: [{
                basis: X()
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", ce]
            }],
            grow: [{
                grow: V()
            }],
            shrink: [{
                shrink: V()
            }],
            order: [{
                order: ["first", "last", "none", Wo, ce]
            }],
            "grid-cols": [{
                "grid-cols": [Ho]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: ["full", Wo, ce]
                }, ce]
            }],
            "col-start": [{
                "col-start": M()
            }],
            "col-end": [{
                "col-end": M()
            }],
            "grid-rows": [{
                "grid-rows": [Ho]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [Wo, ce]
                }, ce]
            }],
            "row-start": [{
                "row-start": M()
            }],
            "row-end": [{
                "row-end": M()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", ce]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", ce]
            }],
            gap: [{
                gap: [f]
            }],
            "gap-x": [{
                "gap-x": [f]
            }],
            "gap-y": [{
                "gap-y": [f]
            }],
            "justify-content": [{
                justify: ["normal", ...A()]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: ["normal", ...A(), "baseline"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [...A(), "baseline"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [m]
            }],
            px: [{
                px: [m]
            }],
            py: [{
                py: [m]
            }],
            ps: [{
                ps: [m]
            }],
            pe: [{
                pe: [m]
            }],
            pt: [{
                pt: [m]
            }],
            pr: [{
                pr: [m]
            }],
            pb: [{
                pb: [m]
            }],
            pl: [{
                pl: [m]
            }],
            m: [{
                m: [w]
            }],
            mx: [{
                mx: [w]
            }],
            my: [{
                my: [w]
            }],
            ms: [{
                ms: [w]
            }],
            me: [{
                me: [w]
            }],
            mt: [{
                mt: [w]
            }],
            mr: [{
                mr: [w]
            }],
            mb: [{
                mb: [w]
            }],
            ml: [{
                ml: [w]
            }],
            "space-x": [{
                "space-x": [C]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [C]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ce, e]
            }],
            "min-w": [{
                "min-w": [ce, e, "min", "max", "fit"]
            }],
            "max-w": [{
                "max-w": [ce, e, "none", "full", "min", "max", "fit", "prose", {
                    screen: [vn]
                }, vn]
            }],
            h: [{
                h: [ce, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "min-h": [{
                "min-h": [ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "max-h": [{
                "max-h": [ce, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            size: [{
                size: [ce, e, "auto", "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", vn, gn]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Wd]
            }],
            "font-family": [{
                font: [Ho]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ce]
            }],
            "line-clamp": [{
                "line-clamp": ["none", Ui, Wd]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", zr, ce]
            }],
            "list-image": [{
                "list-image": ["none", ce]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", ce]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [t]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [v]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [t]
            }],
            "text-opacity": [{
                "text-opacity": [v]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...te(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", zr, gn]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", zr, ce]
            }],
            "text-decoration-color": [{
                decoration: [t]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: D()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ce]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", ce]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [v]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [...ie(), GO]
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", KO]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, ZO]
            }],
            "bg-color": [{
                bg: [t]
            }],
            "gradient-from-pos": [{
                from: [g]
            }],
            "gradient-via-pos": [{
                via: [g]
            }],
            "gradient-to-pos": [{
                to: [g]
            }],
            "gradient-from": [{
                from: [p]
            }],
            "gradient-via": [{
                via: [p]
            }],
            "gradient-to": [{
                to: [p]
            }],
            rounded: [{
                rounded: [i]
            }],
            "rounded-s": [{
                "rounded-s": [i]
            }],
            "rounded-e": [{
                "rounded-e": [i]
            }],
            "rounded-t": [{
                "rounded-t": [i]
            }],
            "rounded-r": [{
                "rounded-r": [i]
            }],
            "rounded-b": [{
                "rounded-b": [i]
            }],
            "rounded-l": [{
                "rounded-l": [i]
            }],
            "rounded-ss": [{
                "rounded-ss": [i]
            }],
            "rounded-se": [{
                "rounded-se": [i]
            }],
            "rounded-ee": [{
                "rounded-ee": [i]
            }],
            "rounded-es": [{
                "rounded-es": [i]
            }],
            "rounded-tl": [{
                "rounded-tl": [i]
            }],
            "rounded-tr": [{
                "rounded-tr": [i]
            }],
            "rounded-br": [{
                "rounded-br": [i]
            }],
            "rounded-bl": [{
                "rounded-bl": [i]
            }],
            "border-w": [{
                border: [a]
            }],
            "border-w-x": [{
                "border-x": [a]
            }],
            "border-w-y": [{
                "border-y": [a]
            }],
            "border-w-s": [{
                "border-s": [a]
            }],
            "border-w-e": [{
                "border-e": [a]
            }],
            "border-w-t": [{
                "border-t": [a]
            }],
            "border-w-r": [{
                "border-r": [a]
            }],
            "border-w-b": [{
                "border-b": [a]
            }],
            "border-w-l": [{
                "border-l": [a]
            }],
            "border-opacity": [{
                "border-opacity": [v]
            }],
            "border-style": [{
                border: [...te(), "hidden"]
            }],
            "divide-x": [{
                "divide-x": [a]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [a]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [v]
            }],
            "divide-style": [{
                divide: te()
            }],
            "border-color": [{
                border: [s]
            }],
            "border-color-x": [{
                "border-x": [s]
            }],
            "border-color-y": [{
                "border-y": [s]
            }],
            "border-color-s": [{
                "border-s": [s]
            }],
            "border-color-e": [{
                "border-e": [s]
            }],
            "border-color-t": [{
                "border-t": [s]
            }],
            "border-color-r": [{
                "border-r": [s]
            }],
            "border-color-b": [{
                "border-b": [s]
            }],
            "border-color-l": [{
                "border-l": [s]
            }],
            "divide-color": [{
                divide: [s]
            }],
            "outline-style": [{
                outline: ["", ...te()]
            }],
            "outline-offset": [{
                "outline-offset": [zr, ce]
            }],
            "outline-w": [{
                outline: [zr, gn]
            }],
            "outline-color": [{
                outline: [t]
            }],
            "ring-w": [{
                ring: H()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [t]
            }],
            "ring-opacity": [{
                "ring-opacity": [v]
            }],
            "ring-offset-w": [{
                "ring-offset": [zr, gn]
            }],
            "ring-offset-color": [{
                "ring-offset": [t]
            }],
            shadow: [{
                shadow: ["", "inner", "none", vn, YO]
            }],
            "shadow-color": [{
                shadow: [Ho]
            }],
            opacity: [{
                opacity: [v]
            }],
            "mix-blend": [{
                "mix-blend": [...oe(), "plus-lighter", "plus-darker"]
            }],
            "bg-blend": [{
                "bg-blend": oe()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [r]
            }],
            brightness: [{
                brightness: [n]
            }],
            contrast: [{
                contrast: [l]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", vn, ce]
            }],
            grayscale: [{
                grayscale: [u]
            }],
            "hue-rotate": [{
                "hue-rotate": [c]
            }],
            invert: [{
                invert: [d]
            }],
            saturate: [{
                saturate: [_]
            }],
            sepia: [{
                sepia: [k]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [r]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [n]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [l]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [u]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [c]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [d]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [v]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [_]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [k]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [o]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [o]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [o]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ce]
            }],
            duration: [{
                duration: ae()
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", ce]
            }],
            delay: [{
                delay: ae()
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", ce]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [x]
            }],
            "scale-x": [{
                "scale-x": [x]
            }],
            "scale-y": [{
                "scale-y": [x]
            }],
            rotate: [{
                rotate: [Wo, ce]
            }],
            "translate-x": [{
                "translate-x": [P]
            }],
            "translate-y": [{
                "translate-y": [P]
            }],
            "skew-x": [{
                "skew-x": [T]
            }],
            "skew-y": [{
                "skew-y": [T]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ce]
            }],
            accent: [{
                accent: ["auto", t]
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ce]
            }],
            "caret-color": [{
                caret: [t]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": D()
            }],
            "scroll-mx": [{
                "scroll-mx": D()
            }],
            "scroll-my": [{
                "scroll-my": D()
            }],
            "scroll-ms": [{
                "scroll-ms": D()
            }],
            "scroll-me": [{
                "scroll-me": D()
            }],
            "scroll-mt": [{
                "scroll-mt": D()
            }],
            "scroll-mr": [{
                "scroll-mr": D()
            }],
            "scroll-mb": [{
                "scroll-mb": D()
            }],
            "scroll-ml": [{
                "scroll-ml": D()
            }],
            "scroll-p": [{
                "scroll-p": D()
            }],
            "scroll-px": [{
                "scroll-px": D()
            }],
            "scroll-py": [{
                "scroll-py": D()
            }],
            "scroll-ps": [{
                "scroll-ps": D()
            }],
            "scroll-pe": [{
                "scroll-pe": D()
            }],
            "scroll-pt": [{
                "scroll-pt": D()
            }],
            "scroll-pr": [{
                "scroll-pr": D()
            }],
            "scroll-pb": [{
                "scroll-pb": D()
            }],
            "scroll-pl": [{
                "scroll-pl": D()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", ce]
            }],
            fill: [{
                fill: [t, "none"]
            }],
            "stroke-w": [{
                stroke: [zr, gn, Wd]
            }],
            stroke: [{
                stroke: [t, "none"]
            }],
            sr: ["sr-only", "not-sr-only"],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        }
    }
}
  , rP = LO(tP);
function ye(...t) {
    return rP(lb(t))
}
const nP = hO
  , bb = b.forwardRef( ({className: t, ...e}, r) => y.jsx(tb, {
    ref: r,
    className: ye("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", t),
    ...e
}));
bb.displayName = tb.displayName;
const sP = Gc("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
        variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
  , xb = b.forwardRef( ({className: t, variant: e, ...r}, n) => y.jsx(rb, {
    ref: n,
    className: ye(sP({
        variant: e
    }), t),
    ...r
}));
xb.displayName = rb.displayName;
const iP = b.forwardRef( ({className: t, ...e}, r) => y.jsx(ib, {
    ref: r,
    className: ye("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", t),
    ...e
}));
iP.displayName = ib.displayName;
const Sb = b.forwardRef( ({className: t, ...e}, r) => y.jsx(ob, {
    ref: r,
    className: ye("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", t),
    "toast-close": "",
    ...e,
    children: y.jsx(mb, {
        className: "h-4 w-4"
    })
}));
Sb.displayName = ob.displayName;
const Eb = b.forwardRef( ({className: t, ...e}, r) => y.jsx(nb, {
    ref: r,
    className: ye("text-sm font-semibold", t),
    ...e
}));
Eb.displayName = nb.displayName;
const kb = b.forwardRef( ({className: t, ...e}, r) => y.jsx(sb, {
    ref: r,
    className: ye("text-sm opacity-90", t),
    ...e
}));
kb.displayName = sb.displayName;
function oP() {
    const {toasts: t} = ko();
    return y.jsxs(nP, {
        children: [t.map(function({id: e, title: r, description: n, action: s, ...i}) {
            return y.jsxs(xb, {
                ...i,
                children: [y.jsxs("div", {
                    className: "grid gap-1",
                    children: [r && y.jsx(Eb, {
                        children: r
                    }), n && y.jsx(kb, {
                        children: n
                    })]
                }), s, y.jsx(Sb, {})]
            }, e)
        }), y.jsx(bb, {})]
    })
}
var aP = rw[" useId ".trim().toString()] || ( () => {}
)
  , lP = 0;
function Hd(t) {
    const [e,r] = b.useState(aP());
    return Qn( () => {
        t || r(n => n ?? String(lP++))
    }
    , [t]),
    t || (e ? `radix-${e}` : "")
}
const uP = ["top", "right", "bottom", "left"]
  , Zn = Math.min
  , Mt = Math.max
  , tc = Math.round
  , Hl = Math.floor
  , Lr = t => ({
    x: t,
    y: t
})
  , cP = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , dP = {
    start: "end",
    end: "start"
};
function kh(t, e, r) {
    return Mt(t, Zn(e, r))
}
function ln(t, e) {
    return typeof t == "function" ? t(e) : t
}
function un(t) {
    return t.split("-")[0]
}
function Po(t) {
    return t.split("-")[1]
}
function tm(t) {
    return t === "x" ? "y" : "x"
}
function rm(t) {
    return t === "y" ? "height" : "width"
}
function Yn(t) {
    return ["top", "bottom"].includes(un(t)) ? "y" : "x"
}
function nm(t) {
    return tm(Yn(t))
}
function fP(t, e, r) {
    r === void 0 && (r = !1);
    const n = Po(t)
      , s = nm(t)
      , i = rm(s);
    let o = s === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
    return e.reference[i] > e.floating[i] && (o = rc(o)),
    [o, rc(o)]
}
function hP(t) {
    const e = rc(t);
    return [Ch(t), e, Ch(e)]
}
function Ch(t) {
    return t.replace(/start|end/g, e => dP[e])
}
function pP(t, e, r) {
    const n = ["left", "right"]
      , s = ["right", "left"]
      , i = ["top", "bottom"]
      , o = ["bottom", "top"];
    switch (t) {
    case "top":
    case "bottom":
        return r ? e ? s : n : e ? n : s;
    case "left":
    case "right":
        return e ? i : o;
    default:
        return []
    }
}
function mP(t, e, r, n) {
    const s = Po(t);
    let i = pP(un(t), r === "start", n);
    return s && (i = i.map(o => o + "-" + s),
    e && (i = i.concat(i.map(Ch)))),
    i
}
function rc(t) {
    return t.replace(/left|right|bottom|top/g, e => cP[e])
}
function gP(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function Cb(t) {
    return typeof t != "number" ? gP(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function nc(t) {
    const {x: e, y: r, width: n, height: s} = t;
    return {
        width: n,
        height: s,
        top: r,
        left: e,
        right: e + n,
        bottom: r + s,
        x: e,
        y: r
    }
}
function _v(t, e, r) {
    let {reference: n, floating: s} = t;
    const i = Yn(e)
      , o = nm(e)
      , a = rm(o)
      , l = un(e)
      , u = i === "y"
      , c = n.x + n.width / 2 - s.width / 2
      , d = n.y + n.height / 2 - s.height / 2
      , f = n[a] / 2 - s[a] / 2;
    let p;
    switch (l) {
    case "top":
        p = {
            x: c,
            y: n.y - s.height
        };
        break;
    case "bottom":
        p = {
            x: c,
            y: n.y + n.height
        };
        break;
    case "right":
        p = {
            x: n.x + n.width,
            y: d
        };
        break;
    case "left":
        p = {
            x: n.x - s.width,
            y: d
        };
        break;
    default:
        p = {
            x: n.x,
            y: n.y
        }
    }
    switch (Po(e)) {
    case "start":
        p[o] -= f * (r && u ? -1 : 1);
        break;
    case "end":
        p[o] += f * (r && u ? -1 : 1);
        break
    }
    return p
}
const vP = async (t, e, r) => {
    const {placement: n="bottom", strategy: s="absolute", middleware: i=[], platform: o} = r
      , a = i.filter(Boolean)
      , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let u = await o.getElementRects({
        reference: t,
        floating: e,
        strategy: s
    })
      , {x: c, y: d} = _v(u, n, l)
      , f = n
      , p = {}
      , g = 0;
    for (let h = 0; h < a.length; h++) {
        const {name: w, fn: v} = a[h]
          , {x: m, y: _, data: x, reset: k} = await v({
            x: c,
            y: d,
            initialPlacement: n,
            placement: f,
            strategy: s,
            middlewareData: p,
            rects: u,
            platform: o,
            elements: {
                reference: t,
                floating: e
            }
        });
        c = m ?? c,
        d = _ ?? d,
        p = {
            ...p,
            [w]: {
                ...p[w],
                ...x
            }
        },
        k && g <= 50 && (g++,
        typeof k == "object" && (k.placement && (f = k.placement),
        k.rects && (u = k.rects === !0 ? await o.getElementRects({
            reference: t,
            floating: e,
            strategy: s
        }) : k.rects),
        {x: c, y: d} = _v(u, f, l)),
        h = -1)
    }
    return {
        x: c,
        y: d,
        placement: f,
        strategy: s,
        middlewareData: p
    }
}
;
async function $a(t, e) {
    var r;
    e === void 0 && (e = {});
    const {x: n, y: s, platform: i, rects: o, elements: a, strategy: l} = t
      , {boundary: u="clippingAncestors", rootBoundary: c="viewport", elementContext: d="floating", altBoundary: f=!1, padding: p=0} = ln(e, t)
      , g = Cb(p)
      , w = a[f ? d === "floating" ? "reference" : "floating" : d]
      , v = nc(await i.getClippingRect({
        element: (r = await (i.isElement == null ? void 0 : i.isElement(w))) == null || r ? w : w.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
        boundary: u,
        rootBoundary: c,
        strategy: l
    }))
      , m = d === "floating" ? {
        x: n,
        y: s,
        width: o.floating.width,
        height: o.floating.height
    } : o.reference
      , _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating))
      , x = await (i.isElement == null ? void 0 : i.isElement(_)) ? await (i.getScale == null ? void 0 : i.getScale(_)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , k = nc(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: m,
        offsetParent: _,
        strategy: l
    }) : m);
    return {
        top: (v.top - k.top + g.top) / x.y,
        bottom: (k.bottom - v.bottom + g.bottom) / x.y,
        left: (v.left - k.left + g.left) / x.x,
        right: (k.right - v.right + g.right) / x.x
    }
}
const yP = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const {x: r, y: n, placement: s, rects: i, platform: o, elements: a, middlewareData: l} = e
          , {element: u, padding: c=0} = ln(t, e) || {};
        if (u == null)
            return {};
        const d = Cb(c)
          , f = {
            x: r,
            y: n
        }
          , p = nm(s)
          , g = rm(p)
          , h = await o.getDimensions(u)
          , w = p === "y"
          , v = w ? "top" : "left"
          , m = w ? "bottom" : "right"
          , _ = w ? "clientHeight" : "clientWidth"
          , x = i.reference[g] + i.reference[p] - f[p] - i.floating[g]
          , k = f[p] - i.reference[p]
          , T = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
        let C = T ? T[_] : 0;
        (!C || !await (o.isElement == null ? void 0 : o.isElement(T))) && (C = a.floating[_] || i.floating[g]);
        const P = x / 2 - k / 2
          , j = C / 2 - h[g] / 2 - 1
          , $ = Zn(d[v], j)
          , X = Zn(d[m], j)
          , D = $
          , H = C - h[g] - X
          , M = C / 2 - h[g] / 2 + P
          , ie = kh(D, M, H)
          , te = !l.arrow && Po(s) != null && M !== ie && i.reference[g] / 2 - (M < D ? $ : X) - h[g] / 2 < 0
          , oe = te ? M < D ? M - D : M - H : 0;
        return {
            [p]: f[p] + oe,
            data: {
                [p]: ie,
                centerOffset: M - ie - oe,
                ...te && {
                    alignmentOffset: oe
                }
            },
            reset: te
        }
    }
})
  , wP = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "flip",
        options: t,
        async fn(e) {
            var r, n;
            const {placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: u} = e
              , {mainAxis: c=!0, crossAxis: d=!0, fallbackPlacements: f, fallbackStrategy: p="bestFit", fallbackAxisSideDirection: g="none", flipAlignment: h=!0, ...w} = ln(t, e);
            if ((r = i.arrow) != null && r.alignmentOffset)
                return {};
            const v = un(s)
              , m = Yn(a)
              , _ = un(a) === a
              , x = await (l.isRTL == null ? void 0 : l.isRTL(u.floating))
              , k = f || (_ || !h ? [rc(a)] : hP(a))
              , T = g !== "none";
            !f && T && k.push(...mP(a, h, g, x));
            const C = [a, ...k]
              , P = await $a(e, w)
              , j = [];
            let $ = ((n = i.flip) == null ? void 0 : n.overflows) || [];
            if (c && j.push(P[v]),
            d) {
                const M = fP(s, o, x);
                j.push(P[M[0]], P[M[1]])
            }
            if ($ = [...$, {
                placement: s,
                overflows: j
            }],
            !j.every(M => M <= 0)) {
                var X, D;
                const M = (((X = i.flip) == null ? void 0 : X.index) || 0) + 1
                  , ie = C[M];
                if (ie)
                    return {
                        data: {
                            index: M,
                            overflows: $
                        },
                        reset: {
                            placement: ie
                        }
                    };
                let te = (D = $.filter(oe => oe.overflows[0] <= 0).sort( (oe, A) => oe.overflows[1] - A.overflows[1])[0]) == null ? void 0 : D.placement;
                if (!te)
                    switch (p) {
                    case "bestFit":
                        {
                            var H;
                            const oe = (H = $.filter(A => {
                                if (T) {
                                    const V = Yn(A.placement);
                                    return V === m || V === "y"
                                }
                                return !0
                            }
                            ).map(A => [A.placement, A.overflows.filter(V => V > 0).reduce( (V, Y) => V + Y, 0)]).sort( (A, V) => A[1] - V[1])[0]) == null ? void 0 : H[0];
                            oe && (te = oe);
                            break
                        }
                    case "initialPlacement":
                        te = a;
                        break
                    }
                if (s !== te)
                    return {
                        reset: {
                            placement: te
                        }
                    }
            }
            return {}
        }
    }
};
function bv(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function xv(t) {
    return uP.some(e => t[e] >= 0)
}
const _P = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const {rects: r} = e
              , {strategy: n="referenceHidden", ...s} = ln(t, e);
            switch (n) {
            case "referenceHidden":
                {
                    const i = await $a(e, {
                        ...s,
                        elementContext: "reference"
                    })
                      , o = bv(i, r.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: o,
                            referenceHidden: xv(o)
                        }
                    }
                }
            case "escaped":
                {
                    const i = await $a(e, {
                        ...s,
                        altBoundary: !0
                    })
                      , o = bv(i, r.floating);
                    return {
                        data: {
                            escapedOffsets: o,
                            escaped: xv(o)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
async function bP(t, e) {
    const {placement: r, platform: n, elements: s} = t
      , i = await (n.isRTL == null ? void 0 : n.isRTL(s.floating))
      , o = un(r)
      , a = Po(r)
      , l = Yn(r) === "y"
      , u = ["left", "top"].includes(o) ? -1 : 1
      , c = i && l ? -1 : 1
      , d = ln(e, t);
    let {mainAxis: f, crossAxis: p, alignmentAxis: g} = typeof d == "number" ? {
        mainAxis: d,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: d.mainAxis || 0,
        crossAxis: d.crossAxis || 0,
        alignmentAxis: d.alignmentAxis
    };
    return a && typeof g == "number" && (p = a === "end" ? g * -1 : g),
    l ? {
        x: p * c,
        y: f * u
    } : {
        x: f * u,
        y: p * c
    }
}
const xP = function(t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            var r, n;
            const {x: s, y: i, placement: o, middlewareData: a} = e
              , l = await bP(e, t);
            return o === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
                x: s + l.x,
                y: i + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
}
  , SP = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "shift",
        options: t,
        async fn(e) {
            const {x: r, y: n, placement: s} = e
              , {mainAxis: i=!0, crossAxis: o=!1, limiter: a={
                fn: w => {
                    let {x: v, y: m} = w;
                    return {
                        x: v,
                        y: m
                    }
                }
            }, ...l} = ln(t, e)
              , u = {
                x: r,
                y: n
            }
              , c = await $a(e, l)
              , d = Yn(un(s))
              , f = tm(d);
            let p = u[f]
              , g = u[d];
            if (i) {
                const w = f === "y" ? "top" : "left"
                  , v = f === "y" ? "bottom" : "right"
                  , m = p + c[w]
                  , _ = p - c[v];
                p = kh(m, p, _)
            }
            if (o) {
                const w = d === "y" ? "top" : "left"
                  , v = d === "y" ? "bottom" : "right"
                  , m = g + c[w]
                  , _ = g - c[v];
                g = kh(m, g, _)
            }
            const h = a.fn({
                ...e,
                [f]: p,
                [d]: g
            });
            return {
                ...h,
                data: {
                    x: h.x - r,
                    y: h.y - n,
                    enabled: {
                        [f]: i,
                        [d]: o
                    }
                }
            }
        }
    }
}
  , EP = function(t) {
    return t === void 0 && (t = {}),
    {
        options: t,
        fn(e) {
            const {x: r, y: n, placement: s, rects: i, middlewareData: o} = e
              , {offset: a=0, mainAxis: l=!0, crossAxis: u=!0} = ln(t, e)
              , c = {
                x: r,
                y: n
            }
              , d = Yn(s)
              , f = tm(d);
            let p = c[f]
              , g = c[d];
            const h = ln(a, e)
              , w = typeof h == "number" ? {
                mainAxis: h,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...h
            };
            if (l) {
                const _ = f === "y" ? "height" : "width"
                  , x = i.reference[f] - i.floating[_] + w.mainAxis
                  , k = i.reference[f] + i.reference[_] - w.mainAxis;
                p < x ? p = x : p > k && (p = k)
            }
            if (u) {
                var v, m;
                const _ = f === "y" ? "width" : "height"
                  , x = ["top", "left"].includes(un(s))
                  , k = i.reference[d] - i.floating[_] + (x && ((v = o.offset) == null ? void 0 : v[d]) || 0) + (x ? 0 : w.crossAxis)
                  , T = i.reference[d] + i.reference[_] + (x ? 0 : ((m = o.offset) == null ? void 0 : m[d]) || 0) - (x ? w.crossAxis : 0);
                g < k ? g = k : g > T && (g = T)
            }
            return {
                [f]: p,
                [d]: g
            }
        }
    }
}
  , kP = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "size",
        options: t,
        async fn(e) {
            var r, n;
            const {placement: s, rects: i, platform: o, elements: a} = e
              , {apply: l= () => {}
            , ...u} = ln(t, e)
              , c = await $a(e, u)
              , d = un(s)
              , f = Po(s)
              , p = Yn(s) === "y"
              , {width: g, height: h} = i.floating;
            let w, v;
            d === "top" || d === "bottom" ? (w = d,
            v = f === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (v = d,
            w = f === "end" ? "top" : "bottom");
            const m = h - c.top - c.bottom
              , _ = g - c.left - c.right
              , x = Zn(h - c[w], m)
              , k = Zn(g - c[v], _)
              , T = !e.middlewareData.shift;
            let C = x
              , P = k;
            if ((r = e.middlewareData.shift) != null && r.enabled.x && (P = _),
            (n = e.middlewareData.shift) != null && n.enabled.y && (C = m),
            T && !f) {
                const $ = Mt(c.left, 0)
                  , X = Mt(c.right, 0)
                  , D = Mt(c.top, 0)
                  , H = Mt(c.bottom, 0);
                p ? P = g - 2 * ($ !== 0 || X !== 0 ? $ + X : Mt(c.left, c.right)) : C = h - 2 * (D !== 0 || H !== 0 ? D + H : Mt(c.top, c.bottom))
            }
            await l({
                ...e,
                availableWidth: P,
                availableHeight: C
            });
            const j = await o.getDimensions(a.floating);
            return g !== j.width || h !== j.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function Qc() {
    return typeof window < "u"
}
function Ro(t) {
    return Tb(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function Bt(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function Br(t) {
    var e;
    return (e = (Tb(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function Tb(t) {
    return Qc() ? t instanceof Node || t instanceof Bt(t).Node : !1
}
function br(t) {
    return Qc() ? t instanceof Element || t instanceof Bt(t).Element : !1
}
function Fr(t) {
    return Qc() ? t instanceof HTMLElement || t instanceof Bt(t).HTMLElement : !1
}
function Sv(t) {
    return !Qc() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Bt(t).ShadowRoot
}
function pl(t) {
    const {overflow: e, overflowX: r, overflowY: n, display: s} = xr(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !["inline", "contents"].includes(s)
}
function CP(t) {
    return ["table", "td", "th"].includes(Ro(t))
}
function Zc(t) {
    return [":popover-open", ":modal"].some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    }
    )
}
function sm(t) {
    const e = im()
      , r = br(t) ? xr(t) : t;
    return ["transform", "translate", "scale", "rotate", "perspective"].some(n => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(n => (r.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some(n => (r.contain || "").includes(n))
}
function TP(t) {
    let e = Jn(t);
    for (; Fr(e) && !mo(e); ) {
        if (sm(e))
            return e;
        if (Zc(e))
            return null;
        e = Jn(e)
    }
    return null
}
function im() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function mo(t) {
    return ["html", "body", "#document"].includes(Ro(t))
}
function xr(t) {
    return Bt(t).getComputedStyle(t)
}
function Yc(t) {
    return br(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}
function Jn(t) {
    if (Ro(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || Sv(t) && t.host || Br(t);
    return Sv(e) ? e.host : e
}
function Ob(t) {
    const e = Jn(t);
    return mo(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Fr(e) && pl(e) ? e : Ob(e)
}
function Fa(t, e, r) {
    var n;
    e === void 0 && (e = []),
    r === void 0 && (r = !0);
    const s = Ob(t)
      , i = s === ((n = t.ownerDocument) == null ? void 0 : n.body)
      , o = Bt(s);
    if (i) {
        const a = Th(o);
        return e.concat(o, o.visualViewport || [], pl(s) ? s : [], a && r ? Fa(a) : [])
    }
    return e.concat(s, Fa(s, [], r))
}
function Th(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}
function Pb(t) {
    const e = xr(t);
    let r = parseFloat(e.width) || 0
      , n = parseFloat(e.height) || 0;
    const s = Fr(t)
      , i = s ? t.offsetWidth : r
      , o = s ? t.offsetHeight : n
      , a = tc(r) !== i || tc(n) !== o;
    return a && (r = i,
    n = o),
    {
        width: r,
        height: n,
        $: a
    }
}
function om(t) {
    return br(t) ? t : t.contextElement
}
function Vi(t) {
    const e = om(t);
    if (!Fr(e))
        return Lr(1);
    const r = e.getBoundingClientRect()
      , {width: n, height: s, $: i} = Pb(e);
    let o = (i ? tc(r.width) : r.width) / n
      , a = (i ? tc(r.height) : r.height) / s;
    return (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const OP = Lr(0);
function Rb(t) {
    const e = Bt(t);
    return !im() || !e.visualViewport ? OP : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function PP(t, e, r) {
    return e === void 0 && (e = !1),
    !r || e && r !== Bt(t) ? !1 : e
}
function zs(t, e, r, n) {
    e === void 0 && (e = !1),
    r === void 0 && (r = !1);
    const s = t.getBoundingClientRect()
      , i = om(t);
    let o = Lr(1);
    e && (n ? br(n) && (o = Vi(n)) : o = Vi(t));
    const a = PP(i, r, n) ? Rb(i) : Lr(0);
    let l = (s.left + a.x) / o.x
      , u = (s.top + a.y) / o.y
      , c = s.width / o.x
      , d = s.height / o.y;
    if (i) {
        const f = Bt(i)
          , p = n && br(n) ? Bt(n) : n;
        let g = f
          , h = Th(g);
        for (; h && n && p !== g; ) {
            const w = Vi(h)
              , v = h.getBoundingClientRect()
              , m = xr(h)
              , _ = v.left + (h.clientLeft + parseFloat(m.paddingLeft)) * w.x
              , x = v.top + (h.clientTop + parseFloat(m.paddingTop)) * w.y;
            l *= w.x,
            u *= w.y,
            c *= w.x,
            d *= w.y,
            l += _,
            u += x,
            g = Bt(h),
            h = Th(g)
        }
    }
    return nc({
        width: c,
        height: d,
        x: l,
        y: u
    })
}
function am(t, e) {
    const r = Yc(t).scrollLeft;
    return e ? e.left + r : zs(Br(t)).left + r
}
function Ab(t, e, r) {
    r === void 0 && (r = !1);
    const n = t.getBoundingClientRect()
      , s = n.left + e.scrollLeft - (r ? 0 : am(t, n))
      , i = n.top + e.scrollTop;
    return {
        x: s,
        y: i
    }
}
function RP(t) {
    let {elements: e, rect: r, offsetParent: n, strategy: s} = t;
    const i = s === "fixed"
      , o = Br(n)
      , a = e ? Zc(e.floating) : !1;
    if (n === o || a && i)
        return r;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , u = Lr(1);
    const c = Lr(0)
      , d = Fr(n);
    if ((d || !d && !i) && ((Ro(n) !== "body" || pl(o)) && (l = Yc(n)),
    Fr(n))) {
        const p = zs(n);
        u = Vi(n),
        c.x = p.x + n.clientLeft,
        c.y = p.y + n.clientTop
    }
    const f = o && !d && !i ? Ab(o, l, !0) : Lr(0);
    return {
        width: r.width * u.x,
        height: r.height * u.y,
        x: r.x * u.x - l.scrollLeft * u.x + c.x + f.x,
        y: r.y * u.y - l.scrollTop * u.y + c.y + f.y
    }
}
function AP(t) {
    return Array.from(t.getClientRects())
}
function jP(t) {
    const e = Br(t)
      , r = Yc(t)
      , n = t.ownerDocument.body
      , s = Mt(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth)
      , i = Mt(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
    let o = -r.scrollLeft + am(t);
    const a = -r.scrollTop;
    return xr(n).direction === "rtl" && (o += Mt(e.clientWidth, n.clientWidth) - s),
    {
        width: s,
        height: i,
        x: o,
        y: a
    }
}
function NP(t, e) {
    const r = Bt(t)
      , n = Br(t)
      , s = r.visualViewport;
    let i = n.clientWidth
      , o = n.clientHeight
      , a = 0
      , l = 0;
    if (s) {
        i = s.width,
        o = s.height;
        const u = im();
        (!u || u && e === "fixed") && (a = s.offsetLeft,
        l = s.offsetTop)
    }
    return {
        width: i,
        height: o,
        x: a,
        y: l
    }
}
function IP(t, e) {
    const r = zs(t, !0, e === "fixed")
      , n = r.top + t.clientTop
      , s = r.left + t.clientLeft
      , i = Fr(t) ? Vi(t) : Lr(1)
      , o = t.clientWidth * i.x
      , a = t.clientHeight * i.y
      , l = s * i.x
      , u = n * i.y;
    return {
        width: o,
        height: a,
        x: l,
        y: u
    }
}
function Ev(t, e, r) {
    let n;
    if (e === "viewport")
        n = NP(t, r);
    else if (e === "document")
        n = jP(Br(t));
    else if (br(e))
        n = IP(e, r);
    else {
        const s = Rb(t);
        n = {
            x: e.x - s.x,
            y: e.y - s.y,
            width: e.width,
            height: e.height
        }
    }
    return nc(n)
}
function jb(t, e) {
    const r = Jn(t);
    return r === e || !br(r) || mo(r) ? !1 : xr(r).position === "fixed" || jb(r, e)
}
function DP(t, e) {
    const r = e.get(t);
    if (r)
        return r;
    let n = Fa(t, [], !1).filter(a => br(a) && Ro(a) !== "body")
      , s = null;
    const i = xr(t).position === "fixed";
    let o = i ? Jn(t) : t;
    for (; br(o) && !mo(o); ) {
        const a = xr(o)
          , l = sm(o);
        !l && a.position === "fixed" && (s = null),
        (i ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || pl(o) && !l && jb(t, o)) ? n = n.filter(c => c !== o) : s = a,
        o = Jn(o)
    }
    return e.set(t, n),
    n
}
function MP(t) {
    let {element: e, boundary: r, rootBoundary: n, strategy: s} = t;
    const o = [...r === "clippingAncestors" ? Zc(e) ? [] : DP(e, this._c) : [].concat(r), n]
      , a = o[0]
      , l = o.reduce( (u, c) => {
        const d = Ev(e, c, s);
        return u.top = Mt(d.top, u.top),
        u.right = Zn(d.right, u.right),
        u.bottom = Zn(d.bottom, u.bottom),
        u.left = Mt(d.left, u.left),
        u
    }
    , Ev(e, a, s));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function LP(t) {
    const {width: e, height: r} = Pb(t);
    return {
        width: e,
        height: r
    }
}
function $P(t, e, r) {
    const n = Fr(e)
      , s = Br(e)
      , i = r === "fixed"
      , o = zs(t, !0, i, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Lr(0);
    if (n || !n && !i)
        if ((Ro(e) !== "body" || pl(s)) && (a = Yc(e)),
        n) {
            const f = zs(e, !0, i, e);
            l.x = f.x + e.clientLeft,
            l.y = f.y + e.clientTop
        } else
            s && (l.x = am(s));
    const u = s && !n && !i ? Ab(s, a) : Lr(0)
      , c = o.left + a.scrollLeft - l.x - u.x
      , d = o.top + a.scrollTop - l.y - u.y;
    return {
        x: c,
        y: d,
        width: o.width,
        height: o.height
    }
}
function qd(t) {
    return xr(t).position === "static"
}
function kv(t, e) {
    if (!Fr(t) || xr(t).position === "fixed")
        return null;
    if (e)
        return e(t);
    let r = t.offsetParent;
    return Br(t) === r && (r = r.ownerDocument.body),
    r
}
function Nb(t, e) {
    const r = Bt(t);
    if (Zc(t))
        return r;
    if (!Fr(t)) {
        let s = Jn(t);
        for (; s && !mo(s); ) {
            if (br(s) && !qd(s))
                return s;
            s = Jn(s)
        }
        return r
    }
    let n = kv(t, e);
    for (; n && CP(n) && qd(n); )
        n = kv(n, e);
    return n && mo(n) && qd(n) && !sm(n) ? r : n || TP(t) || r
}
const FP = async function(t) {
    const e = this.getOffsetParent || Nb
      , r = this.getDimensions
      , n = await r(t.floating);
    return {
        reference: $P(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: n.width,
            height: n.height
        }
    }
};
function UP(t) {
    return xr(t).direction === "rtl"
}
const VP = {
    convertOffsetParentRelativeRectToViewportRelativeRect: RP,
    getDocumentElement: Br,
    getClippingRect: MP,
    getOffsetParent: Nb,
    getElementRects: FP,
    getClientRects: AP,
    getDimensions: LP,
    getScale: Vi,
    isElement: br,
    isRTL: UP
};
function Ib(t, e) {
    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
}
function BP(t, e) {
    let r = null, n;
    const s = Br(t);
    function i() {
        var a;
        clearTimeout(n),
        (a = r) == null || a.disconnect(),
        r = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        i();
        const u = t.getBoundingClientRect()
          , {left: c, top: d, width: f, height: p} = u;
        if (a || e(),
        !f || !p)
            return;
        const g = Hl(d)
          , h = Hl(s.clientWidth - (c + f))
          , w = Hl(s.clientHeight - (d + p))
          , v = Hl(c)
          , _ = {
            rootMargin: -g + "px " + -h + "px " + -w + "px " + -v + "px",
            threshold: Mt(0, Zn(1, l)) || 1
        };
        let x = !0;
        function k(T) {
            const C = T[0].intersectionRatio;
            if (C !== l) {
                if (!x)
                    return o();
                C ? o(!1, C) : n = setTimeout( () => {
                    o(!1, 1e-7)
                }
                , 1e3)
            }
            C === 1 && !Ib(u, t.getBoundingClientRect()) && o(),
            x = !1
        }
        try {
            r = new IntersectionObserver(k,{
                ..._,
                root: s.ownerDocument
            })
        } catch {
            r = new IntersectionObserver(k,_)
        }
        r.observe(t)
    }
    return o(!0),
    i
}
function zP(t, e, r, n) {
    n === void 0 && (n = {});
    const {ancestorScroll: s=!0, ancestorResize: i=!0, elementResize: o=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = n
      , u = om(t)
      , c = s || i ? [...u ? Fa(u) : [], ...Fa(e)] : [];
    c.forEach(v => {
        s && v.addEventListener("scroll", r, {
            passive: !0
        }),
        i && v.addEventListener("resize", r)
    }
    );
    const d = u && a ? BP(u, r) : null;
    let f = -1
      , p = null;
    o && (p = new ResizeObserver(v => {
        let[m] = v;
        m && m.target === u && p && (p.unobserve(e),
        cancelAnimationFrame(f),
        f = requestAnimationFrame( () => {
            var _;
            (_ = p) == null || _.observe(e)
        }
        )),
        r()
    }
    ),
    u && !l && p.observe(u),
    p.observe(e));
    let g, h = l ? zs(t) : null;
    l && w();
    function w() {
        const v = zs(t);
        h && !Ib(h, v) && r(),
        h = v,
        g = requestAnimationFrame(w)
    }
    return r(),
    () => {
        var v;
        c.forEach(m => {
            s && m.removeEventListener("scroll", r),
            i && m.removeEventListener("resize", r)
        }
        ),
        d == null || d(),
        (v = p) == null || v.disconnect(),
        p = null,
        l && cancelAnimationFrame(g)
    }
}
const WP = xP
  , HP = SP
  , qP = wP
  , KP = kP
  , GP = _P
  , Cv = yP
  , QP = EP
  , ZP = (t, e, r) => {
    const n = new Map
      , s = {
        platform: VP,
        ...r
    }
      , i = {
        ...s.platform,
        _c: n
    };
    return vP(t, e, {
        ...s,
        platform: i
    })
}
;
var Su = typeof document < "u" ? b.useLayoutEffect : b.useEffect;
function sc(t, e) {
    if (t === e)
        return !0;
    if (typeof t != typeof e)
        return !1;
    if (typeof t == "function" && t.toString() === e.toString())
        return !0;
    let r, n, s;
    if (t && e && typeof t == "object") {
        if (Array.isArray(t)) {
            if (r = t.length,
            r !== e.length)
                return !1;
            for (n = r; n-- !== 0; )
                if (!sc(t[n], e[n]))
                    return !1;
            return !0
        }
        if (s = Object.keys(t),
        r = s.length,
        r !== Object.keys(e).length)
            return !1;
        for (n = r; n-- !== 0; )
            if (!{}.hasOwnProperty.call(e, s[n]))
                return !1;
        for (n = r; n-- !== 0; ) {
            const i = s[n];
            if (!(i === "_owner" && t.$$typeof) && !sc(t[i], e[i]))
                return !1
        }
        return !0
    }
    return t !== t && e !== e
}
function Db(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function Tv(t, e) {
    const r = Db(t);
    return Math.round(e * r) / r
}
function Kd(t) {
    const e = b.useRef(t);
    return Su( () => {
        e.current = t
    }
    ),
    e
}
function YP(t) {
    t === void 0 && (t = {});
    const {placement: e="bottom", strategy: r="absolute", middleware: n=[], platform: s, elements: {reference: i, floating: o}={}, transform: a=!0, whileElementsMounted: l, open: u} = t
      , [c,d] = b.useState({
        x: 0,
        y: 0,
        strategy: r,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    })
      , [f,p] = b.useState(n);
    sc(f, n) || p(n);
    const [g,h] = b.useState(null)
      , [w,v] = b.useState(null)
      , m = b.useCallback(A => {
        A !== T.current && (T.current = A,
        h(A))
    }
    , [])
      , _ = b.useCallback(A => {
        A !== C.current && (C.current = A,
        v(A))
    }
    , [])
      , x = i || g
      , k = o || w
      , T = b.useRef(null)
      , C = b.useRef(null)
      , P = b.useRef(c)
      , j = l != null
      , $ = Kd(l)
      , X = Kd(s)
      , D = Kd(u)
      , H = b.useCallback( () => {
        if (!T.current || !C.current)
            return;
        const A = {
            placement: e,
            strategy: r,
            middleware: f
        };
        X.current && (A.platform = X.current),
        ZP(T.current, C.current, A).then(V => {
            const Y = {
                ...V,
                isPositioned: D.current !== !1
            };
            M.current && !sc(P.current, Y) && (P.current = Y,
            fl.flushSync( () => {
                d(Y)
            }
            ))
        }
        )
    }
    , [f, e, r, X, D]);
    Su( () => {
        u === !1 && P.current.isPositioned && (P.current.isPositioned = !1,
        d(A => ({
            ...A,
            isPositioned: !1
        })))
    }
    , [u]);
    const M = b.useRef(!1);
    Su( () => (M.current = !0,
    () => {
        M.current = !1
    }
    ), []),
    Su( () => {
        if (x && (T.current = x),
        k && (C.current = k),
        x && k) {
            if ($.current)
                return $.current(x, k, H);
            H()
        }
    }
    , [x, k, H, $, j]);
    const ie = b.useMemo( () => ({
        reference: T,
        floating: C,
        setReference: m,
        setFloating: _
    }), [m, _])
      , te = b.useMemo( () => ({
        reference: x,
        floating: k
    }), [x, k])
      , oe = b.useMemo( () => {
        const A = {
            position: r,
            left: 0,
            top: 0
        };
        if (!te.floating)
            return A;
        const V = Tv(te.floating, c.x)
          , Y = Tv(te.floating, c.y);
        return a ? {
            ...A,
            transform: "translate(" + V + "px, " + Y + "px)",
            ...Db(te.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: r,
            left: V,
            top: Y
        }
    }
    , [r, a, te.floating, c.x, c.y]);
    return b.useMemo( () => ({
        ...c,
        update: H,
        refs: ie,
        elements: te,
        floatingStyles: oe
    }), [c, H, ie, te, oe])
}
const JP = t => {
    function e(r) {
        return {}.hasOwnProperty.call(r, "current")
    }
    return {
        name: "arrow",
        options: t,
        fn(r) {
            const {element: n, padding: s} = typeof t == "function" ? t(r) : t;
            return n && e(n) ? n.current != null ? Cv({
                element: n.current,
                padding: s
            }).fn(r) : {} : n ? Cv({
                element: n,
                padding: s
            }).fn(r) : {}
        }
    }
}
  , XP = (t, e) => ({
    ...WP(t),
    options: [t, e]
})
  , eR = (t, e) => ({
    ...HP(t),
    options: [t, e]
})
  , tR = (t, e) => ({
    ...QP(t),
    options: [t, e]
})
  , rR = (t, e) => ({
    ...qP(t),
    options: [t, e]
})
  , nR = (t, e) => ({
    ...KP(t),
    options: [t, e]
})
  , sR = (t, e) => ({
    ...GP(t),
    options: [t, e]
})
  , iR = (t, e) => ({
    ...JP(t),
    options: [t, e]
});
var oR = "Arrow"
  , Mb = b.forwardRef( (t, e) => {
    const {children: r, width: n=10, height: s=5, ...i} = t;
    return y.jsx(Be.svg, {
        ...i,
        ref: e,
        width: n,
        height: s,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: t.asChild ? r : y.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
Mb.displayName = oR;
var aR = Mb;
function lR(t) {
    const [e,r] = b.useState(void 0);
    return Qn( () => {
        if (t) {
            r({
                width: t.offsetWidth,
                height: t.offsetHeight
            });
            const n = new ResizeObserver(s => {
                if (!Array.isArray(s) || !s.length)
                    return;
                const i = s[0];
                let o, a;
                if ("borderBoxSize"in i) {
                    const l = i.borderBoxSize
                      , u = Array.isArray(l) ? l[0] : l;
                    o = u.inlineSize,
                    a = u.blockSize
                } else
                    o = t.offsetWidth,
                    a = t.offsetHeight;
                r({
                    width: o,
                    height: a
                })
            }
            );
            return n.observe(t, {
                box: "border-box"
            }),
            () => n.unobserve(t)
        } else
            r(void 0)
    }
    , [t]),
    e
}
var Lb = "Popper"
  , [$b,Fb] = Co(Lb)
  , [VM,Ub] = $b(Lb)
  , Vb = "PopperAnchor"
  , Bb = b.forwardRef( (t, e) => {
    const {__scopePopper: r, virtualRef: n, ...s} = t
      , i = Ub(Vb, r)
      , o = b.useRef(null)
      , a = st(e, o);
    return b.useEffect( () => {
        i.onAnchorChange((n == null ? void 0 : n.current) || o.current)
    }
    ),
    n ? null : y.jsx(Be.div, {
        ...s,
        ref: a
    })
}
);
Bb.displayName = Vb;
var lm = "PopperContent"
  , [uR,cR] = $b(lm)
  , zb = b.forwardRef( (t, e) => {
    var kr, bl, Ys, No, Js, Io;
    const {__scopePopper: r, side: n="bottom", sideOffset: s=0, align: i="center", alignOffset: o=0, arrowPadding: a=0, avoidCollisions: l=!0, collisionBoundary: u=[], collisionPadding: c=0, sticky: d="partial", hideWhenDetached: f=!1, updatePositionStrategy: p="optimized", onPlaced: g, ...h} = t
      , w = Ub(lm, r)
      , [v,m] = b.useState(null)
      , _ = st(e, cs => m(cs))
      , [x,k] = b.useState(null)
      , T = lR(x)
      , C = (T == null ? void 0 : T.width) ?? 0
      , P = (T == null ? void 0 : T.height) ?? 0
      , j = n + (i !== "center" ? "-" + i : "")
      , $ = typeof c == "number" ? c : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...c
    }
      , X = Array.isArray(u) ? u : [u]
      , D = X.length > 0
      , H = {
        padding: $,
        boundary: X.filter(fR),
        altBoundary: D
    }
      , {refs: M, floatingStyles: ie, placement: te, isPositioned: oe, middlewareData: A} = YP({
        strategy: "fixed",
        placement: j,
        whileElementsMounted: (...cs) => zP(...cs, {
            animationFrame: p === "always"
        }),
        elements: {
            reference: w.anchor
        },
        middleware: [XP({
            mainAxis: s + P,
            alignmentAxis: o
        }), l && eR({
            mainAxis: !0,
            crossAxis: !1,
            limiter: d === "partial" ? tR() : void 0,
            ...H
        }), l && rR({
            ...H
        }), nR({
            ...H,
            apply: ({elements: cs, rects: Do, availableWidth: ld, availableHeight: xl}) => {
                const {width: Sl, height: ud} = Do.reference
                  , Xs = cs.floating.style;
                Xs.setProperty("--radix-popper-available-width", `${ld}px`),
                Xs.setProperty("--radix-popper-available-height", `${xl}px`),
                Xs.setProperty("--radix-popper-anchor-width", `${Sl}px`),
                Xs.setProperty("--radix-popper-anchor-height", `${ud}px`)
            }
        }), x && iR({
            element: x,
            padding: a
        }), hR({
            arrowWidth: C,
            arrowHeight: P
        }), f && sR({
            strategy: "referenceHidden",
            ...H
        })]
    })
      , [V,Y] = qb(te)
      , ae = rr(g);
    Qn( () => {
        oe && (ae == null || ae())
    }
    , [oe, ae]);
    const Ee = (kr = A.arrow) == null ? void 0 : kr.x
      , xt = (bl = A.arrow) == null ? void 0 : bl.y
      , St = ((Ys = A.arrow) == null ? void 0 : Ys.centerOffset) !== 0
      , [pn,nr] = b.useState();
    return Qn( () => {
        v && nr(window.getComputedStyle(v).zIndex)
    }
    , [v]),
    y.jsx("div", {
        ref: M.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...ie,
            transform: oe ? ie.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: pn,
            "--radix-popper-transform-origin": [(No = A.transformOrigin) == null ? void 0 : No.x, (Js = A.transformOrigin) == null ? void 0 : Js.y].join(" "),
            ...((Io = A.hide) == null ? void 0 : Io.referenceHidden) && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: t.dir,
        children: y.jsx(uR, {
            scope: r,
            placedSide: V,
            onArrowChange: k,
            arrowX: Ee,
            arrowY: xt,
            shouldHideArrow: St,
            children: y.jsx(Be.div, {
                "data-side": V,
                "data-align": Y,
                ...h,
                ref: _,
                style: {
                    ...h.style,
                    animation: oe ? void 0 : "none"
                }
            })
        })
    })
}
);
zb.displayName = lm;
var Wb = "PopperArrow"
  , dR = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , Hb = b.forwardRef(function(e, r) {
    const {__scopePopper: n, ...s} = e
      , i = cR(Wb, n)
      , o = dR[i.placedSide];
    return y.jsx("span", {
        ref: i.onArrowChange,
        style: {
            position: "absolute",
            left: i.arrowX,
            top: i.arrowY,
            [o]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[i.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[i.placedSide],
            visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: y.jsx(aR, {
            ...s,
            ref: r,
            style: {
                ...s.style,
                display: "block"
            }
        })
    })
});
Hb.displayName = Wb;
function fR(t) {
    return t !== null
}
var hR = t => ({
    name: "transformOrigin",
    options: t,
    fn(e) {
        var w, v, m;
        const {placement: r, rects: n, middlewareData: s} = e
          , o = ((w = s.arrow) == null ? void 0 : w.centerOffset) !== 0
          , a = o ? 0 : t.arrowWidth
          , l = o ? 0 : t.arrowHeight
          , [u,c] = qb(r)
          , d = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[c]
          , f = (((v = s.arrow) == null ? void 0 : v.x) ?? 0) + a / 2
          , p = (((m = s.arrow) == null ? void 0 : m.y) ?? 0) + l / 2;
        let g = ""
          , h = "";
        return u === "bottom" ? (g = o ? d : `${f}px`,
        h = `${-l}px`) : u === "top" ? (g = o ? d : `${f}px`,
        h = `${n.floating.height + l}px`) : u === "right" ? (g = `${-l}px`,
        h = o ? d : `${p}px`) : u === "left" && (g = `${n.floating.width + l}px`,
        h = o ? d : `${p}px`),
        {
            data: {
                x: g,
                y: h
            }
        }
    }
});
function qb(t) {
    const [e,r="center"] = t.split("-");
    return [e, r]
}
var pR = Bb
  , mR = zb
  , gR = Hb
  , [Jc,BM] = Co("Tooltip", [Fb])
  , um = Fb()
  , Kb = "TooltipProvider"
  , vR = 700
  , Ov = "tooltip.open"
  , [yR,Gb] = Jc(Kb)
  , Qb = t => {
    const {__scopeTooltip: e, delayDuration: r=vR, skipDelayDuration: n=300, disableHoverableContent: s=!1, children: i} = t
      , o = b.useRef(!0)
      , a = b.useRef(!1)
      , l = b.useRef(0);
    return b.useEffect( () => {
        const u = l.current;
        return () => window.clearTimeout(u)
    }
    , []),
    y.jsx(yR, {
        scope: e,
        isOpenDelayedRef: o,
        delayDuration: r,
        onOpen: b.useCallback( () => {
            window.clearTimeout(l.current),
            o.current = !1
        }
        , []),
        onClose: b.useCallback( () => {
            window.clearTimeout(l.current),
            l.current = window.setTimeout( () => o.current = !0, n)
        }
        , [n]),
        isPointerInTransitRef: a,
        onPointerInTransitChange: b.useCallback(u => {
            a.current = u
        }
        , []),
        disableHoverableContent: s,
        children: i
    })
}
;
Qb.displayName = Kb;
var Zb = "Tooltip"
  , [zM,Xc] = Jc(Zb)
  , Oh = "TooltipTrigger"
  , wR = b.forwardRef( (t, e) => {
    const {__scopeTooltip: r, ...n} = t
      , s = Xc(Oh, r)
      , i = Gb(Oh, r)
      , o = um(r)
      , a = b.useRef(null)
      , l = st(e, a, s.onTriggerChange)
      , u = b.useRef(!1)
      , c = b.useRef(!1)
      , d = b.useCallback( () => u.current = !1, []);
    return b.useEffect( () => () => document.removeEventListener("pointerup", d), [d]),
    y.jsx(pR, {
        asChild: !0,
        ...o,
        children: y.jsx(Be.button, {
            "aria-describedby": s.open ? s.contentId : void 0,
            "data-state": s.stateAttribute,
            ...n,
            ref: l,
            onPointerMove: Pe(t.onPointerMove, f => {
                f.pointerType !== "touch" && !c.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(),
                c.current = !0)
            }
            ),
            onPointerLeave: Pe(t.onPointerLeave, () => {
                s.onTriggerLeave(),
                c.current = !1
            }
            ),
            onPointerDown: Pe(t.onPointerDown, () => {
                s.open && s.onClose(),
                u.current = !0,
                document.addEventListener("pointerup", d, {
                    once: !0
                })
            }
            ),
            onFocus: Pe(t.onFocus, () => {
                u.current || s.onOpen()
            }
            ),
            onBlur: Pe(t.onBlur, s.onClose),
            onClick: Pe(t.onClick, s.onClose)
        })
    })
}
);
wR.displayName = Oh;
var _R = "TooltipPortal"
  , [WM,bR] = Jc(_R, {
    forceMount: void 0
})
  , go = "TooltipContent"
  , Yb = b.forwardRef( (t, e) => {
    const r = bR(go, t.__scopeTooltip)
      , {forceMount: n=r.forceMount, side: s="top", ...i} = t
      , o = Xc(go, t.__scopeTooltip);
    return y.jsx(To, {
        present: n || o.open,
        children: o.disableHoverableContent ? y.jsx(Jb, {
            side: s,
            ...i,
            ref: e
        }) : y.jsx(xR, {
            side: s,
            ...i,
            ref: e
        })
    })
}
)
  , xR = b.forwardRef( (t, e) => {
    const r = Xc(go, t.__scopeTooltip)
      , n = Gb(go, t.__scopeTooltip)
      , s = b.useRef(null)
      , i = st(e, s)
      , [o,a] = b.useState(null)
      , {trigger: l, onClose: u} = r
      , c = s.current
      , {onPointerInTransitChange: d} = n
      , f = b.useCallback( () => {
        a(null),
        d(!1)
    }
    , [d])
      , p = b.useCallback( (g, h) => {
        const w = g.currentTarget
          , v = {
            x: g.clientX,
            y: g.clientY
        }
          , m = TR(v, w.getBoundingClientRect())
          , _ = OR(v, m)
          , x = PR(h.getBoundingClientRect())
          , k = AR([..._, ...x]);
        a(k),
        d(!0)
    }
    , [d]);
    return b.useEffect( () => () => f(), [f]),
    b.useEffect( () => {
        if (l && c) {
            const g = w => p(w, c)
              , h = w => p(w, l);
            return l.addEventListener("pointerleave", g),
            c.addEventListener("pointerleave", h),
            () => {
                l.removeEventListener("pointerleave", g),
                c.removeEventListener("pointerleave", h)
            }
        }
    }
    , [l, c, p, f]),
    b.useEffect( () => {
        if (o) {
            const g = h => {
                const w = h.target
                  , v = {
                    x: h.clientX,
                    y: h.clientY
                }
                  , m = (l == null ? void 0 : l.contains(w)) || (c == null ? void 0 : c.contains(w))
                  , _ = !RR(v, o);
                m ? f() : _ && (f(),
                u())
            }
            ;
            return document.addEventListener("pointermove", g),
            () => document.removeEventListener("pointermove", g)
        }
    }
    , [l, c, o, u, f]),
    y.jsx(Jb, {
        ...t,
        ref: i
    })
}
)
  , [SR,ER] = Jc(Zb, {
    isInside: !1
})
  , kR = M_("TooltipContent")
  , Jb = b.forwardRef( (t, e) => {
    const {__scopeTooltip: r, children: n, "aria-label": s, onEscapeKeyDown: i, onPointerDownOutside: o, ...a} = t
      , l = Xc(go, r)
      , u = um(r)
      , {onClose: c} = l;
    return b.useEffect( () => (document.addEventListener(Ov, c),
    () => document.removeEventListener(Ov, c)), [c]),
    b.useEffect( () => {
        if (l.trigger) {
            const d = f => {
                const p = f.target;
                p != null && p.contains(l.trigger) && c()
            }
            ;
            return window.addEventListener("scroll", d, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", d, {
                capture: !0
            })
        }
    }
    , [l.trigger, c]),
    y.jsx(Wc, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: d => d.preventDefault(),
        onDismiss: c,
        children: y.jsxs(mR, {
            "data-state": l.stateAttribute,
            ...u,
            ...a,
            ref: e,
            style: {
                ...a.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [y.jsx(kR, {
                children: n
            }), y.jsx(SR, {
                scope: r,
                isInside: !0,
                children: y.jsx(QT, {
                    id: l.contentId,
                    role: "tooltip",
                    children: s || n
                })
            })]
        })
    })
}
);
Yb.displayName = go;
var Xb = "TooltipArrow"
  , CR = b.forwardRef( (t, e) => {
    const {__scopeTooltip: r, ...n} = t
      , s = um(r);
    return ER(Xb, r).isInside ? null : y.jsx(gR, {
        ...s,
        ...n,
        ref: e
    })
}
);
CR.displayName = Xb;
function TR(t, e) {
    const r = Math.abs(e.top - t.y)
      , n = Math.abs(e.bottom - t.y)
      , s = Math.abs(e.right - t.x)
      , i = Math.abs(e.left - t.x);
    switch (Math.min(r, n, s, i)) {
    case i:
        return "left";
    case s:
        return "right";
    case r:
        return "top";
    case n:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function OR(t, e, r=5) {
    const n = [];
    switch (e) {
    case "top":
        n.push({
            x: t.x - r,
            y: t.y + r
        }, {
            x: t.x + r,
            y: t.y + r
        });
        break;
    case "bottom":
        n.push({
            x: t.x - r,
            y: t.y - r
        }, {
            x: t.x + r,
            y: t.y - r
        });
        break;
    case "left":
        n.push({
            x: t.x + r,
            y: t.y - r
        }, {
            x: t.x + r,
            y: t.y + r
        });
        break;
    case "right":
        n.push({
            x: t.x - r,
            y: t.y - r
        }, {
            x: t.x - r,
            y: t.y + r
        });
        break
    }
    return n
}
function PR(t) {
    const {top: e, right: r, bottom: n, left: s} = t;
    return [{
        x: s,
        y: e
    }, {
        x: r,
        y: e
    }, {
        x: r,
        y: n
    }, {
        x: s,
        y: n
    }]
}
function RR(t, e) {
    const {x: r, y: n} = t;
    let s = !1;
    for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
        const a = e[i].x
          , l = e[i].y
          , u = e[o].x
          , c = e[o].y;
        l > n != c > n && r < (u - a) * (n - l) / (c - l) + a && (s = !s)
    }
    return s
}
function AR(t) {
    const e = t.slice();
    return e.sort( (r, n) => r.x < n.x ? -1 : r.x > n.x ? 1 : r.y < n.y ? -1 : r.y > n.y ? 1 : 0),
    jR(e)
}
function jR(t) {
    if (t.length <= 1)
        return t.slice();
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const s = t[n];
        for (; e.length >= 2; ) {
            const i = e[e.length - 1]
              , o = e[e.length - 2];
            if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x))
                e.pop();
            else
                break
        }
        e.push(s)
    }
    e.pop();
    const r = [];
    for (let n = t.length - 1; n >= 0; n--) {
        const s = t[n];
        for (; r.length >= 2; ) {
            const i = r[r.length - 1]
              , o = r[r.length - 2];
            if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x))
                r.pop();
            else
                break
        }
        r.push(s)
    }
    return r.pop(),
    e.length === 1 && r.length === 1 && e[0].x === r[0].x && e[0].y === r[0].y ? e : e.concat(r)
}
var NR = Qb
  , ex = Yb;
const IR = NR
  , DR = b.forwardRef( ({className: t, sideOffset: e=4, ...r}, n) => y.jsx(ex, {
    ref: n,
    sideOffset: e,
    className: ye("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]", t),
    ...r
}));
DR.displayName = ex.displayName;
var Ph = function(t, e) {
    return Ph = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(r, n) {
        r.__proto__ = n
    }
    || function(r, n) {
        for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (r[s] = n[s])
    }
    ,
    Ph(t, e)
};
function tx(t, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    Ph(t, e);
    function r() {
        this.constructor = t
    }
    t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype,
    new r)
}
var Yt = function() {
    return Yt = Object.assign || function(e) {
        for (var r, n = 1, s = arguments.length; n < s; n++) {
            r = arguments[n];
            for (var i in r)
                Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }
    ,
    Yt.apply(this, arguments)
};
function os(t, e) {
    var r = {};
    for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
            e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
    return r
}
function rx(t, e, r, n) {
    var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        i = Reflect.decorate(t, e, r, n);
    else
        for (var a = t.length - 1; a >= 0; a--)
            (o = t[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, r, i) : o(e, r)) || i);
    return s > 3 && i && Object.defineProperty(e, r, i),
    i
}
function nx(t, e) {
    return function(r, n) {
        e(r, n, t)
    }
}
function sx(t, e, r, n, s, i) {
    function o(v) {
        if (v !== void 0 && typeof v != "function")
            throw new TypeError("Function expected");
        return v
    }
    for (var a = n.kind, l = a === "getter" ? "get" : a === "setter" ? "set" : "value", u = !e && t ? n.static ? t : t.prototype : null, c = e || (u ? Object.getOwnPropertyDescriptor(u, n.name) : {}), d, f = !1, p = r.length - 1; p >= 0; p--) {
        var g = {};
        for (var h in n)
            g[h] = h === "access" ? {} : n[h];
        for (var h in n.access)
            g.access[h] = n.access[h];
        g.addInitializer = function(v) {
            if (f)
                throw new TypeError("Cannot add initializers after decoration has completed");
            i.push(o(v || null))
        }
        ;
        var w = (0,
        r[p])(a === "accessor" ? {
            get: c.get,
            set: c.set
        } : c[l], g);
        if (a === "accessor") {
            if (w === void 0)
                continue;
            if (w === null || typeof w != "object")
                throw new TypeError("Object expected");
            (d = o(w.get)) && (c.get = d),
            (d = o(w.set)) && (c.set = d),
            (d = o(w.init)) && s.unshift(d)
        } else
            (d = o(w)) && (a === "field" ? s.unshift(d) : c[l] = d)
    }
    u && Object.defineProperty(u, n.name, c),
    f = !0
}
function ix(t, e, r) {
    for (var n = arguments.length > 2, s = 0; s < e.length; s++)
        r = n ? e[s].call(t, r) : e[s].call(t);
    return n ? r : void 0
}
function ox(t) {
    return typeof t == "symbol" ? t : "".concat(t)
}
function ax(t, e, r) {
    return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(t, "name", {
        configurable: !0,
        value: r ? "".concat(r, " ", e) : e
    })
}
function lx(t, e) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(t, e)
}
function Z(t, e, r, n) {
    function s(i) {
        return i instanceof r ? i : new r(function(o) {
            o(i)
        }
        )
    }
    return new (r || (r = Promise))(function(i, o) {
        function a(c) {
            try {
                u(n.next(c))
            } catch (d) {
                o(d)
            }
        }
        function l(c) {
            try {
                u(n.throw(c))
            } catch (d) {
                o(d)
            }
        }
        function u(c) {
            c.done ? i(c.value) : s(c.value).then(a, l)
        }
        u((n = n.apply(t, e || [])).next())
    }
    )
}
function ux(t, e) {
    var r = {
        label: 0,
        sent: function() {
            if (i[0] & 1)
                throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    }, n, s, i, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0),
    o.throw = a(1),
    o.return = a(2),
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(u) {
        return function(c) {
            return l([u, c])
        }
    }
    function l(u) {
        if (n)
            throw new TypeError("Generator is already executing.");
        for (; o && (o = 0,
        u[0] && (r = 0)),
        r; )
            try {
                if (n = 1,
                s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s),
                0) : s.next) && !(i = i.call(s, u[1])).done)
                    return i;
                switch (s = 0,
                i && (u = [u[0] & 2, i.value]),
                u[0]) {
                case 0:
                case 1:
                    i = u;
                    break;
                case 4:
                    return r.label++,
                    {
                        value: u[1],
                        done: !1
                    };
                case 5:
                    r.label++,
                    s = u[1],
                    u = [0];
                    continue;
                case 7:
                    u = r.ops.pop(),
                    r.trys.pop();
                    continue;
                default:
                    if (i = r.trys,
                    !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                        r.label = u[1];
                        break
                    }
                    if (u[0] === 6 && r.label < i[1]) {
                        r.label = i[1],
                        i = u;
                        break
                    }
                    if (i && r.label < i[2]) {
                        r.label = i[2],
                        r.ops.push(u);
                        break
                    }
                    i[2] && r.ops.pop(),
                    r.trys.pop();
                    continue
                }
                u = e.call(t, r)
            } catch (c) {
                u = [6, c],
                s = 0
            } finally {
                n = i = 0
            }
        if (u[0] & 5)
            throw u[1];
        return {
            value: u[0] ? u[1] : void 0,
            done: !0
        }
    }
}
var ed = Object.create ? function(t, e, r, n) {
    n === void 0 && (n = r);
    var s = Object.getOwnPropertyDescriptor(e, r);
    (!s || ("get"in s ? !e.__esModule : s.writable || s.configurable)) && (s = {
        enumerable: !0,
        get: function() {
            return e[r]
        }
    }),
    Object.defineProperty(t, n, s)
}
: function(t, e, r, n) {
    n === void 0 && (n = r),
    t[n] = e[r]
}
;
function cx(t, e) {
    for (var r in t)
        r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && ed(e, t, r)
}
function ic(t) {
    var e = typeof Symbol == "function" && Symbol.iterator
      , r = e && t[e]
      , n = 0;
    if (r)
        return r.call(t);
    if (t && typeof t.length == "number")
        return {
            next: function() {
                return t && n >= t.length && (t = void 0),
                {
                    value: t && t[n++],
                    done: !t
                }
            }
        };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function cm(t, e) {
    var r = typeof Symbol == "function" && t[Symbol.iterator];
    if (!r)
        return t;
    var n = r.call(t), s, i = [], o;
    try {
        for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; )
            i.push(s.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            s && !s.done && (r = n.return) && r.call(n)
        } finally {
            if (o)
                throw o.error
        }
    }
    return i
}
function dx() {
    for (var t = [], e = 0; e < arguments.length; e++)
        t = t.concat(cm(arguments[e]));
    return t
}
function fx() {
    for (var t = 0, e = 0, r = arguments.length; e < r; e++)
        t += arguments[e].length;
    for (var n = Array(t), s = 0, e = 0; e < r; e++)
        for (var i = arguments[e], o = 0, a = i.length; o < a; o++,
        s++)
            n[s] = i[o];
    return n
}
function dm(t, e, r) {
    if (r || arguments.length === 2)
        for (var n = 0, s = e.length, i; n < s; n++)
            (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)),
            i[n] = e[n]);
    return t.concat(i || Array.prototype.slice.call(e))
}
function vo(t) {
    return this instanceof vo ? (this.v = t,
    this) : new vo(t)
}
function hx(t, e, r) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = r.apply(t, e || []), s, i = [];
    return s = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    a("next"),
    a("throw"),
    a("return", o),
    s[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    s;
    function o(p) {
        return function(g) {
            return Promise.resolve(g).then(p, d)
        }
    }
    function a(p, g) {
        n[p] && (s[p] = function(h) {
            return new Promise(function(w, v) {
                i.push([p, h, w, v]) > 1 || l(p, h)
            }
            )
        }
        ,
        g && (s[p] = g(s[p])))
    }
    function l(p, g) {
        try {
            u(n[p](g))
        } catch (h) {
            f(i[0][3], h)
        }
    }
    function u(p) {
        p.value instanceof vo ? Promise.resolve(p.value.v).then(c, d) : f(i[0][2], p)
    }
    function c(p) {
        l("next", p)
    }
    function d(p) {
        l("throw", p)
    }
    function f(p, g) {
        p(g),
        i.shift(),
        i.length && l(i[0][0], i[0][1])
    }
}
function px(t) {
    var e, r;
    return e = {},
    n("next"),
    n("throw", function(s) {
        throw s
    }),
    n("return"),
    e[Symbol.iterator] = function() {
        return this
    }
    ,
    e;
    function n(s, i) {
        e[s] = t[s] ? function(o) {
            return (r = !r) ? {
                value: vo(t[s](o)),
                done: !1
            } : i ? i(o) : o
        }
        : i
    }
}
function mx(t) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var e = t[Symbol.asyncIterator], r;
    return e ? e.call(t) : (t = typeof ic == "function" ? ic(t) : t[Symbol.iterator](),
    r = {},
    n("next"),
    n("throw"),
    n("return"),
    r[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    r);
    function n(i) {
        r[i] = t[i] && function(o) {
            return new Promise(function(a, l) {
                o = t[i](o),
                s(a, l, o.done, o.value)
            }
            )
        }
    }
    function s(i, o, a, l) {
        Promise.resolve(l).then(function(u) {
            i({
                value: u,
                done: a
            })
        }, o)
    }
}
function gx(t, e) {
    return Object.defineProperty ? Object.defineProperty(t, "raw", {
        value: e
    }) : t.raw = e,
    t
}
var MR = Object.create ? function(t, e) {
    Object.defineProperty(t, "default", {
        enumerable: !0,
        value: e
    })
}
: function(t, e) {
    t.default = e
}
  , Rh = function(t) {
    return Rh = Object.getOwnPropertyNames || function(e) {
        var r = [];
        for (var n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (r[r.length] = n);
        return r
    }
    ,
    Rh(t)
};
function vx(t) {
    if (t && t.__esModule)
        return t;
    var e = {};
    if (t != null)
        for (var r = Rh(t), n = 0; n < r.length; n++)
            r[n] !== "default" && ed(e, t, r[n]);
    return MR(e, t),
    e
}
function yx(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
function wx(t, e, r, n) {
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof e == "function" ? t !== e || !n : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t)
}
function _x(t, e, r, n, s) {
    if (n === "m")
        throw new TypeError("Private method is not writable");
    if (n === "a" && !s)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof e == "function" ? t !== e || !s : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return n === "a" ? s.call(t, r) : s ? s.value = r : e.set(t, r),
    r
}
function bx(t, e) {
    if (e === null || typeof e != "object" && typeof e != "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof t == "function" ? e === t : t.has(e)
}
function xx(t, e, r) {
    if (e != null) {
        if (typeof e != "object" && typeof e != "function")
            throw new TypeError("Object expected.");
        var n, s;
        if (r) {
            if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
            n = e[Symbol.asyncDispose]
        }
        if (n === void 0) {
            if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
            n = e[Symbol.dispose],
            r && (s = n)
        }
        if (typeof n != "function")
            throw new TypeError("Object not disposable.");
        s && (n = function() {
            try {
                s.call(this)
            } catch (i) {
                return Promise.reject(i)
            }
        }
        ),
        t.stack.push({
            value: e,
            dispose: n,
            async: r
        })
    } else
        r && t.stack.push({
            async: !0
        });
    return e
}
var LR = typeof SuppressedError == "function" ? SuppressedError : function(t, e, r) {
    var n = new Error(r);
    return n.name = "SuppressedError",
    n.error = t,
    n.suppressed = e,
    n
}
;
function Sx(t) {
    function e(i) {
        t.error = t.hasError ? new LR(i,t.error,"An error was suppressed during disposal.") : i,
        t.hasError = !0
    }
    var r, n = 0;
    function s() {
        for (; r = t.stack.pop(); )
            try {
                if (!r.async && n === 1)
                    return n = 0,
                    t.stack.push(r),
                    Promise.resolve().then(s);
                if (r.dispose) {
                    var i = r.dispose.call(r.value);
                    if (r.async)
                        return n |= 2,
                        Promise.resolve(i).then(s, function(o) {
                            return e(o),
                            s()
                        })
                } else
                    n |= 1
            } catch (o) {
                e(o)
            }
        if (n === 1)
            return t.hasError ? Promise.reject(t.error) : Promise.resolve();
        if (t.hasError)
            throw t.error
    }
    return s()
}
function Ex(t, e) {
    return typeof t == "string" && /^\.\.?\//.test(t) ? t.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(r, n, s, i, o) {
        return n ? e ? ".jsx" : ".js" : s && (!i || !o) ? r : s + i + "." + o.toLowerCase() + "js"
    }) : t
}
const $R = {
    __extends: tx,
    __assign: Yt,
    __rest: os,
    __decorate: rx,
    __param: nx,
    __esDecorate: sx,
    __runInitializers: ix,
    __propKey: ox,
    __setFunctionName: ax,
    __metadata: lx,
    __awaiter: Z,
    __generator: ux,
    __createBinding: ed,
    __exportStar: cx,
    __values: ic,
    __read: cm,
    __spread: dx,
    __spreadArrays: fx,
    __spreadArray: dm,
    __await: vo,
    __asyncGenerator: hx,
    __asyncDelegator: px,
    __asyncValues: mx,
    __makeTemplateObject: gx,
    __importStar: vx,
    __importDefault: yx,
    __classPrivateFieldGet: wx,
    __classPrivateFieldSet: _x,
    __classPrivateFieldIn: bx,
    __addDisposableResource: xx,
    __disposeResources: Sx,
    __rewriteRelativeImportExtension: Ex
}
  , FR = Object.freeze(Object.defineProperty({
    __proto__: null,
    __addDisposableResource: xx,
    get __assign() {
        return Yt
    },
    __asyncDelegator: px,
    __asyncGenerator: hx,
    __asyncValues: mx,
    __await: vo,
    __awaiter: Z,
    __classPrivateFieldGet: wx,
    __classPrivateFieldIn: bx,
    __classPrivateFieldSet: _x,
    __createBinding: ed,
    __decorate: rx,
    __disposeResources: Sx,
    __esDecorate: sx,
    __exportStar: cx,
    __extends: tx,
    __generator: ux,
    __importDefault: yx,
    __importStar: vx,
    __makeTemplateObject: gx,
    __metadata: lx,
    __param: nx,
    __propKey: ox,
    __read: cm,
    __rest: os,
    __rewriteRelativeImportExtension: Ex,
    __runInitializers: ix,
    __setFunctionName: ax,
    __spread: dx,
    __spreadArray: dm,
    __spreadArrays: fx,
    __values: ic,
    default: $R
}, Symbol.toStringTag, {
    value: "Module"
}))
  , UR = t => t ? (...e) => t(...e) : (...e) => fetch(...e);
class fm extends Error {
    constructor(e, r="FunctionsError", n) {
        super(e),
        this.name = r,
        this.context = n
    }
}
class VR extends fm {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
class Pv extends fm {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
class Rv extends fm {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
var Ah;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(Ah || (Ah = {}));
class BR {
    constructor(e, {headers: r={}, customFetch: n, region: s=Ah.Any}={}) {
        this.url = e,
        this.headers = r,
        this.region = s,
        this.fetch = UR(n)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e) {
        return Z(this, arguments, void 0, function*(r, n={}) {
            var s;
            let i, o;
            try {
                const {headers: a, method: l, body: u, signal: c, timeout: d} = n;
                let f = {}
                  , {region: p} = n;
                p || (p = this.region);
                const g = new URL(`${this.url}/${r}`);
                p && p !== "any" && (f["x-region"] = p,
                g.searchParams.set("forceFunctionRegion", p));
                let h;
                u && (a && !Object.prototype.hasOwnProperty.call(a, "Content-Type") || !a) ? typeof Blob < "u" && u instanceof Blob || u instanceof ArrayBuffer ? (f["Content-Type"] = "application/octet-stream",
                h = u) : typeof u == "string" ? (f["Content-Type"] = "text/plain",
                h = u) : typeof FormData < "u" && u instanceof FormData ? h = u : (f["Content-Type"] = "application/json",
                h = JSON.stringify(u)) : h = u;
                let w = c;
                d && (o = new AbortController,
                i = setTimeout( () => o.abort(), d),
                c ? (w = o.signal,
                c.addEventListener("abort", () => o.abort())) : w = o.signal);
                const v = yield this.fetch(g.toString(), {
                    method: l || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, f), this.headers), a),
                    body: h,
                    signal: w
                }).catch(k => {
                    throw new VR(k)
                }
                )
                  , m = v.headers.get("x-relay-error");
                if (m && m === "true")
                    throw new Pv(v);
                if (!v.ok)
                    throw new Rv(v);
                let _ = ((s = v.headers.get("Content-Type")) !== null && s !== void 0 ? s : "text/plain").split(";")[0].trim(), x;
                return _ === "application/json" ? x = yield v.json() : _ === "application/octet-stream" || _ === "application/pdf" ? x = yield v.blob() : _ === "text/event-stream" ? x = v : _ === "multipart/form-data" ? x = yield v.formData() : x = yield v.text(),
                {
                    data: x,
                    error: null,
                    response: v
                }
            } catch (a) {
                return {
                    data: null,
                    error: a,
                    response: a instanceof Rv || a instanceof Pv ? a.context : void 0
                }
            } finally {
                i && clearTimeout(i)
            }
        })
    }
}
var vt = {};
const Ao = UE(FR);
var ql = {}, Kl = {}, Gl = {}, Ql = {}, Zl = {}, Yl = {}, Av;
function kx() {
    if (Av)
        return Yl;
    Av = 1,
    Object.defineProperty(Yl, "__esModule", {
        value: !0
    });
    class t extends Error {
        constructor(r) {
            super(r.message),
            this.name = "PostgrestError",
            this.details = r.details,
            this.hint = r.hint,
            this.code = r.code
        }
    }
    return Yl.default = t,
    Yl
}
var jv;
function Cx() {
    if (jv)
        return Zl;
    jv = 1,
    Object.defineProperty(Zl, "__esModule", {
        value: !0
    });
    const e = Ao.__importDefault(kx());
    class r {
        constructor(s) {
            var i, o;
            this.shouldThrowOnError = !1,
            this.method = s.method,
            this.url = s.url,
            this.headers = new Headers(s.headers),
            this.schema = s.schema,
            this.body = s.body,
            this.shouldThrowOnError = (i = s.shouldThrowOnError) !== null && i !== void 0 ? i : !1,
            this.signal = s.signal,
            this.isMaybeSingle = (o = s.isMaybeSingle) !== null && o !== void 0 ? o : !1,
            s.fetch ? this.fetch = s.fetch : this.fetch = fetch
        }
        throwOnError() {
            return this.shouldThrowOnError = !0,
            this
        }
        setHeader(s, i) {
            return this.headers = new Headers(this.headers),
            this.headers.set(s, i),
            this
        }
        then(s, i) {
            this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
            this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
            const o = this.fetch;
            let a = o(this.url.toString(), {
                method: this.method,
                headers: this.headers,
                body: JSON.stringify(this.body),
                signal: this.signal
            }).then(async l => {
                var u, c, d, f;
                let p = null
                  , g = null
                  , h = null
                  , w = l.status
                  , v = l.statusText;
                if (l.ok) {
                    if (this.method !== "HEAD") {
                        const k = await l.text();
                        k === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((u = this.headers.get("Accept")) === null || u === void 0) && u.includes("application/vnd.pgrst.plan+text")) ? g = k : g = JSON.parse(k))
                    }
                    const _ = (c = this.headers.get("Prefer")) === null || c === void 0 ? void 0 : c.match(/count=(exact|planned|estimated)/)
                      , x = (d = l.headers.get("content-range")) === null || d === void 0 ? void 0 : d.split("/");
                    _ && x && x.length > 1 && (h = parseInt(x[1])),
                    this.isMaybeSingle && this.method === "GET" && Array.isArray(g) && (g.length > 1 ? (p = {
                        code: "PGRST116",
                        details: `Results contain ${g.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                        hint: null,
                        message: "JSON object requested, multiple (or no) rows returned"
                    },
                    g = null,
                    h = null,
                    w = 406,
                    v = "Not Acceptable") : g.length === 1 ? g = g[0] : g = null)
                } else {
                    const _ = await l.text();
                    try {
                        p = JSON.parse(_),
                        Array.isArray(p) && l.status === 404 && (g = [],
                        p = null,
                        w = 200,
                        v = "OK")
                    } catch {
                        l.status === 404 && _ === "" ? (w = 204,
                        v = "No Content") : p = {
                            message: _
                        }
                    }
                    if (p && this.isMaybeSingle && (!((f = p == null ? void 0 : p.details) === null || f === void 0) && f.includes("0 rows")) && (p = null,
                    w = 200,
                    v = "OK"),
                    p && this.shouldThrowOnError)
                        throw new e.default(p)
                }
                return {
                    error: p,
                    data: g,
                    count: h,
                    status: w,
                    statusText: v
                }
            }
            );
            return this.shouldThrowOnError || (a = a.catch(l => {
                var u, c, d, f, p, g;
                let h = "";
                const w = l == null ? void 0 : l.cause;
                if (w) {
                    const v = (u = w == null ? void 0 : w.message) !== null && u !== void 0 ? u : ""
                      , m = (c = w == null ? void 0 : w.code) !== null && c !== void 0 ? c : "";
                    h = `${(d = l == null ? void 0 : l.name) !== null && d !== void 0 ? d : "FetchError"}: ${l == null ? void 0 : l.message}`,
                    h += `

Caused by: ${(f = w == null ? void 0 : w.name) !== null && f !== void 0 ? f : "Error"}: ${v}`,
                    m && (h += ` (${m})`),
                    w != null && w.stack && (h += `
${w.stack}`)
                } else
                    h = (p = l == null ? void 0 : l.stack) !== null && p !== void 0 ? p : "";
                return {
                    error: {
                        message: `${(g = l == null ? void 0 : l.name) !== null && g !== void 0 ? g : "FetchError"}: ${l == null ? void 0 : l.message}`,
                        details: h,
                        hint: "",
                        code: ""
                    },
                    data: null,
                    count: null,
                    status: 0,
                    statusText: ""
                }
            }
            )),
            a.then(s, i)
        }
        returns() {
            return this
        }
        overrideTypes() {
            return this
        }
    }
    return Zl.default = r,
    Zl
}
var Nv;
function Tx() {
    if (Nv)
        return Ql;
    Nv = 1,
    Object.defineProperty(Ql, "__esModule", {
        value: !0
    });
    const e = Ao.__importDefault(Cx());
    class r extends e.default {
        select(s) {
            let i = !1;
            const o = (s ?? "*").split("").map(a => /\s/.test(a) && !i ? "" : (a === '"' && (i = !i),
            a)).join("");
            return this.url.searchParams.set("select", o),
            this.headers.append("Prefer", "return=representation"),
            this
        }
        order(s, {ascending: i=!0, nullsFirst: o, foreignTable: a, referencedTable: l=a}={}) {
            const u = l ? `${l}.order` : "order"
              , c = this.url.searchParams.get(u);
            return this.url.searchParams.set(u, `${c ? `${c},` : ""}${s}.${i ? "asc" : "desc"}${o === void 0 ? "" : o ? ".nullsfirst" : ".nullslast"}`),
            this
        }
        limit(s, {foreignTable: i, referencedTable: o=i}={}) {
            const a = typeof o > "u" ? "limit" : `${o}.limit`;
            return this.url.searchParams.set(a, `${s}`),
            this
        }
        range(s, i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = typeof a > "u" ? "offset" : `${a}.offset`
              , u = typeof a > "u" ? "limit" : `${a}.limit`;
            return this.url.searchParams.set(l, `${s}`),
            this.url.searchParams.set(u, `${i - s + 1}`),
            this
        }
        abortSignal(s) {
            return this.signal = s,
            this
        }
        single() {
            return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this
        }
        maybeSingle() {
            return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
            this.isMaybeSingle = !0,
            this
        }
        csv() {
            return this.headers.set("Accept", "text/csv"),
            this
        }
        geojson() {
            return this.headers.set("Accept", "application/geo+json"),
            this
        }
        explain({analyze: s=!1, verbose: i=!1, settings: o=!1, buffers: a=!1, wal: l=!1, format: u="text"}={}) {
            var c;
            const d = [s ? "analyze" : null, i ? "verbose" : null, o ? "settings" : null, a ? "buffers" : null, l ? "wal" : null].filter(Boolean).join("|")
              , f = (c = this.headers.get("Accept")) !== null && c !== void 0 ? c : "application/json";
            return this.headers.set("Accept", `application/vnd.pgrst.plan+${u}; for="${f}"; options=${d};`),
            u === "json" ? this : this
        }
        rollback() {
            return this.headers.append("Prefer", "tx=rollback"),
            this
        }
        returns() {
            return this
        }
        maxAffected(s) {
            return this.headers.append("Prefer", "handling=strict"),
            this.headers.append("Prefer", `max-affected=${s}`),
            this
        }
    }
    return Ql.default = r,
    Ql
}
var Iv;
function hm() {
    if (Iv)
        return Gl;
    Iv = 1,
    Object.defineProperty(Gl, "__esModule", {
        value: !0
    });
    const e = Ao.__importDefault(Tx())
      , r = new RegExp("[,()]");
    class n extends e.default {
        eq(i, o) {
            return this.url.searchParams.append(i, `eq.${o}`),
            this
        }
        neq(i, o) {
            return this.url.searchParams.append(i, `neq.${o}`),
            this
        }
        gt(i, o) {
            return this.url.searchParams.append(i, `gt.${o}`),
            this
        }
        gte(i, o) {
            return this.url.searchParams.append(i, `gte.${o}`),
            this
        }
        lt(i, o) {
            return this.url.searchParams.append(i, `lt.${o}`),
            this
        }
        lte(i, o) {
            return this.url.searchParams.append(i, `lte.${o}`),
            this
        }
        like(i, o) {
            return this.url.searchParams.append(i, `like.${o}`),
            this
        }
        likeAllOf(i, o) {
            return this.url.searchParams.append(i, `like(all).{${o.join(",")}}`),
            this
        }
        likeAnyOf(i, o) {
            return this.url.searchParams.append(i, `like(any).{${o.join(",")}}`),
            this
        }
        ilike(i, o) {
            return this.url.searchParams.append(i, `ilike.${o}`),
            this
        }
        ilikeAllOf(i, o) {
            return this.url.searchParams.append(i, `ilike(all).{${o.join(",")}}`),
            this
        }
        ilikeAnyOf(i, o) {
            return this.url.searchParams.append(i, `ilike(any).{${o.join(",")}}`),
            this
        }
        regexMatch(i, o) {
            return this.url.searchParams.append(i, `match.${o}`),
            this
        }
        regexIMatch(i, o) {
            return this.url.searchParams.append(i, `imatch.${o}`),
            this
        }
        is(i, o) {
            return this.url.searchParams.append(i, `is.${o}`),
            this
        }
        isDistinct(i, o) {
            return this.url.searchParams.append(i, `isdistinct.${o}`),
            this
        }
        in(i, o) {
            const a = Array.from(new Set(o)).map(l => typeof l == "string" && r.test(l) ? `"${l}"` : `${l}`).join(",");
            return this.url.searchParams.append(i, `in.(${a})`),
            this
        }
        contains(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cs.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cs.{${o.join(",")}}`) : this.url.searchParams.append(i, `cs.${JSON.stringify(o)}`),
            this
        }
        containedBy(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `cd.${o}`) : Array.isArray(o) ? this.url.searchParams.append(i, `cd.{${o.join(",")}}`) : this.url.searchParams.append(i, `cd.${JSON.stringify(o)}`),
            this
        }
        rangeGt(i, o) {
            return this.url.searchParams.append(i, `sr.${o}`),
            this
        }
        rangeGte(i, o) {
            return this.url.searchParams.append(i, `nxl.${o}`),
            this
        }
        rangeLt(i, o) {
            return this.url.searchParams.append(i, `sl.${o}`),
            this
        }
        rangeLte(i, o) {
            return this.url.searchParams.append(i, `nxr.${o}`),
            this
        }
        rangeAdjacent(i, o) {
            return this.url.searchParams.append(i, `adj.${o}`),
            this
        }
        overlaps(i, o) {
            return typeof o == "string" ? this.url.searchParams.append(i, `ov.${o}`) : this.url.searchParams.append(i, `ov.{${o.join(",")}}`),
            this
        }
        textSearch(i, o, {config: a, type: l}={}) {
            let u = "";
            l === "plain" ? u = "pl" : l === "phrase" ? u = "ph" : l === "websearch" && (u = "w");
            const c = a === void 0 ? "" : `(${a})`;
            return this.url.searchParams.append(i, `${u}fts${c}.${o}`),
            this
        }
        match(i) {
            return Object.entries(i).forEach( ([o,a]) => {
                this.url.searchParams.append(o, `eq.${a}`)
            }
            ),
            this
        }
        not(i, o, a) {
            return this.url.searchParams.append(i, `not.${o}.${a}`),
            this
        }
        or(i, {foreignTable: o, referencedTable: a=o}={}) {
            const l = a ? `${a}.or` : "or";
            return this.url.searchParams.append(l, `(${i})`),
            this
        }
        filter(i, o, a) {
            return this.url.searchParams.append(i, `${o}.${a}`),
            this
        }
    }
    return Gl.default = n,
    Gl
}
var Dv;
function Ox() {
    if (Dv)
        return Kl;
    Dv = 1,
    Object.defineProperty(Kl, "__esModule", {
        value: !0
    });
    const e = Ao.__importDefault(hm());
    class r {
        constructor(s, {headers: i={}, schema: o, fetch: a}) {
            this.url = s,
            this.headers = new Headers(i),
            this.schema = o,
            this.fetch = a
        }
        select(s, i) {
            const {head: o=!1, count: a} = i ?? {}
              , l = o ? "HEAD" : "GET";
            let u = !1;
            const c = (s ?? "*").split("").map(d => /\s/.test(d) && !u ? "" : (d === '"' && (u = !u),
            d)).join("");
            return this.url.searchParams.set("select", c),
            a && this.headers.append("Prefer", `count=${a}`),
            new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: this.fetch
            })
        }
        insert(s, {count: i, defaultToNull: o=!0}={}) {
            var a;
            const l = "POST";
            if (i && this.headers.append("Prefer", `count=${i}`),
            o || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const u = s.reduce( (c, d) => c.concat(Object.keys(d)), []);
                if (u.length > 0) {
                    const c = [...new Set(u)].map(d => `"${d}"`);
                    this.url.searchParams.set("columns", c.join(","))
                }
            }
            return new e.default({
                method: l,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (a = this.fetch) !== null && a !== void 0 ? a : fetch
            })
        }
        upsert(s, {onConflict: i, ignoreDuplicates: o=!1, count: a, defaultToNull: l=!0}={}) {
            var u;
            const c = "POST";
            if (this.headers.append("Prefer", `resolution=${o ? "ignore" : "merge"}-duplicates`),
            i !== void 0 && this.url.searchParams.set("on_conflict", i),
            a && this.headers.append("Prefer", `count=${a}`),
            l || this.headers.append("Prefer", "missing=default"),
            Array.isArray(s)) {
                const d = s.reduce( (f, p) => f.concat(Object.keys(p)), []);
                if (d.length > 0) {
                    const f = [...new Set(d)].map(p => `"${p}"`);
                    this.url.searchParams.set("columns", f.join(","))
                }
            }
            return new e.default({
                method: c,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (u = this.fetch) !== null && u !== void 0 ? u : fetch
            })
        }
        update(s, {count: i}={}) {
            var o;
            const a = "PATCH";
            return i && this.headers.append("Prefer", `count=${i}`),
            new e.default({
                method: a,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                body: s,
                fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
            })
        }
        delete({count: s}={}) {
            var i;
            const o = "DELETE";
            return s && this.headers.append("Prefer", `count=${s}`),
            new e.default({
                method: o,
                url: this.url,
                headers: this.headers,
                schema: this.schema,
                fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
            })
        }
    }
    return Kl.default = r,
    Kl
}
var Mv;
function zR() {
    if (Mv)
        return ql;
    Mv = 1,
    Object.defineProperty(ql, "__esModule", {
        value: !0
    });
    const t = Ao
      , e = t.__importDefault(Ox())
      , r = t.__importDefault(hm());
    class n {
        constructor(i, {headers: o={}, schema: a, fetch: l}={}) {
            this.url = i,
            this.headers = new Headers(o),
            this.schemaName = a,
            this.fetch = l
        }
        from(i) {
            if (!i || typeof i != "string" || i.trim() === "")
                throw new Error("Invalid relation name: relation must be a non-empty string.");
            const o = new URL(`${this.url}/${i}`);
            return new e.default(o,{
                headers: new Headers(this.headers),
                schema: this.schemaName,
                fetch: this.fetch
            })
        }
        schema(i) {
            return new n(this.url,{
                headers: this.headers,
                schema: i,
                fetch: this.fetch
            })
        }
        rpc(i, o={}, {head: a=!1, get: l=!1, count: u}={}) {
            var c;
            let d;
            const f = new URL(`${this.url}/rpc/${i}`);
            let p;
            a || l ? (d = a ? "HEAD" : "GET",
            Object.entries(o).filter( ([h,w]) => w !== void 0).map( ([h,w]) => [h, Array.isArray(w) ? `{${w.join(",")}}` : `${w}`]).forEach( ([h,w]) => {
                f.searchParams.append(h, w)
            }
            )) : (d = "POST",
            p = o);
            const g = new Headers(this.headers);
            return u && g.set("Prefer", `count=${u}`),
            new r.default({
                method: d,
                url: f,
                headers: g,
                schema: this.schemaName,
                body: p,
                fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch
            })
        }
    }
    return ql.default = n,
    ql
}
Object.defineProperty(vt, "__esModule", {
    value: !0
});
var Px = vt.PostgrestError = Fx = vt.PostgrestBuilder = Lx = vt.PostgrestTransformBuilder = Dx = vt.PostgrestFilterBuilder = Nx = vt.PostgrestQueryBuilder = Ax = vt.PostgrestClient = void 0;
const jo = Ao
  , Rx = jo.__importDefault(zR());
var Ax = vt.PostgrestClient = Rx.default;
const jx = jo.__importDefault(Ox());
var Nx = vt.PostgrestQueryBuilder = jx.default;
const Ix = jo.__importDefault(hm());
var Dx = vt.PostgrestFilterBuilder = Ix.default;
const Mx = jo.__importDefault(Tx());
var Lx = vt.PostgrestTransformBuilder = Mx.default;
const $x = jo.__importDefault(Cx());
var Fx = vt.PostgrestBuilder = $x.default;
const Ux = jo.__importDefault(kx());
Px = vt.PostgrestError = Ux.default;
var Vx = vt.default = {
    PostgrestClient: Rx.default,
    PostgrestQueryBuilder: jx.default,
    PostgrestFilterBuilder: Ix.default,
    PostgrestTransformBuilder: Mx.default,
    PostgrestBuilder: $x.default,
    PostgrestError: Ux.default
};
const WR = Wy({
    __proto__: null,
    get PostgrestBuilder() {
        return Fx
    },
    get PostgrestClient() {
        return Ax
    },
    get PostgrestError() {
        return Px
    },
    get PostgrestFilterBuilder() {
        return Dx
    },
    get PostgrestQueryBuilder() {
        return Nx
    },
    get PostgrestTransformBuilder() {
        return Lx
    },
    default: Vx
}, [vt])
  , {PostgrestClient: HR, PostgrestQueryBuilder: HM, PostgrestFilterBuilder: qM, PostgrestTransformBuilder: KM, PostgrestBuilder: GM, PostgrestError: QM} = Vx || WR;
class qR {
    constructor() {}
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof global < "u" && typeof global.WebSocket < "u")
            return {
                type: "native",
                constructor: global.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        if (typeof process < "u") {
            const r = process.versions;
            if (r && r.node) {
                const n = r.node
                  , s = parseInt(n.replace(/^v/, "").split(".")[0]);
                return s >= 22 ? typeof globalThis.WebSocket < "u" ? {
                    type: "native",
                    constructor: globalThis.WebSocket
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected but native WebSocket not found.`,
                    workaround: "Provide a WebSocket implementation via the transport option."
                } : {
                    type: "unsupported",
                    error: `Node.js ${s} detected without native WebSocket support.`,
                    workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
                }
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let r = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (r += `

Suggested solution: ${e.workaround}`),
        new Error(r)
    }
    static createWebSocket(e, r) {
        const n = this.getWebSocketConstructor();
        return new n(e,r)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const KR = "2.84.0"
  , GR = `realtime-js/${KR}`
  , Bx = "1.0.0"
  , QR = "2.0.0"
  , Lv = Bx
  , jh = 1e4
  , ZR = 1e3
  , YR = 100;
var ys;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(ys || (ys = {}));
var qe;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(qe || (qe = {}));
var cr;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(cr || (cr = {}));
var Nh;
(function(t) {
    t.websocket = "websocket"
}
)(Nh || (Nh = {}));
var ws;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(ws || (ws = {}));
class JR {
    constructor() {
        this.HEADER_LENGTH = 1,
        this.META_LENGTH = 4,
        this.USER_BROADCAST_PUSH_META_LENGTH = 5,
        this.KINDS = {
            userBroadcastPush: 3,
            userBroadcast: 4
        },
        this.BINARY_ENCODING = 0,
        this.JSON_ENCODING = 1,
        this.BROADCAST_EVENT = "broadcast"
    }
    encode(e, r) {
        if (e.event === this.BROADCAST_EVENT && !(e.payload instanceof ArrayBuffer) && typeof e.payload.event == "string")
            return r(this._binaryEncodeUserBroadcastPush(e));
        let n = [e.join_ref, e.ref, e.topic, e.event, e.payload];
        return r(JSON.stringify(n))
    }
    _binaryEncodeUserBroadcastPush(e) {
        var r;
        return this._isArrayBuffer((r = e.payload) === null || r === void 0 ? void 0 : r.payload) ? this._encodeBinaryUserBroadcastPush(e) : this._encodeJsonUserBroadcastPush(e)
    }
    _encodeBinaryUserBroadcastPush(e) {
        var r, n, s, i;
        const o = e.topic
          , a = (r = e.ref) !== null && r !== void 0 ? r : ""
          , l = (n = e.join_ref) !== null && n !== void 0 ? n : ""
          , u = e.payload.event
          , c = (i = (s = e.payload) === null || s === void 0 ? void 0 : s.payload) !== null && i !== void 0 ? i : new ArrayBuffer(0)
          , d = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + u.length
          , f = new ArrayBuffer(this.HEADER_LENGTH + d);
        let p = new DataView(f)
          , g = 0;
        p.setUint8(g++, this.KINDS.userBroadcastPush),
        p.setUint8(g++, l.length),
        p.setUint8(g++, a.length),
        p.setUint8(g++, o.length),
        p.setUint8(g++, u.length),
        p.setUint8(g++, this.BINARY_ENCODING),
        Array.from(l, w => p.setUint8(g++, w.charCodeAt(0))),
        Array.from(a, w => p.setUint8(g++, w.charCodeAt(0))),
        Array.from(o, w => p.setUint8(g++, w.charCodeAt(0))),
        Array.from(u, w => p.setUint8(g++, w.charCodeAt(0)));
        var h = new Uint8Array(f.byteLength + c.byteLength);
        return h.set(new Uint8Array(f), 0),
        h.set(new Uint8Array(c), f.byteLength),
        h.buffer
    }
    _encodeJsonUserBroadcastPush(e) {
        var r, n, s, i;
        const o = e.topic
          , a = (r = e.ref) !== null && r !== void 0 ? r : ""
          , l = (n = e.join_ref) !== null && n !== void 0 ? n : ""
          , u = e.payload.event
          , c = (i = (s = e.payload) === null || s === void 0 ? void 0 : s.payload) !== null && i !== void 0 ? i : {}
          , f = new TextEncoder().encode(JSON.stringify(c)).buffer
          , p = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + u.length
          , g = new ArrayBuffer(this.HEADER_LENGTH + p);
        let h = new DataView(g)
          , w = 0;
        h.setUint8(w++, this.KINDS.userBroadcastPush),
        h.setUint8(w++, l.length),
        h.setUint8(w++, a.length),
        h.setUint8(w++, o.length),
        h.setUint8(w++, u.length),
        h.setUint8(w++, this.JSON_ENCODING),
        Array.from(l, m => h.setUint8(w++, m.charCodeAt(0))),
        Array.from(a, m => h.setUint8(w++, m.charCodeAt(0))),
        Array.from(o, m => h.setUint8(w++, m.charCodeAt(0))),
        Array.from(u, m => h.setUint8(w++, m.charCodeAt(0)));
        var v = new Uint8Array(g.byteLength + f.byteLength);
        return v.set(new Uint8Array(g), 0),
        v.set(new Uint8Array(f), g.byteLength),
        v.buffer
    }
    decode(e, r) {
        if (this._isArrayBuffer(e)) {
            let n = this._binaryDecode(e);
            return r(n)
        }
        if (typeof e == "string") {
            const n = JSON.parse(e)
              , [s,i,o,a,l] = n;
            return r({
                join_ref: s,
                ref: i,
                topic: o,
                event: a,
                payload: l
            })
        }
        return r({})
    }
    _binaryDecode(e) {
        const r = new DataView(e)
          , n = r.getUint8(0)
          , s = new TextDecoder;
        switch (n) {
        case this.KINDS.userBroadcast:
            return this._decodeUserBroadcast(e, r, s)
        }
    }
    _decodeUserBroadcast(e, r, n) {
        const s = r.getUint8(1)
          , i = r.getUint8(2)
          , o = r.getUint8(3)
          , a = r.getUint8(4);
        let l = this.HEADER_LENGTH + 4;
        const u = n.decode(e.slice(l, l + s));
        l = l + s;
        const c = n.decode(e.slice(l, l + i));
        l = l + i;
        const d = n.decode(e.slice(l, l + o));
        l = l + o;
        const f = e.slice(l, e.byteLength)
          , p = a === this.JSON_ENCODING ? JSON.parse(n.decode(f)) : f
          , g = {
            type: this.BROADCAST_EVENT,
            event: c,
            payload: p
        };
        return o > 0 && (g.meta = JSON.parse(d)),
        {
            join_ref: null,
            ref: null,
            topic: u,
            event: this.BROADCAST_EVENT,
            payload: g
        }
    }
    _isArrayBuffer(e) {
        var r;
        return e instanceof ArrayBuffer || ((r = e == null ? void 0 : e.constructor) === null || r === void 0 ? void 0 : r.name) === "ArrayBuffer"
    }
}
class zx {
    constructor(e, r) {
        this.callback = e,
        this.timerCalc = r,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = r
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout( () => {
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var ke;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(ke || (ke = {}));
const $v = (t, e, r={}) => {
    var n;
    const s = (n = r.skipTypes) !== null && n !== void 0 ? n : [];
    return e ? Object.keys(e).reduce( (i, o) => (i[o] = XR(o, t, e, s),
    i), {}) : {}
}
  , XR = (t, e, r, n) => {
    const s = e.find(a => a.name === t)
      , i = s == null ? void 0 : s.type
      , o = r[t];
    return i && !n.includes(i) ? Wx(i, o) : Ih(o)
}
  , Wx = (t, e) => {
    if (t.charAt(0) === "_") {
        const r = t.slice(1, t.length);
        return nA(e, r)
    }
    switch (t) {
    case ke.bool:
        return eA(e);
    case ke.float4:
    case ke.float8:
    case ke.int2:
    case ke.int4:
    case ke.int8:
    case ke.numeric:
    case ke.oid:
        return tA(e);
    case ke.json:
    case ke.jsonb:
        return rA(e);
    case ke.timestamp:
        return sA(e);
    case ke.abstime:
    case ke.date:
    case ke.daterange:
    case ke.int4range:
    case ke.int8range:
    case ke.money:
    case ke.reltime:
    case ke.text:
    case ke.time:
    case ke.timestamptz:
    case ke.timetz:
    case ke.tsrange:
    case ke.tstzrange:
        return Ih(e);
    default:
        return Ih(e)
    }
}
  , Ih = t => t
  , eA = t => {
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , tA = t => {
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , rA = t => {
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch (e) {
            return console.log(`JSON parse error: ${e}`),
            t
        }
    return t
}
  , nA = (t, e) => {
    if (typeof t != "string")
        return t;
    const r = t.length - 1
      , n = t[r];
    if (t[0] === "{" && n === "}") {
        let i;
        const o = t.slice(1, r);
        try {
            i = JSON.parse("[" + o + "]")
        } catch {
            i = o ? o.split(",") : []
        }
        return i.map(a => Wx(e, a))
    }
    return t
}
  , sA = t => typeof t == "string" ? t.replace(" ", "T") : t
  , Hx = t => {
    const e = new URL(t);
    return e.protocol = e.protocol.replace(/^ws/i, "http"),
    e.pathname = e.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""),
    e.pathname === "" || e.pathname === "/" ? e.pathname = "/api/broadcast" : e.pathname = e.pathname + "/api/broadcast",
    e.href
}
;
class Gd {
    constructor(e, r, n={}, s=jh) {
        this.channel = e,
        this.event = r,
        this.payload = n,
        this.timeout = s,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, r) {
        var n;
        return this._hasReceived(e) && r((n = this.receivedResp) === null || n === void 0 ? void 0 : n.response),
        this.recHooks.push({
            status: e,
            callback: r
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = r => {
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = r,
            this._matchReceive(r)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout( () => {
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, r) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: r
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: r}) {
        this.recHooks.filter(n => n.status === e).forEach(n => n.callback(r))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var Fv;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(Fv || (Fv = {}));
class ma {
    constructor(e, r) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: () => {}
            ,
            onLeave: () => {}
            ,
            onSync: () => {}
        };
        const n = (r == null ? void 0 : r.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(n.state, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = ma.syncState(this.state, s, i, o),
            this.pendingDiffs.forEach(l => {
                this.state = ma.syncDiff(this.state, l, i, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(n.diff, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(s) : (this.state = ma.syncDiff(this.state, s, i, o),
            a())
        }
        ),
        this.onJoin( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "join",
                key: s,
                currentPresences: i,
                newPresences: o
            })
        }
        ),
        this.onLeave( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "leave",
                key: s,
                currentPresences: i,
                leftPresences: o
            })
        }
        ),
        this.onSync( () => {
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, r, n, s) {
        const i = this.cloneDeep(e)
          , o = this.transformState(r)
          , a = {}
          , l = {};
        return this.map(i, (u, c) => {
            o[u] || (l[u] = c)
        }
        ),
        this.map(o, (u, c) => {
            const d = i[u];
            if (d) {
                const f = c.map(w => w.presence_ref)
                  , p = d.map(w => w.presence_ref)
                  , g = c.filter(w => p.indexOf(w.presence_ref) < 0)
                  , h = d.filter(w => f.indexOf(w.presence_ref) < 0);
                g.length > 0 && (a[u] = g),
                h.length > 0 && (l[u] = h)
            } else
                a[u] = c
        }
        ),
        this.syncDiff(i, {
            joins: a,
            leaves: l
        }, n, s)
    }
    static syncDiff(e, r, n, s) {
        const {joins: i, leaves: o} = {
            joins: this.transformState(r.joins),
            leaves: this.transformState(r.leaves)
        };
        return n || (n = () => {}
        ),
        s || (s = () => {}
        ),
        this.map(i, (a, l) => {
            var u;
            const c = (u = e[a]) !== null && u !== void 0 ? u : [];
            if (e[a] = this.cloneDeep(l),
            c.length > 0) {
                const d = e[a].map(p => p.presence_ref)
                  , f = c.filter(p => d.indexOf(p.presence_ref) < 0);
                e[a].unshift(...f)
            }
            n(a, c, l)
        }
        ),
        this.map(o, (a, l) => {
            let u = e[a];
            if (!u)
                return;
            const c = l.map(d => d.presence_ref);
            u = u.filter(d => c.indexOf(d.presence_ref) < 0),
            e[a] = u,
            s(a, u, l),
            u.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, r) {
        return Object.getOwnPropertyNames(e).map(n => r(n, e[n]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce( (r, n) => {
            const s = e[n];
            return "metas"in s ? r[n] = s.metas.map(i => (i.presence_ref = i.phx_ref,
            delete i.phx_ref,
            delete i.phx_ref_prev,
            i)) : r[n] = s,
            r
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
var Uv;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(Uv || (Uv = {}));
var ga;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(ga || (ga = {}));
var Gr;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(Gr || (Gr = {}));
class pm {
    constructor(e, r={
        config: {}
    }, n) {
        var s, i;
        if (this.topic = e,
        this.params = r,
        this.socket = n,
        this.bindings = {},
        this.state = qe.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, r.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new Gd(this,cr.join,this.params,this.timeout),
        this.rejoinTimer = new zx( () => this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", () => {
            this.state = qe.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(o => o.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose( () => {
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = qe.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = qe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", () => {
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = qe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = qe.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(cr.reply, {}, (o, a) => {
            this._trigger(this._replyEventName(a), o)
        }
        ),
        this.presence = new ma(this),
        this.broadcastEndpointURL = Hx(this.socket.endPoint),
        this.private = this.params.config.private || !1,
        !this.private && (!((i = (s = this.params.config) === null || s === void 0 ? void 0 : s.broadcast) === null || i === void 0) && i.replay))
            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`
    }
    subscribe(e, r=this.timeout) {
        var n, s, i;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == qe.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , u = (s = (n = this.bindings.postgres_changes) === null || n === void 0 ? void 0 : n.map(p => p.filter)) !== null && s !== void 0 ? s : []
              , c = !!this.bindings[ga.PRESENCE] && this.bindings[ga.PRESENCE].length > 0 || ((i = this.params.config.presence) === null || i === void 0 ? void 0 : i.enabled) === !0
              , d = {}
              , f = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: c
                }),
                postgres_changes: u,
                private: l
            };
            this.socket.accessTokenValue && (d.access_token = this.socket.accessTokenValue),
            this._onError(p => e == null ? void 0 : e(Gr.CHANNEL_ERROR, p)),
            this._onClose( () => e == null ? void 0 : e(Gr.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: f
            }, d)),
            this.joinedOnce = !0,
            this._rejoin(r),
            this.joinPush.receive("ok", async ({postgres_changes: p}) => {
                var g;
                if (this.socket.setAuth(),
                p === void 0) {
                    e == null || e(Gr.SUBSCRIBED);
                    return
                } else {
                    const h = this.bindings.postgres_changes
                      , w = (g = h == null ? void 0 : h.length) !== null && g !== void 0 ? g : 0
                      , v = [];
                    for (let m = 0; m < w; m++) {
                        const _ = h[m]
                          , {filter: {event: x, schema: k, table: T, filter: C}} = _
                          , P = p && p[m];
                        if (P && P.event === x && P.schema === k && P.table === T && P.filter === C)
                            v.push(Object.assign(Object.assign({}, _), {
                                id: P.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = qe.errored,
                            e == null || e(Gr.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = v,
                    e && e(Gr.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", p => {
                this.state = qe.errored,
                e == null || e(Gr.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(p).join(", ") || "error")))
            }
            ).receive("timeout", () => {
                e == null || e(Gr.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, r={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, r.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, r, n) {
        return this.state === qe.joined && e === ga.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then( () => this.subscribe())),
        this._on(e, r, n)
    }
    async httpSend(e, r, n={}) {
        var s;
        const i = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        if (r == null)
            return Promise.reject("Payload is required for httpSend()");
        const o = {
            method: "POST",
            headers: {
                Authorization: i,
                apikey: this.socket.apiKey ? this.socket.apiKey : "",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                messages: [{
                    topic: this.subTopic,
                    event: e,
                    payload: r,
                    private: this.private
                }]
            })
        }
          , a = await this._fetchWithTimeout(this.broadcastEndpointURL, o, (s = n.timeout) !== null && s !== void 0 ? s : this.timeout);
        if (a.status === 202)
            return {
                success: !0
            };
        let l = a.statusText;
        try {
            const u = await a.json();
            l = u.error || u.message || l
        } catch {}
        return Promise.reject(new Error(l))
    }
    async send(e, r={}) {
        var n, s;
        if (!this._canPush() && e.type === "broadcast") {
            console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
            const {event: i, payload: o} = e
              , l = {
                method: "POST",
                headers: {
                    Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "",
                    apikey: this.socket.apiKey ? this.socket.apiKey : "",
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: i,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const u = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (n = r.timeout) !== null && n !== void 0 ? n : this.timeout);
                return await ((s = u.body) === null || s === void 0 ? void 0 : s.cancel()),
                u.ok ? "ok" : "error"
            } catch (u) {
                return u.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(i => {
                var o, a, l;
                const u = this._push(e.type, e, r.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && i("ok"),
                u.receive("ok", () => i("ok")),
                u.receive("error", () => i("error")),
                u.receive("timeout", () => i("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = qe.leaving;
        const r = () => {
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(cr.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let n = null;
        return new Promise(s => {
            n = new Gd(this,cr.leave,{},e),
            n.receive("ok", () => {
                r(),
                s("ok")
            }
            ).receive("timeout", () => {
                r(),
                s("timed out")
            }
            ).receive("error", () => {
                s("error")
            }
            ),
            n.send(),
            this._canPush() || n.trigger("ok", {})
        }
        ).finally( () => {
            n == null || n.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e => e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = qe.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, r, n) {
        const s = new AbortController
          , i = setTimeout( () => s.abort(), n)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, r), {
            signal: s.signal
        }));
        return clearTimeout(i),
        o
    }
    _push(e, r, n=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let s = new Gd(this,e,r,n);
        return this._canPush() ? s.send() : this._addToPushBuffer(s),
        s
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > YR) {
            const r = this.pushBuffer.shift();
            r && (r.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${r.event}`, r.payload))
        }
    }
    _onMessage(e, r, n) {
        return r
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, r, n) {
        var s, i;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: u, join: c} = cr;
        if (n && [a, l, u, c].indexOf(o) >= 0 && n !== this._joinRef())
            return;
        let f = this._onMessage(o, r, n);
        if (r && !f)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (s = this.bindings.postgres_changes) === null || s === void 0 || s.filter(p => {
            var g, h, w;
            return ((g = p.filter) === null || g === void 0 ? void 0 : g.event) === "*" || ((w = (h = p.filter) === null || h === void 0 ? void 0 : h.event) === null || w === void 0 ? void 0 : w.toLocaleLowerCase()) === o
        }
        ).map(p => p.callback(f, n)) : (i = this.bindings[o]) === null || i === void 0 || i.filter(p => {
            var g, h, w, v, m, _;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in p) {
                    const x = p.id
                      , k = (g = p.filter) === null || g === void 0 ? void 0 : g.event;
                    return x && ((h = r.ids) === null || h === void 0 ? void 0 : h.includes(x)) && (k === "*" || (k == null ? void 0 : k.toLocaleLowerCase()) === ((w = r.data) === null || w === void 0 ? void 0 : w.type.toLocaleLowerCase()))
                } else {
                    const x = (m = (v = p == null ? void 0 : p.filter) === null || v === void 0 ? void 0 : v.event) === null || m === void 0 ? void 0 : m.toLocaleLowerCase();
                    return x === "*" || x === ((_ = r == null ? void 0 : r.event) === null || _ === void 0 ? void 0 : _.toLocaleLowerCase())
                }
            else
                return p.type.toLocaleLowerCase() === o
        }
        ).map(p => {
            if (typeof f == "object" && "ids"in f) {
                const g = f.data
                  , {schema: h, table: w, commit_timestamp: v, type: m, errors: _} = g;
                f = Object.assign(Object.assign({}, {
                    schema: h,
                    table: w,
                    commit_timestamp: v,
                    eventType: m,
                    new: {},
                    old: {},
                    errors: _
                }), this._getPayloadRecords(g))
            }
            p.callback(f, n)
        }
        )
    }
    _isClosed() {
        return this.state === qe.closed
    }
    _isJoined() {
        return this.state === qe.joined
    }
    _isJoining() {
        return this.state === qe.joining
    }
    _isLeaving() {
        return this.state === qe.leaving
    }
    _replyEventName(e) {
        return `chan_reply_${e}`
    }
    _on(e, r, n) {
        const s = e.toLocaleLowerCase()
          , i = {
            type: s,
            filter: r,
            callback: n
        };
        return this.bindings[s] ? this.bindings[s].push(i) : this.bindings[s] = [i],
        this
    }
    _off(e, r) {
        const n = e.toLocaleLowerCase();
        return this.bindings[n] && (this.bindings[n] = this.bindings[n].filter(s => {
            var i;
            return !(((i = s.type) === null || i === void 0 ? void 0 : i.toLocaleLowerCase()) === n && pm.isEqual(s.filter, r))
        }
        )),
        this
    }
    static isEqual(e, r) {
        if (Object.keys(e).length !== Object.keys(r).length)
            return !1;
        for (const n in e)
            if (e[n] !== r[n])
                return !1;
        return !0
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(cr.close, {}, e)
    }
    _onError(e) {
        this._on(cr.error, {}, r => e(r))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = qe.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const r = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (r.new = $v(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (r.old = $v(e.columns, e.old_record)),
        r
    }
}
const Qd = () => {}
  , Jl = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , iA = [1e3, 2e3, 5e3, 1e4]
  , oA = 1e4
  , aA = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class lA {
    constructor(e, r) {
        var n;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = jh,
        this.transport = null,
        this.heartbeatIntervalMs = Jl.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = Qd,
        this.ref = 0,
        this.reconnectTimer = null,
        this.vsn = Lv,
        this.logger = Qd,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new JR,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._resolveFetch = s => s ? (...i) => s(...i) : (...i) => fetch(...i),
        !(!((n = r == null ? void 0 : r.params) === null || n === void 0) && n.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = r.params.apikey,
        this.endPoint = `${e}/${Nh.websocket}`,
        this.httpEndpoint = Hx(e),
        this._initializeOptions(r),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(r == null ? void 0 : r.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this.accessToken && !this._authPromise && this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = qR.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const r = e.message;
                    throw r.includes("Node.js") ? new Error(`${r}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${r}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: this.vsn
        }))
    }
    disconnect(e, r) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const n = setTimeout( () => {
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = () => {
                    clearTimeout(n),
                    this._setConnectionState("disconnected")
                }
                ,
                typeof this.conn.close == "function" && (e ? this.conn.close(e, r ?? "") : this.conn.close()),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const r = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        r
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(r => r.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, r, n) {
        this.logger(e, r, n)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case ys.connecting:
            return ws.Connecting;
        case ys.open:
            return ws.Open;
        case ys.closing:
            return ws.Closing;
        default:
            return ws.Closed
        }
    }
    isConnected() {
        return this.connectionState() === ws.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, r={
        config: {}
    }) {
        const n = `realtime:${e}`
          , s = this.getChannels().find(i => i.topic === n);
        if (s)
            return s;
        {
            const i = new pm(`realtime:${e}`,r,this);
            return this.channels.push(i),
            i
        }
    }
    push(e) {
        const {topic: r, event: n, payload: s, ref: i} = e
          , o = () => {
            this.encode(e, a => {
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${r} ${n} (${i})`, s),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(ZR, "heartbeat timeout"),
            setTimeout( () => {
                var r;
                this.isConnected() || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout()
            }
            , Jl.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (r) {
            this.log("error", "error in heartbeat callback", r)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let r = this.channels.find(n => n.topic === e && (n._isJoined() || n._isJoining()));
        r && (this.log("transport", `leaving duplicate topic "${e}"`),
        r.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(r => r.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, r => {
            if (r.topic === "phoenix" && r.event === "phx_reply")
                try {
                    this.heartbeatCallback(r.payload.status === "ok" ? "ok" : "error")
                } catch (u) {
                    this.log("error", "error in heartbeat callback", u)
                }
            r.ref && r.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null);
            const {topic: n, event: s, payload: i, ref: o} = r
              , a = o ? `(${o})` : ""
              , l = i.status || "";
            this.log("receive", `${l} ${n} ${s} ${a}`.trim(), i),
            this.channels.filter(u => u._isMember(n)).forEach(u => u._trigger(s, i, o)),
            this._triggerStateCallbacks("message", r)
        }
        )
    }
    _clearTimer(e) {
        var r;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((r = this.reconnectTimer) === null || r === void 0 || r.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = () => this._onConnOpen(),
        this.conn.onerror = e => this._onConnError(e),
        this.conn.onmessage = e => this._onConnMessage(e),
        this.conn.onclose = e => this._onConnClose(e))
    }
    _teardownConnection() {
        if (this.conn) {
            if (this.conn.readyState === ys.open || this.conn.readyState === ys.connecting)
                try {
                    this.conn.close()
                } catch (e) {
                    this.log("error", "Error closing connection", e)
                }
            this.conn.onopen = null,
            this.conn.onerror = null,
            this.conn.onmessage = null,
            this.conn.onclose = null,
            this.conn = null
        }
        this._clearAllTimers(),
        this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then( () => {
            this.flushSendBuffer()
        }
        ).catch(r => {
            this.log("error", "error waiting for auth on connect", r),
            this.flushSendBuffer()
        }
        ),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval( () => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = r => {
            this.log("worker", "worker error", r.message),
            this.workerRef.terminate()
        }
        ,
        this.workerRef.onmessage = r => {
            r.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _onConnClose(e) {
        var r;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e => e._trigger(cr.error))
    }
    _appendParams(e, r) {
        if (Object.keys(r).length === 0)
            return e;
        const n = e.match(/\?/) ? "&" : "?"
          , s = new URLSearchParams(r);
        return `${e}${n}${s}`
    }
    _workerObjectUrl(e) {
        let r;
        if (e)
            r = e;
        else {
            const n = new Blob([aA],{
                type: "application/javascript"
            });
            r = URL.createObjectURL(n)
        }
        return r
    }
    _setConnectionState(e, r=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = r)
    }
    async _performAuth(e=null) {
        let r;
        e ? r = e : this.accessToken ? r = await this.accessToken() : r = this.accessTokenValue,
        this.accessTokenValue != r && (this.accessTokenValue = r,
        this.channels.forEach(n => {
            const s = {
                access_token: r,
                version: GR
            };
            r && n.updateJoinPayload(s),
            n.joinedOnce && n._isJoined() && n._push(cr.access_token, {
                access_token: r
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this.setAuth().catch(r => {
            this.log("error", `error setting auth in ${e}`, r)
        }
        )
    }
    _triggerStateCallbacks(e, r) {
        try {
            this.stateChangeCallbacks[e].forEach(n => {
                try {
                    n(r)
                } catch (s) {
                    this.log("error", `error in ${e} callback`, s)
                }
            }
            )
        } catch (n) {
            this.log("error", `error triggering ${e} callbacks`, n)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new zx(async () => {
            setTimeout(async () => {
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , Jl.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var r, n, s, i, o, a, l, u, c, d, f, p;
        switch (this.transport = (r = e == null ? void 0 : e.transport) !== null && r !== void 0 ? r : null,
        this.timeout = (n = e == null ? void 0 : e.timeout) !== null && n !== void 0 ? n : jh,
        this.heartbeatIntervalMs = (s = e == null ? void 0 : e.heartbeatIntervalMs) !== null && s !== void 0 ? s : Jl.HEARTBEAT_INTERVAL,
        this.worker = (i = e == null ? void 0 : e.worker) !== null && i !== void 0 ? i : !1,
        this.accessToken = (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0 ? a : Qd,
        this.vsn = (l = e == null ? void 0 : e.vsn) !== null && l !== void 0 ? l : Lv,
        e != null && e.params && (this.params = e.params),
        e != null && e.logger && (this.logger = e.logger),
        (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (u = e == null ? void 0 : e.reconnectAfterMs) !== null && u !== void 0 ? u : g => iA[g - 1] || oA,
        this.vsn) {
        case Bx:
            this.encode = (c = e == null ? void 0 : e.encode) !== null && c !== void 0 ? c : (g, h) => h(JSON.stringify(g)),
            this.decode = (d = e == null ? void 0 : e.decode) !== null && d !== void 0 ? d : (g, h) => h(JSON.parse(g));
            break;
        case QR:
            this.encode = (f = e == null ? void 0 : e.encode) !== null && f !== void 0 ? f : this.serializer.encode.bind(this.serializer),
            this.decode = (p = e == null ? void 0 : e.decode) !== null && p !== void 0 ? p : this.serializer.decode.bind(this.serializer);
            break;
        default:
            throw new Error(`Unsupported serializer version: ${this.vsn}`)
        }
        if (this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e == null ? void 0 : e.workerUrl
        }
    }
}
class mm extends Error {
    constructor(e) {
        super(e),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
function je(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
class uA extends mm {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class Dh extends mm {
    constructor(e, r) {
        super(e),
        this.name = "StorageUnknownError",
        this.originalError = r
    }
}
const gm = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , cA = () => Response
  , Mh = t => {
    if (Array.isArray(t))
        return t.map(r => Mh(r));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach( ([r,n]) => {
        const s = r.replace(/([-_][a-z])/gi, i => i.toUpperCase().replace(/[-_]/g, ""));
        e[s] = Mh(n)
    }
    ),
    e
}
  , dA = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , Zd = t => {
    var e;
    return t.msg || t.message || t.error_description || (typeof t.error == "string" ? t.error : (e = t.error) === null || e === void 0 ? void 0 : e.message) || JSON.stringify(t)
}
  , fA = (t, e, r) => Z(void 0, void 0, void 0, function*() {
    const n = yield cA();
    t instanceof n && !(r != null && r.noResolveJson) ? t.json().then(s => {
        const i = t.status || 500
          , o = (s == null ? void 0 : s.statusCode) || i + "";
        e(new uA(Zd(s),i,o))
    }
    ).catch(s => {
        e(new Dh(Zd(s),s))
    }
    ) : e(new Dh(Zd(t),t))
})
  , hA = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" || !n ? s : (dA(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    e != null && e.duplex && (s.duplex = e.duplex),
    Object.assign(Object.assign({}, s), r))
}
;
function ml(t, e, r, n, s, i) {
    return Z(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(r, hA(e, n, s, i)).then(l => {
                if (!l.ok)
                    throw l;
                return n != null && n.noResolveJson ? l : l.json()
            }
            ).then(l => o(l)).catch(l => fA(l, a, n))
        }
        )
    })
}
function Ua(t, e, r, n) {
    return Z(this, void 0, void 0, function*() {
        return ml(t, "GET", e, r, n)
    })
}
function ar(t, e, r, n, s) {
    return Z(this, void 0, void 0, function*() {
        return ml(t, "POST", e, n, s, r)
    })
}
function Lh(t, e, r, n, s) {
    return Z(this, void 0, void 0, function*() {
        return ml(t, "PUT", e, n, s, r)
    })
}
function pA(t, e, r, n) {
    return Z(this, void 0, void 0, function*() {
        return ml(t, "HEAD", e, Object.assign(Object.assign({}, r), {
            noResolveJson: !0
        }), n)
    })
}
function vm(t, e, r, n, s) {
    return Z(this, void 0, void 0, function*() {
        return ml(t, "DELETE", e, n, s, r)
    })
}
class mA {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r
    }
    then(e, r) {
        return this.execute().then(e, r)
    }
    execute() {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield this.downloadFn()).body,
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (je(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
var qx;
class gA {
    constructor(e, r) {
        this.downloadFn = e,
        this.shouldThrowOnError = r,
        this[qx] = "BlobDownloadBuilder",
        this.promise = null
    }
    asStream() {
        return new mA(this.downloadFn,this.shouldThrowOnError)
    }
    then(e, r) {
        return this.getPromise().then(e, r)
    }
    catch(e) {
        return this.getPromise().catch(e)
    }
    finally(e) {
        return this.getPromise().finally(e)
    }
    getPromise() {
        return this.promise || (this.promise = this.execute()),
        this.promise
    }
    execute() {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield(yield this.downloadFn()).blob(),
                    error: null
                }
            } catch (e) {
                if (this.shouldThrowOnError)
                    throw e;
                if (je(e))
                    return {
                        data: null,
                        error: e
                    };
                throw e
            }
        })
    }
}
qx = Symbol.toStringTag;
const vA = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , Vv = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
class yA {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1,
        this.url = e,
        this.headers = r,
        this.bucketId = n,
        this.fetch = gm(s)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    uploadOrUpdate(e, r, n, s) {
        return Z(this, void 0, void 0, function*() {
            try {
                let i;
                const o = Object.assign(Object.assign({}, Vv), s);
                let a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
                    "x-upsert": String(o.upsert)
                });
                const l = o.metadata;
                typeof Blob < "u" && n instanceof Blob ? (i = new FormData,
                i.append("cacheControl", o.cacheControl),
                l && i.append("metadata", this.encodeMetadata(l)),
                i.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (i = n,
                i.has("cacheControl") || i.append("cacheControl", o.cacheControl),
                l && !i.has("metadata") && i.append("metadata", this.encodeMetadata(l))) : (i = n,
                a["cache-control"] = `max-age=${o.cacheControl}`,
                a["content-type"] = o.contentType,
                l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l))),
                (typeof ReadableStream < "u" && i instanceof ReadableStream || i && typeof i == "object" && "pipe"in i && typeof i.pipe == "function") && !o.duplex && (o.duplex = "half")),
                s != null && s.headers && (a = Object.assign(Object.assign({}, a), s.headers));
                const u = this._removeEmptyFolders(r)
                  , c = this._getFinalPath(u)
                  , d = yield(e == "PUT" ? Lh : ar)(this.fetch, `${this.url}/object/${c}`, i, Object.assign({
                    headers: a
                }, o != null && o.duplex ? {
                    duplex: o.duplex
                } : {}));
                return {
                    data: {
                        path: u,
                        id: d.Id,
                        fullPath: d.Key
                    },
                    error: null
                }
            } catch (i) {
                if (this.shouldThrowOnError)
                    throw i;
                if (je(i))
                    return {
                        data: null,
                        error: i
                    };
                throw i
            }
        })
    }
    upload(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("POST", e, r, n)
        })
    }
    uploadToSignedUrl(e, r, n, s) {
        return Z(this, void 0, void 0, function*() {
            const i = this._removeEmptyFolders(e)
              , o = this._getFinalPath(i)
              , a = new URL(this.url + `/object/upload/sign/${o}`);
            a.searchParams.set("token", r);
            try {
                let l;
                const u = Object.assign({
                    upsert: Vv.upsert
                }, s)
                  , c = Object.assign(Object.assign({}, this.headers), {
                    "x-upsert": String(u.upsert)
                });
                typeof Blob < "u" && n instanceof Blob ? (l = new FormData,
                l.append("cacheControl", u.cacheControl),
                l.append("", n)) : typeof FormData < "u" && n instanceof FormData ? (l = n,
                l.append("cacheControl", u.cacheControl)) : (l = n,
                c["cache-control"] = `max-age=${u.cacheControl}`,
                c["content-type"] = u.contentType);
                const d = yield Lh(this.fetch, a.toString(), l, {
                    headers: c
                });
                return {
                    data: {
                        path: i,
                        fullPath: d.Key
                    },
                    error: null
                }
            } catch (l) {
                if (this.shouldThrowOnError)
                    throw l;
                if (je(l))
                    return {
                        data: null,
                        error: l
                    };
                throw l
            }
        })
    }
    createSignedUploadUrl(e, r) {
        return Z(this, void 0, void 0, function*() {
            try {
                let n = this._getFinalPath(e);
                const s = Object.assign({}, this.headers);
                r != null && r.upsert && (s["x-upsert"] = "true");
                const i = yield ar(this.fetch, `${this.url}/object/upload/sign/${n}`, {}, {
                    headers: s
                })
                  , o = new URL(this.url + i.url)
                  , a = o.searchParams.get("token");
                if (!a)
                    throw new mm("No token returned by API");
                return {
                    data: {
                        signedUrl: o.toString(),
                        path: e,
                        token: a
                    },
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (je(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    update(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            return this.uploadOrUpdate("PUT", e, r, n)
        })
    }
    move(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ar(this.fetch, `${this.url}/object/move`, {
                        bucketId: this.bucketId,
                        sourceKey: e,
                        destinationKey: r,
                        destinationBucket: n == null ? void 0 : n.destinationBucket
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    copy(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: {
                        path: (yield ar(this.fetch, `${this.url}/object/copy`, {
                            bucketId: this.bucketId,
                            sourceKey: e,
                            destinationKey: r,
                            destinationBucket: n == null ? void 0 : n.destinationBucket
                        }, {
                            headers: this.headers
                        })).Key
                    },
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrl(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            try {
                let s = this._getFinalPath(e)
                  , i = yield ar(this.fetch, `${this.url}/object/sign/${s}`, Object.assign({
                    expiresIn: r
                }, n != null && n.transform ? {
                    transform: n.transform
                } : {}), {
                    headers: this.headers
                });
                const o = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return i = {
                    signedUrl: encodeURI(`${this.url}${i.signedURL}${o}`)
                },
                {
                    data: i,
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    createSignedUrls(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            try {
                const s = yield ar(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
                    expiresIn: r,
                    paths: e
                }, {
                    headers: this.headers
                })
                  , i = n != null && n.download ? `&download=${n.download === !0 ? "" : n.download}` : "";
                return {
                    data: s.map(o => Object.assign(Object.assign({}, o), {
                        signedUrl: o.signedURL ? encodeURI(`${this.url}${o.signedURL}${i}`) : null
                    })),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    download(e, r) {
        const s = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image/authenticated" : "object"
          , i = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {})
          , o = i ? `?${i}` : ""
          , a = this._getFinalPath(e)
          , l = () => Ua(this.fetch, `${this.url}/${s}/${a}${o}`, {
            headers: this.headers,
            noResolveJson: !0
        });
        return new gA(l,this.shouldThrowOnError)
    }
    info(e) {
        return Z(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                const n = yield Ua(this.fetch, `${this.url}/object/info/${r}`, {
                    headers: this.headers
                });
                return {
                    data: Mh(n),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (je(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    exists(e) {
        return Z(this, void 0, void 0, function*() {
            const r = this._getFinalPath(e);
            try {
                return yield pA(this.fetch, `${this.url}/object/${r}`, {
                    headers: this.headers
                }),
                {
                    data: !0,
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (je(n) && n instanceof Dh) {
                    const s = n.originalError;
                    if ([400, 404].includes(s == null ? void 0 : s.status))
                        return {
                            data: !1,
                            error: n
                        }
                }
                throw n
            }
        })
    }
    getPublicUrl(e, r) {
        const n = this._getFinalPath(e)
          , s = []
          , i = r != null && r.download ? `download=${r.download === !0 ? "" : r.download}` : "";
        i !== "" && s.push(i);
        const a = typeof (r == null ? void 0 : r.transform) < "u" ? "render/image" : "object"
          , l = this.transformOptsToQueryString((r == null ? void 0 : r.transform) || {});
        l !== "" && s.push(l);
        let u = s.join("&");
        return u !== "" && (u = `?${u}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${a}/public/${n}${u}`)
            }
        }
    }
    remove(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield vm(this.fetch, `${this.url}/object/${this.bucketId}`, {
                        prefixes: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    list(e, r, n) {
        return Z(this, void 0, void 0, function*() {
            try {
                const s = Object.assign(Object.assign(Object.assign({}, vA), r), {
                    prefix: e || ""
                });
                return {
                    data: yield ar(this.fetch, `${this.url}/object/list/${this.bucketId}`, s, {
                        headers: this.headers
                    }, n),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    listV2(e, r) {
        return Z(this, void 0, void 0, function*() {
            try {
                const n = Object.assign({}, e);
                return {
                    data: yield ar(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, n, {
                        headers: this.headers
                    }, r),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (je(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    encodeMetadata(e) {
        return JSON.stringify(e)
    }
    toBase64(e) {
        return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e)
    }
    _getFinalPath(e) {
        return `${this.bucketId}/${e.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(e) {
        return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(e) {
        const r = [];
        return e.width && r.push(`width=${e.width}`),
        e.height && r.push(`height=${e.height}`),
        e.resize && r.push(`resize=${e.resize}`),
        e.format && r.push(`format=${e.format}`),
        e.quality && r.push(`quality=${e.quality}`),
        r.join("&")
    }
}
const Kx = "2.84.0"
  , Gx = {
    "X-Client-Info": `storage-js/${Kx}`
};
class wA {
    constructor(e, r={}, n, s) {
        this.shouldThrowOnError = !1;
        const i = new URL(e);
        s != null && s.useNewHostname && /supabase\.(co|in|red)$/.test(i.hostname) && !i.hostname.includes("storage.supabase.") && (i.hostname = i.hostname.replace("supabase.", "storage.supabase.")),
        this.url = i.href.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Gx), r),
        this.fetch = gm(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    listBuckets(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                const r = this.listBucketOptionsToQueryString(e);
                return {
                    data: yield Ua(this.fetch, `${this.url}/bucket${r}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Ua(this.fetch, `${this.url}/bucket/${e}`, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    createBucket(e) {
        return Z(this, arguments, void 0, function*(r, n={
            public: !1
        }) {
            try {
                return {
                    data: yield ar(this.fetch, `${this.url}/bucket`, {
                        id: r,
                        name: r,
                        type: n.type,
                        public: n.public,
                        file_size_limit: n.fileSizeLimit,
                        allowed_mime_types: n.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (s) {
                if (this.shouldThrowOnError)
                    throw s;
                if (je(s))
                    return {
                        data: null,
                        error: s
                    };
                throw s
            }
        })
    }
    updateBucket(e, r) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield Lh(this.fetch, `${this.url}/bucket/${e}`, {
                        id: e,
                        name: e,
                        public: r.public,
                        file_size_limit: r.fileSizeLimit,
                        allowed_mime_types: r.allowedMimeTypes
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (je(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    emptyBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ar(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield vm(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBucketOptionsToQueryString(e) {
        const r = {};
        return e && ("limit"in e && (r.limit = String(e.limit)),
        "offset"in e && (r.offset = String(e.offset)),
        e.search && (r.search = e.search),
        e.sortColumn && (r.sortColumn = e.sortColumn),
        e.sortOrder && (r.sortOrder = e.sortOrder)),
        Object.keys(r).length > 0 ? "?" + new URLSearchParams(r).toString() : ""
    }
}
class _A {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, Gx), r),
        this.fetch = gm(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield ar(this.fetch, `${this.url}/bucket`, {
                        name: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                const r = new URLSearchParams;
                (e == null ? void 0 : e.limit) !== void 0 && r.set("limit", e.limit.toString()),
                (e == null ? void 0 : e.offset) !== void 0 && r.set("offset", e.offset.toString()),
                e != null && e.sortColumn && r.set("sortColumn", e.sortColumn),
                e != null && e.sortOrder && r.set("sortOrder", e.sortOrder),
                e != null && e.search && r.set("search", e.search);
                const n = r.toString()
                  , s = n ? `${this.url}/bucket?${n}` : `${this.url}/bucket`;
                return {
                    data: yield Ua(this.fetch, s, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield vm(this.fetch, `${this.url}/bucket/${e}`, {}, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (je(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
const ym = {
    "X-Client-Info": `storage-js/${Kx}`,
    "Content-Type": "application/json"
};
class Qx extends Error {
    constructor(e) {
        super(e),
        this.__isStorageVectorsError = !0,
        this.name = "StorageVectorsError"
    }
}
function Lt(t) {
    return typeof t == "object" && t !== null && "__isStorageVectorsError"in t
}
class Yd extends Qx {
    constructor(e, r, n) {
        super(e),
        this.name = "StorageVectorsApiError",
        this.status = r,
        this.statusCode = n
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
class bA extends Qx {
    constructor(e, r) {
        super(e),
        this.name = "StorageVectorsUnknownError",
        this.originalError = r
    }
}
var Bv;
(function(t) {
    t.InternalError = "InternalError",
    t.S3VectorConflictException = "S3VectorConflictException",
    t.S3VectorNotFoundException = "S3VectorNotFoundException",
    t.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty",
    t.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded",
    t.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded"
}
)(Bv || (Bv = {}));
const wm = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , xA = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , zv = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , SA = (t, e, r) => Z(void 0, void 0, void 0, function*() {
    if (t && typeof t == "object" && "status"in t && "ok"in t && typeof t.status == "number" && !(r != null && r.noResolveJson)) {
        const s = t.status || 500
          , i = t;
        if (typeof i.json == "function")
            i.json().then(o => {
                const a = (o == null ? void 0 : o.statusCode) || (o == null ? void 0 : o.code) || s + "";
                e(new Yd(zv(o),s,a))
            }
            ).catch( () => {
                const o = s + ""
                  , a = i.statusText || `HTTP ${s} error`;
                e(new Yd(a,s,o))
            }
            );
        else {
            const o = s + ""
              , a = i.statusText || `HTTP ${s} error`;
            e(new Yd(a,s,o))
        }
    } else
        e(new bA(zv(t),t))
})
  , EA = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return n ? (xA(n) ? (s.headers = Object.assign({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    Object.assign(Object.assign({}, s), r)) : s
}
;
function kA(t, e, r, n, s, i) {
    return Z(this, void 0, void 0, function*() {
        return new Promise( (o, a) => {
            t(r, EA(e, n, s, i)).then(l => {
                if (!l.ok)
                    throw l;
                if (n != null && n.noResolveJson)
                    return l;
                const u = l.headers.get("content-type");
                return !u || !u.includes("application/json") ? {} : l.json()
            }
            ).then(l => o(l)).catch(l => SA(l, a, n))
        }
        )
    })
}
function $t(t, e, r, n, s) {
    return Z(this, void 0, void 0, function*() {
        return kA(t, "POST", e, n, s, r)
    })
}
class CA {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, ym), r),
        this.fetch = wm(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createIndex(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield $t(this.fetch, `${this.url}/CreateIndex`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getIndex(e, r) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/GetIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Lt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
    listIndexes(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/ListIndexes`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteIndex(e, r) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield $t(this.fetch, `${this.url}/DeleteIndex`, {
                        vectorBucketName: e,
                        indexName: r
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (n) {
                if (this.shouldThrowOnError)
                    throw n;
                if (Lt(n))
                    return {
                        data: null,
                        error: n
                    };
                throw n
            }
        })
    }
}
class TA {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, ym), r),
        this.fetch = wm(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    putVectors(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                if (e.vectors.length < 1 || e.vectors.length > 500)
                    throw new Error("Vector batch size must be between 1 and 500 items");
                return {
                    data: (yield $t(this.fetch, `${this.url}/PutVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getVectors(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/GetVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listVectors(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                if (e.segmentCount !== void 0) {
                    if (e.segmentCount < 1 || e.segmentCount > 16)
                        throw new Error("segmentCount must be between 1 and 16");
                    if (e.segmentIndex !== void 0 && (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount))
                        throw new Error(`segmentIndex must be between 0 and ${e.segmentCount - 1}`)
                }
                return {
                    data: yield $t(this.fetch, `${this.url}/ListVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    queryVectors(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/QueryVectors`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteVectors(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                if (e.keys.length < 1 || e.keys.length > 500)
                    throw new Error("Keys batch size must be between 1 and 500 items");
                return {
                    data: (yield $t(this.fetch, `${this.url}/DeleteVectors`, e, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class OA {
    constructor(e, r={}, n) {
        this.shouldThrowOnError = !1,
        this.url = e.replace(/\/$/, ""),
        this.headers = Object.assign(Object.assign({}, ym), r),
        this.fetch = wm(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    createBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield $t(this.fetch, `${this.url}/CreateVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    getBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/GetVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    listBuckets() {
        return Z(this, arguments, void 0, function*(e={}) {
            try {
                return {
                    data: yield $t(this.fetch, `${this.url}/ListVectorBuckets`, e, {
                        headers: this.headers
                    }),
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
    deleteBucket(e) {
        return Z(this, void 0, void 0, function*() {
            try {
                return {
                    data: (yield $t(this.fetch, `${this.url}/DeleteVectorBucket`, {
                        vectorBucketName: e
                    }, {
                        headers: this.headers
                    })) || {},
                    error: null
                }
            } catch (r) {
                if (this.shouldThrowOnError)
                    throw r;
                if (Lt(r))
                    return {
                        data: null,
                        error: r
                    };
                throw r
            }
        })
    }
}
class PA extends OA {
    constructor(e, r={}) {
        super(e, r.headers || {}, r.fetch)
    }
    from(e) {
        return new RA(this.url,this.headers,e,this.fetch)
    }
}
class RA extends CA {
    constructor(e, r, n, s) {
        super(e, r, s),
        this.vectorBucketName = n
    }
    createIndex(e) {
        const r = Object.create(null, {
            createIndex: {
                get: () => super.createIndex
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.createIndex.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    listIndexes() {
        const e = Object.create(null, {
            listIndexes: {
                get: () => super.listIndexes
            }
        });
        return Z(this, arguments, void 0, function*(r={}) {
            return e.listIndexes.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName
            }))
        })
    }
    getIndex(e) {
        const r = Object.create(null, {
            getIndex: {
                get: () => super.getIndex
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.getIndex.call(this, this.vectorBucketName, e)
        })
    }
    deleteIndex(e) {
        const r = Object.create(null, {
            deleteIndex: {
                get: () => super.deleteIndex
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.deleteIndex.call(this, this.vectorBucketName, e)
        })
    }
    index(e) {
        return new AA(this.url,this.headers,this.vectorBucketName,e,this.fetch)
    }
}
class AA extends TA {
    constructor(e, r, n, s, i) {
        super(e, r, i),
        this.vectorBucketName = n,
        this.indexName = s
    }
    putVectors(e) {
        const r = Object.create(null, {
            putVectors: {
                get: () => super.putVectors
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.putVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    getVectors(e) {
        const r = Object.create(null, {
            getVectors: {
                get: () => super.getVectors
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.getVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    listVectors() {
        const e = Object.create(null, {
            listVectors: {
                get: () => super.listVectors
            }
        });
        return Z(this, arguments, void 0, function*(r={}) {
            return e.listVectors.call(this, Object.assign(Object.assign({}, r), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    queryVectors(e) {
        const r = Object.create(null, {
            queryVectors: {
                get: () => super.queryVectors
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.queryVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
    deleteVectors(e) {
        const r = Object.create(null, {
            deleteVectors: {
                get: () => super.deleteVectors
            }
        });
        return Z(this, void 0, void 0, function*() {
            return r.deleteVectors.call(this, Object.assign(Object.assign({}, e), {
                vectorBucketName: this.vectorBucketName,
                indexName: this.indexName
            }))
        })
    }
}
class jA extends wA {
    constructor(e, r={}, n, s) {
        super(e, r, n, s)
    }
    from(e) {
        return new yA(this.url,this.headers,e,this.fetch)
    }
    get vectors() {
        return new PA(this.url + "/vector",{
            headers: this.headers,
            fetch: this.fetch
        })
    }
    get analytics() {
        return new _A(this.url + "/iceberg",this.headers,this.fetch)
    }
}
const NA = "2.84.0";
let ra = "";
typeof Deno < "u" ? ra = "deno" : typeof document < "u" ? ra = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? ra = "react-native" : ra = "node";
const IA = {
    "X-Client-Info": `supabase-js-${ra}/${NA}`
}
  , DA = {
    headers: IA
}
  , MA = {
    schema: "public"
}
  , LA = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
}
  , $A = {}
  , FA = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , UA = () => Headers
  , VA = (t, e, r) => {
    const n = FA(r)
      , s = UA();
    return async (i, o) => {
        var a;
        const l = (a = await e()) !== null && a !== void 0 ? a : t;
        let u = new s(o == null ? void 0 : o.headers);
        return u.has("apikey") || u.set("apikey", t),
        u.has("Authorization") || u.set("Authorization", `Bearer ${l}`),
        n(i, Object.assign(Object.assign({}, o), {
            headers: u
        }))
    }
}
;
function BA(t) {
    return t.endsWith("/") ? t : t + "/"
}
function zA(t, e) {
    var r, n;
    const {db: s, auth: i, realtime: o, global: a} = t
      , {db: l, auth: u, realtime: c, global: d} = e
      , f = {
        db: Object.assign(Object.assign({}, l), s),
        auth: Object.assign(Object.assign({}, u), i),
        realtime: Object.assign(Object.assign({}, c), o),
        storage: {},
        global: Object.assign(Object.assign(Object.assign({}, d), a), {
            headers: Object.assign(Object.assign({}, (r = d == null ? void 0 : d.headers) !== null && r !== void 0 ? r : {}), (n = a == null ? void 0 : a.headers) !== null && n !== void 0 ? n : {})
        }),
        accessToken: async () => ""
    };
    return t.accessToken ? f.accessToken = t.accessToken : delete f.accessToken,
    f
}
function WA(t) {
    const e = t == null ? void 0 : t.trim();
    if (!e)
        throw new Error("supabaseUrl is required.");
    if (!e.match(/^https?:\/\//i))
        throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    try {
        return new URL(BA(e))
    } catch {
        throw Error("Invalid supabaseUrl: Provided URL is malformed.")
    }
}
const Zx = "2.84.0"
  , fi = 30 * 1e3
  , $h = 3
  , Jd = $h * fi
  , HA = "http://localhost:9999"
  , qA = "supabase.auth.token"
  , KA = {
    "X-Client-Info": `gotrue-js/${Zx}`
}
  , Fh = "X-Supabase-Api-Version"
  , Yx = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , GA = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , QA = 10 * 60 * 1e3;
class Va extends Error {
    constructor(e, r, n) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = r,
        this.code = n
    }
}
function J(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
class ZA extends Va {
    constructor(e, r, n) {
        super(e, r, n),
        this.name = "AuthApiError",
        this.status = r,
        this.code = n
    }
}
function YA(t) {
    return J(t) && t.name === "AuthApiError"
}
class _s extends Va {
    constructor(e, r) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = r
    }
}
class as extends Va {
    constructor(e, r, n, s) {
        super(e, n, s),
        this.name = r,
        this.status = n
    }
}
class jt extends as {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
function JA(t) {
    return J(t) && t.name === "AuthSessionMissingError"
}
class ri extends as {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
class Xl extends as {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
class eu extends as {
    constructor(e, r=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
function XA(t) {
    return J(t) && t.name === "AuthImplicitGrantRedirectError"
}
class Wv extends as {
    constructor(e, r=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
class Uh extends as {
    constructor(e, r) {
        super(e, "AuthRetryableFetchError", r, void 0)
    }
}
function Xd(t) {
    return J(t) && t.name === "AuthRetryableFetchError"
}
class Hv extends as {
    constructor(e, r, n) {
        super(e, "AuthWeakPasswordError", r, "weak_password"),
        this.reasons = n
    }
}
class Vh extends as {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
const oc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , qv = ` 	
\r=`.split("")
  , ej = ( () => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < qv.length; e += 1)
        t[qv[e].charCodeAt(0)] = -2;
    for (let e = 0; e < oc.length; e += 1)
        t[oc[e].charCodeAt(0)] = e;
    return t
}
)();
function Kv(t, e, r) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(oc[n]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(oc[n]),
            e.queuedBits -= 6
        }
}
function Jx(t, e, r) {
    const n = ej[t];
    if (n > -1)
        for (e.queue = e.queue << 6 | n,
        e.queuedBits += 6; e.queuedBits >= 8; )
            r(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (n === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function Gv(t) {
    const e = []
      , r = o => {
        e.push(String.fromCodePoint(o))
    }
      , n = {
        utf8seq: 0,
        codepoint: 0
    }
      , s = {
        queue: 0,
        queuedBits: 0
    }
      , i = o => {
        nj(o, n, r)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        Jx(t.charCodeAt(o), s, i);
    return e.join("")
}
function tj(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function rj(t, e) {
    for (let r = 0; r < t.length; r += 1) {
        let n = t.charCodeAt(r);
        if (n > 55295 && n <= 56319) {
            const s = (n - 55296) * 1024 & 65535;
            n = (t.charCodeAt(r + 1) - 56320 & 65535 | s) + 65536,
            r += 1
        }
        tj(n, e)
    }
}
function nj(t, e, r) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            r(t);
            return
        }
        for (let n = 1; n < 6; n += 1)
            if (!(t >> 7 - n & 1)) {
                e.utf8seq = n;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && r(e.codepoint)
    }
}
function Bi(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    for (let s = 0; s < t.length; s += 1)
        Jx(t.charCodeAt(s), r, n);
    return new Uint8Array(e)
}
function sj(t) {
    const e = [];
    return rj(t, r => e.push(r)),
    new Uint8Array(e)
}
function Es(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    return t.forEach(s => Kv(s, r, n)),
    Kv(null, r, n),
    e.join("")
}
function ij(t) {
    return Math.round(Date.now() / 1e3) + t
}
function oj() {
    return Symbol("auth-callback")
}
const Xe = () => typeof window < "u" && typeof document < "u"
  , ds = {
    tested: !1,
    writable: !1
}
  , Xx = () => {
    if (!Xe())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (ds.tested)
        return ds.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        ds.tested = !0,
        ds.writable = !0
    } catch {
        ds.tested = !0,
        ds.writable = !1
    }
    return ds.writable
}
;
function aj(t) {
    const e = {}
      , r = new URL(t);
    if (r.hash && r.hash[0] === "#")
        try {
            new URLSearchParams(r.hash.substring(1)).forEach( (s, i) => {
                e[i] = s
            }
            )
        } catch {}
    return r.searchParams.forEach( (n, s) => {
        e[s] = n
    }
    ),
    e
}
const eS = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , lj = t => typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , hi = async (t, e, r) => {
    await t.setItem(e, JSON.stringify(r))
}
  , fs = async (t, e) => {
    const r = await t.getItem(e);
    if (!r)
        return null;
    try {
        return JSON.parse(r)
    } catch {
        return r
    }
}
  , yn = async (t, e) => {
    await t.removeItem(e)
}
;
class td {
    constructor() {
        this.promise = new td.promiseConstructor( (e, r) => {
            this.resolve = e,
            this.reject = r
        }
        )
    }
}
td.promiseConstructor = Promise;
function ef(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new Vh("Invalid JWT structure");
    for (let n = 0; n < e.length; n++)
        if (!GA.test(e[n]))
            throw new Vh("JWT not in base64url format");
    return {
        header: JSON.parse(Gv(e[0])),
        payload: JSON.parse(Gv(e[1])),
        signature: Bi(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function uj(t) {
    return await new Promise(e => {
        setTimeout( () => e(null), t)
    }
    )
}
function cj(t, e) {
    return new Promise( (n, s) => {
        (async () => {
            for (let i = 0; i < 1 / 0; i++)
                try {
                    const o = await t(i);
                    if (!e(i, null, o)) {
                        n(o);
                        return
                    }
                } catch (o) {
                    if (!e(i, o)) {
                        s(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function dj(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function fj() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , n = r.length;
        let s = "";
        for (let i = 0; i < 56; i++)
            s += r.charAt(Math.floor(Math.random() * n));
        return s
    }
    return crypto.getRandomValues(e),
    Array.from(e, dj).join("")
}
async function hj(t) {
    const r = new TextEncoder().encode(t)
      , n = await crypto.subtle.digest("SHA-256", r)
      , s = new Uint8Array(n);
    return Array.from(s).map(i => String.fromCharCode(i)).join("")
}
async function pj(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const r = await hj(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function ni(t, e, r=!1) {
    const n = fj();
    let s = n;
    r && (s += "/PASSWORD_RECOVERY"),
    await hi(t, `${e}-code-verifier`, s);
    const i = await pj(n);
    return [i, n === i ? "plain" : "s256"]
}
const mj = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function gj(t) {
    const e = t.headers.get(Fh);
    if (!e || !e.match(mj))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function vj(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function yj(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const wj = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function si(t) {
    if (!wj.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function tf() {
    const t = {};
    return new Proxy(t,{
        get: (e, r) => {
            if (r === "__isUserNotAvailableProxy")
                return !0;
            if (typeof r == "symbol") {
                const n = r.toString();
                if (n === "Symbol(Symbol.toPrimitive)" || n === "Symbol(Symbol.toStringTag)" || n === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${r}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function _j(t, e) {
    return new Proxy(t,{
        get: (r, n, s) => {
            if (n === "__isInsecureUserWarningProxy")
                return !0;
            if (typeof n == "symbol") {
                const i = n.toString();
                if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)" || i === "Symbol(nodejs.util.inspect.custom)")
                    return Reflect.get(r, n, s)
            }
            return !e.value && typeof n == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
            e.value = !0),
            Reflect.get(r, n, s)
        }
    })
}
function Qv(t) {
    return JSON.parse(JSON.stringify(t))
}
const gs = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , bj = [502, 503, 504];
async function Zv(t) {
    var e;
    if (!lj(t))
        throw new Uh(gs(t),0);
    if (bj.includes(t.status))
        throw new Uh(gs(t),t.status);
    let r;
    try {
        r = await t.json()
    } catch (i) {
        throw new _s(gs(i),i)
    }
    let n;
    const s = gj(t);
    if (s && s.getTime() >= Yx["2024-01-01"].timestamp && typeof r == "object" && r && typeof r.code == "string" ? n = r.code : typeof r == "object" && r && typeof r.error_code == "string" && (n = r.error_code),
    n) {
        if (n === "weak_password")
            throw new Hv(gs(r),t.status,((e = r.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (n === "session_not_found")
            throw new jt
    } else if (typeof r == "object" && r && typeof r.weak_password == "object" && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce( (i, o) => i && typeof o == "string", !0))
        throw new Hv(gs(r),t.status,r.weak_password.reasons);
    throw new ZA(gs(r),t.status || 500,n)
}
const xj = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? s : (s.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n),
    Object.assign(Object.assign({}, s), r))
}
;
async function re(t, e, r, n) {
    var s;
    const i = Object.assign({}, n == null ? void 0 : n.headers);
    i[Fh] || (i[Fh] = Yx["2024-01-01"].name),
    n != null && n.jwt && (i.Authorization = `Bearer ${n.jwt}`);
    const o = (s = n == null ? void 0 : n.query) !== null && s !== void 0 ? s : {};
    n != null && n.redirectTo && (o.redirect_to = n.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await Sj(t, e, r + a, {
        headers: i,
        noResolveJson: n == null ? void 0 : n.noResolveJson
    }, {}, n == null ? void 0 : n.body);
    return n != null && n.xform ? n == null ? void 0 : n.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function Sj(t, e, r, n, s, i) {
    const o = xj(e, n, s, i);
    let a;
    try {
        a = await t(r, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new Uh(gs(l),0)
    }
    if (a.ok || await Zv(a),
    n != null && n.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await Zv(l)
    }
}
function ir(t) {
    var e;
    let r = null;
    Cj(t) && (r = Object.assign({}, t),
    t.expires_at || (r.expires_at = ij(t.expires_in)));
    const n = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: r,
            user: n
        },
        error: null
    }
}
function Yv(t) {
    const e = ir(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce( (r, n) => r && typeof n == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function Cn(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function Ej(t) {
    return {
        data: t,
        error: null
    }
}
function kj(t) {
    const {action_link: e, email_otp: r, hashed_token: n, redirect_to: s, verification_type: i} = t
      , o = os(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: r,
        hashed_token: n,
        redirect_to: s,
        verification_type: i
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function Jv(t) {
    return t
}
function Cj(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const rf = ["global", "local", "others"];
class Tj {
    constructor({url: e="", headers: r={}, fetch: n}) {
        this.url = e,
        this.headers = r,
        this.fetch = eS(n),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        },
        this.oauth = {
            listClients: this._listOAuthClients.bind(this),
            createClient: this._createOAuthClient.bind(this),
            getClient: this._getOAuthClient.bind(this),
            updateClient: this._updateOAuthClient.bind(this),
            deleteClient: this._deleteOAuthClient.bind(this),
            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
        }
    }
    async signOut(e, r=rf[0]) {
        if (rf.indexOf(r) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${rf.join(", ")}`);
        try {
            return await re(this.fetch, "POST", `${this.url}/logout?scope=${r}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (n) {
            if (J(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async inviteUserByEmail(e, r={}) {
        try {
            return await re(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: r.data
                },
                headers: this.headers,
                redirectTo: r.redirectTo,
                xform: Cn
            })
        } catch (n) {
            if (J(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async generateLink(e) {
        try {
            const {options: r} = e
              , n = os(e, ["options"])
              , s = Object.assign(Object.assign({}, n), r);
            return "newEmail"in n && (s.new_email = n == null ? void 0 : n.newEmail,
            delete s.newEmail),
            await re(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: s,
                headers: this.headers,
                xform: kj,
                redirectTo: r == null ? void 0 : r.redirectTo
            })
        } catch (r) {
            if (J(r))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async createUser(e) {
        try {
            return await re(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: Cn
            })
        } catch (r) {
            if (J(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async listUsers(e) {
        var r, n, s, i, o, a, l;
        try {
            const u = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , c = await re(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: Jv
            });
            if (c.error)
                throw c.error;
            const d = await c.json()
              , f = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , p = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return p.length > 0 && (p.forEach(g => {
                const h = parseInt(g.split(";")[0].split("=")[1].substring(0, 1))
                  , w = JSON.parse(g.split(";")[1].split("=")[1]);
                u[`${w}Page`] = h
            }
            ),
            u.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, d), u),
                error: null
            }
        } catch (u) {
            if (J(u))
                return {
                    data: {
                        users: []
                    },
                    error: u
                };
            throw u
        }
    }
    async getUserById(e) {
        si(e);
        try {
            return await re(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: Cn
            })
        } catch (r) {
            if (J(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async updateUserById(e, r) {
        si(e);
        try {
            return await re(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: r,
                headers: this.headers,
                xform: Cn
            })
        } catch (n) {
            if (J(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async deleteUser(e, r=!1) {
        si(e);
        try {
            return await re(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: r
                },
                xform: Cn
            })
        } catch (n) {
            if (J(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _listFactors(e) {
        si(e.userId);
        try {
            const {data: r, error: n} = await re(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: s => ({
                    data: {
                        factors: s
                    },
                    error: null
                })
            });
            return {
                data: r,
                error: n
            }
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _deleteFactor(e) {
        si(e.userId),
        si(e.id);
        try {
            return {
                data: await re(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _listOAuthClients(e) {
        var r, n, s, i, o, a, l;
        try {
            const u = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , c = await re(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: Jv
            });
            if (c.error)
                throw c.error;
            const d = await c.json()
              , f = (o = c.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , p = (l = (a = c.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return p.length > 0 && (p.forEach(g => {
                const h = parseInt(g.split(";")[0].split("=")[1].substring(0, 1))
                  , w = JSON.parse(g.split(";")[1].split("=")[1]);
                u[`${w}Page`] = h
            }
            ),
            u.total = parseInt(f)),
            {
                data: Object.assign(Object.assign({}, d), u),
                error: null
            }
        } catch (u) {
            if (J(u))
                return {
                    data: {
                        clients: []
                    },
                    error: u
                };
            throw u
        }
    }
    async _createOAuthClient(e) {
        try {
            return await re(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
                body: e,
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _getOAuthClient(e) {
        try {
            return await re(this.fetch, "GET", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _updateOAuthClient(e, r) {
        try {
            return await re(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${e}`, {
                body: r,
                headers: this.headers,
                xform: n => ({
                    data: n,
                    error: null
                })
            })
        } catch (n) {
            if (J(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteOAuthClient(e) {
        try {
            return await re(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _regenerateOAuthClientSecret(e) {
        try {
            return await re(this.fetch, "POST", `${this.url}/admin/oauth/clients/${e}/regenerate_secret`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (J(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
function Xv(t={}) {
    return {
        getItem: e => t[e] || null,
        setItem: (e, r) => {
            t[e] = r
        }
        ,
        removeItem: e => {
            delete t[e]
        }
    }
}
const ii = {
    debug: !!(globalThis && Xx() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class tS extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
class Oj extends tS {
}
async function Pj(t, e, r) {
    ii.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const n = new globalThis.AbortController;
    return e > 0 && setTimeout( () => {
        n.abort(),
        ii.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then( () => globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: n.signal
    }, async s => {
        if (s) {
            ii.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, s.name);
            try {
                return await r()
            } finally {
                ii.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, s.name)
            }
        } else {
            if (e === 0)
                throw ii.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new Oj(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (ii.debug)
                try {
                    const i = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(i, null, "  "))
                } catch (i) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", i)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await r()
        }
    }
    ))
}
function Rj() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
function rS(t) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(t))
        throw new Error(`@supabase/auth-js: Address "${t}" is invalid.`);
    return t.toLowerCase()
}
function Aj(t) {
    return parseInt(t, 16)
}
function jj(t) {
    const e = new TextEncoder().encode(t);
    return "0x" + Array.from(e, n => n.toString(16).padStart(2, "0")).join("")
}
function Nj(t) {
    var e;
    const {chainId: r, domain: n, expirationTime: s, issuedAt: i=new Date, nonce: o, notBefore: a, requestId: l, resources: u, scheme: c, uri: d, version: f} = t;
    {
        if (!Number.isInteger(r))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`);
        if (!n)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
        if (o && o.length < 8)
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);
        if (!d)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
        if (f !== "1")
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${f}`);
        if (!((e = t.statement) === null || e === void 0) && e.includes(`
`))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${t.statement}`)
    }
    const p = rS(t.address)
      , g = c ? `${c}://${n}` : n
      , h = t.statement ? `${t.statement}
` : ""
      , w = `${g} wants you to sign in with your Ethereum account:
${p}

${h}`;
    let v = `URI: ${d}
Version: ${f}
Chain ID: ${r}${o ? `
Nonce: ${o}` : ""}
Issued At: ${i.toISOString()}`;
    if (s && (v += `
Expiration Time: ${s.toISOString()}`),
    a && (v += `
Not Before: ${a.toISOString()}`),
    l && (v += `
Request ID: ${l}`),
    u) {
        let m = `
Resources:`;
        for (const _ of u) {
            if (!_ || typeof _ != "string")
                throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${_}`);
            m += `
- ${_}`
        }
        v += m
    }
    return `${w}
${v}`
}
class We extends Error {
    constructor({message: e, code: r, cause: n, name: s}) {
        var i;
        super(e, {
            cause: n
        }),
        this.__isWebAuthnError = !0,
        this.name = (i = s ?? (n instanceof Error ? n.name : void 0)) !== null && i !== void 0 ? i : "Unknown Error",
        this.code = r
    }
}
class ac extends We {
    constructor(e, r) {
        super({
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: r,
            message: e
        }),
        this.name = "WebAuthnUnknownError",
        this.originalError = r
    }
}
function Ij({error: t, options: e}) {
    var r, n, s;
    const {publicKey: i} = e;
    if (!i)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new We({
                message: "Registration ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else if (t.name === "ConstraintError") {
        if (((r = i.authenticatorSelection) === null || r === void 0 ? void 0 : r.requireResidentKey) === !0)
            return new We({
                message: "Discoverable credentials were required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
                cause: t
            });
        if (e.mediation === "conditional" && ((n = i.authenticatorSelection) === null || n === void 0 ? void 0 : n.userVerification) === "required")
            return new We({
                message: "User verification was required during automatic registration but it could not be performed",
                code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
                cause: t
            });
        if (((s = i.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required")
            return new We({
                message: "User verification was required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
                cause: t
            })
    } else {
        if (t.name === "InvalidStateError")
            return new We({
                message: "The authenticator was previously registered",
                code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
                cause: t
            });
        if (t.name === "NotAllowedError")
            return new We({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "NotSupportedError")
            return i.pubKeyCredParams.filter(a => a.type === "public-key").length === 0 ? new We({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
                cause: t
            }) : new We({
                message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
                code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
                cause: t
            });
        if (t.name === "SecurityError") {
            const o = window.location.hostname;
            if (nS(o)) {
                if (i.rp.id !== o)
                    return new We({
                        message: `The RP ID "${i.rp.id}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new We({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "TypeError") {
            if (i.user.id.byteLength < 1 || i.user.id.byteLength > 64)
                return new We({
                    message: "User ID was not between 1 and 64 characters",
                    code: "ERROR_INVALID_USER_ID_LENGTH",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new We({
                message: "The authenticator was unable to process the specified options, or could not create a new credential",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new We({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
function Dj({error: t, options: e}) {
    const {publicKey: r} = e;
    if (!r)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new We({
                message: "Authentication ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else {
        if (t.name === "NotAllowedError")
            return new We({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "SecurityError") {
            const n = window.location.hostname;
            if (nS(n)) {
                if (r.rpId !== n)
                    return new We({
                        message: `The RP ID "${r.rpId}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new We({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new We({
                message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new We({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
class Mj {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError",
            this.controller.abort(r)
        }
        const e = new AbortController;
        return this.controller = e,
        e.signal
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError",
            this.controller.abort(e),
            this.controller = void 0
        }
    }
}
const Lj = new Mj;
function $j(t) {
    if (!t)
        throw new Error("Credential creation options are required");
    if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function")
        return PublicKeyCredential.parseCreationOptionsFromJSON(t);
    const {challenge: e, user: r, excludeCredentials: n} = t
      , s = os(t, ["challenge", "user", "excludeCredentials"])
      , i = Bi(e).buffer
      , o = Object.assign(Object.assign({}, r), {
        id: Bi(r.id).buffer
    })
      , a = Object.assign(Object.assign({}, s), {
        challenge: i,
        user: o
    });
    if (n && n.length > 0) {
        a.excludeCredentials = new Array(n.length);
        for (let l = 0; l < n.length; l++) {
            const u = n[l];
            a.excludeCredentials[l] = Object.assign(Object.assign({}, u), {
                id: Bi(u.id).buffer,
                type: u.type || "public-key",
                transports: u.transports
            })
        }
    }
    return a
}
function Fj(t) {
    if (!t)
        throw new Error("Credential request options are required");
    if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function")
        return PublicKeyCredential.parseRequestOptionsFromJSON(t);
    const {challenge: e, allowCredentials: r} = t
      , n = os(t, ["challenge", "allowCredentials"])
      , s = Bi(e).buffer
      , i = Object.assign(Object.assign({}, n), {
        challenge: s
    });
    if (r && r.length > 0) {
        i.allowCredentials = new Array(r.length);
        for (let o = 0; o < r.length; o++) {
            const a = r[o];
            i.allowCredentials[o] = Object.assign(Object.assign({}, a), {
                id: Bi(a.id).buffer,
                type: a.type || "public-key",
                transports: a.transports
            })
        }
    }
    return i
}
function Uj(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            attestationObject: Es(new Uint8Array(t.response.attestationObject)),
            clientDataJSON: Es(new Uint8Array(t.response.clientDataJSON))
        },
        type: "public-key",
        clientExtensionResults: t.getClientExtensionResults(),
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function Vj(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t
      , n = t.getClientExtensionResults()
      , s = t.response;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            authenticatorData: Es(new Uint8Array(s.authenticatorData)),
            clientDataJSON: Es(new Uint8Array(s.clientDataJSON)),
            signature: Es(new Uint8Array(s.signature)),
            userHandle: s.userHandle ? Es(new Uint8Array(s.userHandle)) : void 0
        },
        type: "public-key",
        clientExtensionResults: n,
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function nS(t) {
    return t === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)
}
function ey() {
    var t, e;
    return !!(Xe() && "PublicKeyCredential"in window && window.PublicKeyCredential && "credentials"in navigator && typeof ((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.create) == "function" && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.get) == "function")
}
async function Bj(t) {
    try {
        const e = await navigator.credentials.create(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new ac("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new ac("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: Ij({
                error: e,
                options: t
            })
        }
    }
}
async function zj(t) {
    try {
        const e = await navigator.credentials.get(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new ac("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new ac("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: Dj({
                error: e,
                options: t
            })
        }
    }
}
const Wj = {
    hints: ["security-key"],
    authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: !1,
        userVerification: "preferred",
        residentKey: "discouraged"
    },
    attestation: "direct"
}
  , Hj = {
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
};
function lc(...t) {
    const e = s => s !== null && typeof s == "object" && !Array.isArray(s)
      , r = s => s instanceof ArrayBuffer || ArrayBuffer.isView(s)
      , n = {};
    for (const s of t)
        if (s)
            for (const i in s) {
                const o = s[i];
                if (o !== void 0)
                    if (Array.isArray(o))
                        n[i] = o;
                    else if (r(o))
                        n[i] = o;
                    else if (e(o)) {
                        const a = n[i];
                        e(a) ? n[i] = lc(a, o) : n[i] = lc(o)
                    } else
                        n[i] = o
            }
    return n
}
function qj(t, e) {
    return lc(Wj, t, e || {})
}
function Kj(t, e) {
    return lc(Hj, t, e || {})
}
class Gj {
    constructor(e) {
        this.client = e,
        this.enroll = this._enroll.bind(this),
        this.challenge = this._challenge.bind(this),
        this.verify = this._verify.bind(this),
        this.authenticate = this._authenticate.bind(this),
        this.register = this._register.bind(this)
    }
    async _enroll(e) {
        return this.client.mfa.enroll(Object.assign(Object.assign({}, e), {
            factorType: "webauthn"
        }))
    }
    async _challenge({factorId: e, webauthn: r, friendlyName: n, signal: s}, i) {
        try {
            const {data: o, error: a} = await this.client.mfa.challenge({
                factorId: e,
                webauthn: r
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const l = s ?? Lj.createNewAbortSignal();
            if (o.webauthn.type === "create") {
                const {user: u} = o.webauthn.credential_options.publicKey;
                u.name || (u.name = `${u.id}:${n}`),
                u.displayName || (u.displayName = u.name)
            }
            switch (o.webauthn.type) {
            case "create":
                {
                    const u = qj(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.create)
                      , {data: c, error: d} = await Bj({
                        publicKey: u,
                        signal: l
                    });
                    return c ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: c
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: d
                    }
                }
            case "request":
                {
                    const u = Kj(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.request)
                      , {data: c, error: d} = await zj(Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: u,
                        signal: l
                    }));
                    return c ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: c
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: d
                    }
                }
            }
        } catch (o) {
            return J(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new _s("Unexpected error in challenge",o)
            }
        }
    }
    async _verify({challengeId: e, factorId: r, webauthn: n}) {
        return this.client.mfa.verify({
            factorId: r,
            challengeId: e,
            webauthn: n
        })
    }
    async _authenticate({factorId: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Va("rpId is required for WebAuthn authentication")
            };
        try {
            if (!ey())
                return {
                    data: null,
                    error: new _s("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this.challenge({
                factorId: e,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                request: i
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const {webauthn: l} = o;
            return this._verify({
                factorId: e,
                challengeId: o.challengeId,
                webauthn: {
                    type: l.type,
                    rpId: r,
                    rpOrigins: n,
                    credential_response: l.credential_response
                }
            })
        } catch (o) {
            return J(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new _s("Unexpected error in authenticate",o)
            }
        }
    }
    async _register({friendlyName: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Va("rpId is required for WebAuthn registration")
            };
        try {
            if (!ey())
                return {
                    data: null,
                    error: new _s("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this._enroll({
                friendlyName: e
            });
            if (!o)
                return await this.client.mfa.listFactors().then(c => {
                    var d;
                    return (d = c.data) === null || d === void 0 ? void 0 : d.all.find(f => f.factor_type === "webauthn" && f.friendly_name === e && f.status !== "unverified")
                }
                ).then(c => c ? this.client.mfa.unenroll({
                    factorId: c == null ? void 0 : c.id
                }) : void 0),
                {
                    data: null,
                    error: a
                };
            const {data: l, error: u} = await this._challenge({
                factorId: o.id,
                friendlyName: o.friendly_name,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                create: i
            });
            return l ? this._verify({
                factorId: o.id,
                challengeId: l.challengeId,
                webauthn: {
                    rpId: r,
                    rpOrigins: n,
                    type: l.webauthn.type,
                    credential_response: l.webauthn.credential_response
                }
            }) : {
                data: null,
                error: u
            }
        } catch (o) {
            return J(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new _s("Unexpected error in register",o)
            }
        }
    }
}
Rj();
const Qj = {
    url: HA,
    storageKey: qA,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: KA,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1,
    throwOnError: !1
};
async function ty(t, e, r) {
    return await r()
}
const oi = {};
class Ba {
    get jwks() {
        var e, r;
        return (r = (e = oi[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && r !== void 0 ? r : {
            keys: []
        }
    }
    set jwks(e) {
        oi[this.storageKey] = Object.assign(Object.assign({}, oi[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, r;
        return (r = (e = oi[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && r !== void 0 ? r : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        oi[this.storageKey] = Object.assign(Object.assign({}, oi[this.storageKey]), {
            cachedAt: e
        })
    }
    constructor(e) {
        var r, n, s;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log;
        const i = Object.assign(Object.assign({}, Qj), e);
        if (this.storageKey = i.storageKey,
        this.instanceID = (r = Ba.nextInstanceID[this.storageKey]) !== null && r !== void 0 ? r : 0,
        Ba.nextInstanceID[this.storageKey] = this.instanceID + 1,
        this.logDebugMessages = !!i.debug,
        typeof i.debug == "function" && (this.logger = i.debug),
        this.instanceID > 0 && Xe()) {
            const o = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
            console.warn(o),
            this.logDebugMessages && console.trace(o)
        }
        if (this.persistSession = i.persistSession,
        this.autoRefreshToken = i.autoRefreshToken,
        this.admin = new Tj({
            url: i.url,
            headers: i.headers,
            fetch: i.fetch
        }),
        this.url = i.url,
        this.headers = i.headers,
        this.fetch = eS(i.fetch),
        this.lock = i.lock || ty,
        this.detectSessionInUrl = i.detectSessionInUrl,
        this.flowType = i.flowType,
        this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader,
        this.throwOnError = i.throwOnError,
        i.lock ? this.lock = i.lock : Xe() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = Pj : this.lock = ty,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
            webauthn: new Gj(this)
        },
        this.oauth = {
            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
            approveAuthorization: this._approveAuthorization.bind(this),
            denyAuthorization: this._denyAuthorization.bind(this),
            listGrants: this._listOAuthGrants.bind(this),
            revokeGrant: this._revokeOAuthGrant.bind(this)
        },
        this.persistSession ? (i.storage ? this.storage = i.storage : Xx() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = Xv(this.memoryStorage)),
        i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {},
        this.storage = Xv(this.memoryStorage)),
        Xe() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (o) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
            }
            (s = this.broadcastChannel) === null || s === void 0 || s.addEventListener("message", async o => {
                this._debug("received broadcast notification from other tab or client", o),
                await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    isThrowOnErrorEnabled() {
        return this.throwOnError
    }
    _returnResult(e) {
        if (this.throwOnError && e && e.error)
            throw e.error;
        return e
    }
    _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${Zx}) ${new Date().toISOString()}`
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(this._logPrefix(), ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            let r = {}
              , n = "none";
            if (Xe() && (r = aj(window.location.href),
            this._isImplicitGrantCallback(r) ? n = "implicit" : await this._isPKCECallback(r) && (n = "pkce")),
            Xe() && this.detectSessionInUrl && n !== "none") {
                const {data: s, error: i} = await this._getSessionFromURL(r, n);
                if (i) {
                    if (this._debug("#_initialize()", "error detecting session from URL", i),
                    XA(i)) {
                        const l = (e = i.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: i
                            }
                    }
                    return await this._removeSession(),
                    {
                        error: i
                    }
                }
                const {session: o, redirectType: a} = s;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async () => {
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (r) {
            return J(r) ? this._returnResult({
                error: r
            }) : this._returnResult({
                error: new _s("Unexpected error during initialization",r)
            })
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var r, n, s;
        try {
            const i = await re(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (n = (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.data) !== null && n !== void 0 ? n : {},
                    gotrue_meta_security: {
                        captcha_token: (s = e == null ? void 0 : e.options) === null || s === void 0 ? void 0 : s.captchaToken
                    }
                },
                xform: ir
            })
              , {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , u = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (J(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signUp(e) {
        var r, n, s;
        try {
            let i;
            if ("email"in e) {
                const {email: c, password: d, options: f} = e;
                let p = null
                  , g = null;
                this.flowType === "pkce" && ([p,g] = await ni(this.storage, this.storageKey)),
                i = await re(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: f == null ? void 0 : f.emailRedirectTo,
                    body: {
                        email: c,
                        password: d,
                        data: (r = f == null ? void 0 : f.data) !== null && r !== void 0 ? r : {},
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        },
                        code_challenge: p,
                        code_challenge_method: g
                    },
                    xform: ir
                })
            } else if ("phone"in e) {
                const {phone: c, password: d, options: f} = e;
                i = await re(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: c,
                        password: d,
                        data: (n = f == null ? void 0 : f.data) !== null && n !== void 0 ? n : {},
                        channel: (s = f == null ? void 0 : f.channel) !== null && s !== void 0 ? s : "sms",
                        gotrue_meta_security: {
                            captcha_token: f == null ? void 0 : f.captchaToken
                        }
                    },
                    xform: ir
                })
            } else
                throw new Xl("You must provide either an email or phone number and a password");
            const {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , u = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (J(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithPassword(e) {
        try {
            let r;
            if ("email"in e) {
                const {email: i, password: o, options: a} = e;
                r = await re(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: Yv
                })
            } else if ("phone"in e) {
                const {phone: i, password: o, options: a} = e;
                r = await re(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: Yv
                })
            } else
                throw new Xl("You must provide either an email or phone number and a password");
            const {data: n, error: s} = r;
            if (s)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            if (!n || !n.session || !n.user) {
                const i = new ri;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                })
            }
            return n.session && (await this._saveSession(n.session),
            await this._notifyAllSubscribers("SIGNED_IN", n.session)),
            this._returnResult({
                data: Object.assign({
                    user: n.user,
                    session: n.session
                }, n.weak_password ? {
                    weakPassword: n.weak_password
                } : null),
                error: s
            })
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOAuth(e) {
        var r, n, s, i;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            scopes: (n = e.options) === null || n === void 0 ? void 0 : n.scopes,
            queryParams: (s = e.options) === null || s === void 0 ? void 0 : s.queryParams,
            skipBrowserRedirect: (i = e.options) === null || i === void 0 ? void 0 : i.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: r} = e;
        switch (r) {
        case "ethereum":
            return await this.signInWithEthereum(e);
        case "solana":
            return await this.signInWithSolana(e);
        default:
            throw new Error(`@supabase/auth-js: Unsupported chain "${r}"`)
        }
    }
    async signInWithEthereum(e) {
        var r, n, s, i, o, a, l, u, c, d, f;
        let p, g;
        if ("message"in e)
            p = e.message,
            g = e.signature;
        else {
            const {chain: h, wallet: w, statement: v, options: m} = e;
            let _;
            if (Xe())
                if (typeof w == "object")
                    _ = w;
                else {
                    const j = window;
                    if ("ethereum"in j && typeof j.ethereum == "object" && "request"in j.ethereum && typeof j.ethereum.request == "function")
                        _ = j.ethereum;
                    else
                        throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof w != "object" || !(m != null && m.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                _ = w
            }
            const x = new URL((r = m == null ? void 0 : m.url) !== null && r !== void 0 ? r : window.location.href)
              , k = await _.request({
                method: "eth_requestAccounts"
            }).then(j => j).catch( () => {
                throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
            }
            );
            if (!k || k.length === 0)
                throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
            const T = rS(k[0]);
            let C = (n = m == null ? void 0 : m.signInWithEthereum) === null || n === void 0 ? void 0 : n.chainId;
            if (!C) {
                const j = await _.request({
                    method: "eth_chainId"
                });
                C = Aj(j)
            }
            const P = {
                domain: x.host,
                address: T,
                statement: v,
                uri: x.href,
                version: "1",
                chainId: C,
                nonce: (s = m == null ? void 0 : m.signInWithEthereum) === null || s === void 0 ? void 0 : s.nonce,
                issuedAt: (o = (i = m == null ? void 0 : m.signInWithEthereum) === null || i === void 0 ? void 0 : i.issuedAt) !== null && o !== void 0 ? o : new Date,
                expirationTime: (a = m == null ? void 0 : m.signInWithEthereum) === null || a === void 0 ? void 0 : a.expirationTime,
                notBefore: (l = m == null ? void 0 : m.signInWithEthereum) === null || l === void 0 ? void 0 : l.notBefore,
                requestId: (u = m == null ? void 0 : m.signInWithEthereum) === null || u === void 0 ? void 0 : u.requestId,
                resources: (c = m == null ? void 0 : m.signInWithEthereum) === null || c === void 0 ? void 0 : c.resources
            };
            p = Nj(P),
            g = await _.request({
                method: "personal_sign",
                params: [jj(p), T]
            })
        }
        try {
            const {data: h, error: w} = await re(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "ethereum",
                    message: p,
                    signature: g
                }, !((d = e.options) === null || d === void 0) && d.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (f = e.options) === null || f === void 0 ? void 0 : f.captchaToken
                    }
                } : null),
                xform: ir
            });
            if (w)
                throw w;
            if (!h || !h.session || !h.user) {
                const v = new ri;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: v
                })
            }
            return h.session && (await this._saveSession(h.session),
            await this._notifyAllSubscribers("SIGNED_IN", h.session)),
            this._returnResult({
                data: Object.assign({}, h),
                error: w
            })
        } catch (h) {
            if (J(h))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: h
                });
            throw h
        }
    }
    async signInWithSolana(e) {
        var r, n, s, i, o, a, l, u, c, d, f, p;
        let g, h;
        if ("message"in e)
            g = e.message,
            h = e.signature;
        else {
            const {chain: w, wallet: v, statement: m, options: _} = e;
            let x;
            if (Xe())
                if (typeof v == "object")
                    x = v;
                else {
                    const T = window;
                    if ("solana"in T && typeof T.solana == "object" && ("signIn"in T.solana && typeof T.solana.signIn == "function" || "signMessage"in T.solana && typeof T.solana.signMessage == "function"))
                        x = T.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof v != "object" || !(_ != null && _.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                x = v
            }
            const k = new URL((r = _ == null ? void 0 : _.url) !== null && r !== void 0 ? r : window.location.href);
            if ("signIn"in x && x.signIn) {
                const T = await x.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, _ == null ? void 0 : _.signInWithSolana), {
                    version: "1",
                    domain: k.host,
                    uri: k.href
                }), m ? {
                    statement: m
                } : null));
                let C;
                if (Array.isArray(T) && T[0] && typeof T[0] == "object")
                    C = T[0];
                else if (T && typeof T == "object" && "signedMessage"in T && "signature"in T)
                    C = T;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in C && "signature"in C && (typeof C.signedMessage == "string" || C.signedMessage instanceof Uint8Array) && C.signature instanceof Uint8Array)
                    g = typeof C.signedMessage == "string" ? C.signedMessage : new TextDecoder().decode(C.signedMessage),
                    h = C.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in x) || typeof x.signMessage != "function" || !("publicKey"in x) || typeof x != "object" || !x.publicKey || !("toBase58"in x.publicKey) || typeof x.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                g = [`${k.host} wants you to sign in with your Solana account:`, x.publicKey.toBase58(), ...m ? ["", m, ""] : [""], "Version: 1", `URI: ${k.href}`, `Issued At: ${(s = (n = _ == null ? void 0 : _.signInWithSolana) === null || n === void 0 ? void 0 : n.issuedAt) !== null && s !== void 0 ? s : new Date().toISOString()}`, ...!((i = _ == null ? void 0 : _.signInWithSolana) === null || i === void 0) && i.notBefore ? [`Not Before: ${_.signInWithSolana.notBefore}`] : [], ...!((o = _ == null ? void 0 : _.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${_.signInWithSolana.expirationTime}`] : [], ...!((a = _ == null ? void 0 : _.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${_.signInWithSolana.chainId}`] : [], ...!((l = _ == null ? void 0 : _.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${_.signInWithSolana.nonce}`] : [], ...!((u = _ == null ? void 0 : _.signInWithSolana) === null || u === void 0) && u.requestId ? [`Request ID: ${_.signInWithSolana.requestId}`] : [], ...!((d = (c = _ == null ? void 0 : _.signInWithSolana) === null || c === void 0 ? void 0 : c.resources) === null || d === void 0) && d.length ? ["Resources", ..._.signInWithSolana.resources.map(C => `- ${C}`)] : []].join(`
`);
                const T = await x.signMessage(new TextEncoder().encode(g), "utf8");
                if (!T || !(T instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                h = T
            }
        }
        try {
            const {data: w, error: v} = await re(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: g,
                    signature: Es(h)
                }, !((f = e.options) === null || f === void 0) && f.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (p = e.options) === null || p === void 0 ? void 0 : p.captchaToken
                    }
                } : null),
                xform: ir
            });
            if (v)
                throw v;
            if (!w || !w.session || !w.user) {
                const m = new ri;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: m
                })
            }
            return w.session && (await this._saveSession(w.session),
            await this._notifyAllSubscribers("SIGNED_IN", w.session)),
            this._returnResult({
                data: Object.assign({}, w),
                error: v
            })
        } catch (w) {
            if (J(w))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: w
                });
            throw w
        }
    }
    async _exchangeCodeForSession(e) {
        const r = await fs(this.storage, `${this.storageKey}-code-verifier`)
          , [n,s] = (r ?? "").split("/");
        try {
            const {data: i, error: o} = await re(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: n
                },
                xform: ir
            });
            if (await yn(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            if (!i || !i.session || !i.user) {
                const a = new ri;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: a
                })
            }
            return i.session && (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
            this._returnResult({
                data: Object.assign(Object.assign({}, i), {
                    redirectType: s ?? null
                }),
                error: o
            })
        } catch (i) {
            if (J(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: r, provider: n, token: s, access_token: i, nonce: o} = e
              , a = await re(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: n,
                    id_token: s,
                    access_token: i,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: r == null ? void 0 : r.captchaToken
                    }
                },
                xform: ir
            })
              , {data: l, error: u} = a;
            if (u)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: u
                });
            if (!l || !l.session || !l.user) {
                const c = new ri;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: c
                })
            }
            return l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            this._returnResult({
                data: l,
                error: u
            })
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOtp(e) {
        var r, n, s, i, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let u = null
                  , c = null;
                this.flowType === "pkce" && ([u,c] = await ni(this.storage, this.storageKey));
                const {error: d} = await re(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (r = l == null ? void 0 : l.data) !== null && r !== void 0 ? r : {},
                        create_user: (n = l == null ? void 0 : l.shouldCreateUser) !== null && n !== void 0 ? n : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        code_challenge: u,
                        code_challenge_method: c
                    },
                    redirectTo: l == null ? void 0 : l.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: d
                })
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: u, error: c} = await re(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (s = l == null ? void 0 : l.data) !== null && s !== void 0 ? s : {},
                        create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: u == null ? void 0 : u.message_id
                    },
                    error: c
                })
            }
            throw new Xl("You must provide either an email or phone number.")
        } catch (a) {
            if (J(a))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            throw a
        }
    }
    async verifyOtp(e) {
        var r, n;
        try {
            let s, i;
            "options"in e && (s = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            i = (n = e.options) === null || n === void 0 ? void 0 : n.captchaToken);
            const {data: o, error: a} = await re(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: i
                    }
                }),
                redirectTo: s,
                xform: ir
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , u = o.user;
            return l != null && l.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: u,
                    session: l
                },
                error: null
            })
        } catch (s) {
            if (J(s))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            throw s
        }
    }
    async signInWithSSO(e) {
        var r, n, s, i, o;
        try {
            let a = null
              , l = null;
            this.flowType === "pkce" && ([a,l] = await ni(this.storage, this.storageKey));
            const u = await re(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (n = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo) !== null && n !== void 0 ? n : void 0
                }), !((s = e == null ? void 0 : e.options) === null || s === void 0) && s.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: a,
                    code_challenge_method: l
                }),
                headers: this.headers,
                xform: Ej
            });
            return !((i = u.data) === null || i === void 0) && i.url && Xe() && !(!((o = e.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(u.data.url),
            this._returnResult(u)
        } catch (a) {
            if (J(a))
                return this._returnResult({
                    data: null,
                    error: a
                });
            throw a
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                if (n)
                    throw n;
                if (!r)
                    throw new jt;
                const {error: s} = await re(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: r.access_token
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                })
            }
            )
        } catch (e) {
            if (J(e))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                });
            throw e
        }
    }
    async resend(e) {
        try {
            const r = `${this.url}/resend`;
            if ("email"in e) {
                const {email: n, type: s, options: i} = e
                  , {error: o} = await re(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        email: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    },
                    redirectTo: i == null ? void 0 : i.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                })
            } else if ("phone"in e) {
                const {phone: n, type: s, options: i} = e
                  , {data: o, error: a} = await re(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        phone: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: o == null ? void 0 : o.message_id
                    },
                    error: a
                })
            }
            throw new Xl("You must provide either an email or phone number and a type")
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => this._useSession(async r => r))
    }
    async _acquireLock(e, r) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const n = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , s = (async () => (await n,
                await r()))();
                return this.pendingInLock.push((async () => {
                    try {
                        await s
                    } catch {}
                }
                )()),
                s
            }
            return await this.lock(`lock:${this.storageKey}`, e, async () => {
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const n = r();
                    for (this.pendingInLock.push((async () => {
                        try {
                            await n
                        } catch {}
                    }
                    )()),
                    await n; this.pendingInLock.length; ) {
                        const s = [...this.pendingInLock];
                        await Promise.all(s),
                        this.pendingInLock.splice(0, s.length)
                    }
                    return await n
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const r = await this.__loadSession();
            return await e(r)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const r = await fs(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", r),
            r !== null && (this._isValidSession(r) ? e = r : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const n = e.expires_at ? e.expires_at * 1e3 - Date.now() < Jd : !1;
            if (this._debug("#__loadSession()", `session has${n ? "" : " not"} expired`, "expires_at", e.expires_at),
            !n) {
                if (this.userStorage) {
                    const o = await fs(this.userStorage, this.storageKey + "-user");
                    o != null && o.user ? e.user = o.user : e.user = tf()
                }
                if (this.storage.isServer && e.user && !e.user.__isUserNotAvailableProxy) {
                    const o = {
                        value: this.suppressGetSessionWarning
                    };
                    e.user = _j(e.user, o),
                    o.value && (this.suppressGetSessionWarning = !0)
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
            return i ? this._returnResult({
                data: {
                    session: null
                },
                error: i
            }) : this._returnResult({
                data: {
                    session: s
                },
                error: null
            })
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        return e ? await this._getUser(e) : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()))
    }
    async _getUser(e) {
        try {
            return e ? await re(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: Cn
            }) : await this._useSession(async r => {
                var n, s, i;
                const {data: o, error: a} = r;
                if (a)
                    throw a;
                return !(!((n = o.session) === null || n === void 0) && n.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new jt
                } : await re(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (i = (s = o.session) === null || s === void 0 ? void 0 : s.access_token) !== null && i !== void 0 ? i : void 0,
                    xform: Cn
                })
            }
            )
        } catch (r) {
            if (J(r))
                return JA(r) && (await this._removeSession(),
                await yn(this.storage, `${this.storageKey}-code-verifier`)),
                this._returnResult({
                    data: {
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async updateUser(e, r={}) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._updateUser(e, r))
    }
    async _updateUser(e, r={}) {
        try {
            return await this._useSession(async n => {
                const {data: s, error: i} = n;
                if (i)
                    throw i;
                if (!s.session)
                    throw new jt;
                const o = s.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await ni(this.storage, this.storageKey));
                const {data: u, error: c} = await re(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: r == null ? void 0 : r.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: Cn
                });
                if (c)
                    throw c;
                return o.user = u.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                this._returnResult({
                    data: {
                        user: o.user
                    },
                    error: null
                })
            }
            )
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: {
                        user: null
                    },
                    error: n
                });
            throw n
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new jt;
            const r = Date.now() / 1e3;
            let n = r
              , s = !0
              , i = null;
            const {payload: o} = ef(e.access_token);
            if (o.exp && (n = o.exp,
            s = n <= r),
            s) {
                const {data: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    });
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                i = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                i = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: n - r,
                    expires_at: n
                },
                await this._saveSession(i),
                await this._notifyAllSubscribers("SIGNED_IN", i)
            }
            return this._returnResult({
                data: {
                    user: i.user,
                    session: i
                },
                error: null
            })
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async r => {
                var n;
                if (!e) {
                    const {data: o, error: a} = r;
                    if (a)
                        throw a;
                    e = (n = o.session) !== null && n !== void 0 ? n : void 0
                }
                if (!(e != null && e.refresh_token))
                    throw new jt;
                const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
                return i ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                }) : s ? this._returnResult({
                    data: {
                        user: s.user,
                        session: s
                    },
                    error: null
                }) : this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                })
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async _getSessionFromURL(e, r) {
        try {
            if (!Xe())
                throw new eu("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new eu(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (r) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new Wv("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new eu("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (r === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new Wv("No code detected.");
                const {data: m, error: _} = await this._exchangeCodeForSession(e.code);
                if (_)
                    throw _;
                const x = new URL(window.location.href);
                return x.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", x.toString()),
                {
                    data: {
                        session: m.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: n, provider_refresh_token: s, access_token: i, refresh_token: o, expires_in: a, expires_at: l, token_type: u} = e;
            if (!i || !a || !o || !u)
                throw new eu("No session defined in URL");
            const c = Math.round(Date.now() / 1e3)
              , d = parseInt(a);
            let f = c + d;
            l && (f = parseInt(l));
            const p = f - c;
            p * 1e3 <= fi && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${p}s, should have been closer to ${d}s`);
            const g = f - d;
            c - g >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", g, f, c) : c - g < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", g, f, c);
            const {data: h, error: w} = await this._getUser(i);
            if (w)
                throw w;
            const v = {
                provider_token: n,
                provider_refresh_token: s,
                access_token: i,
                expires_in: d,
                expires_at: f,
                refresh_token: o,
                token_type: u,
                user: h.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            this._returnResult({
                data: {
                    session: v,
                    redirectType: e.type
                },
                error: null
            })
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: n
                });
            throw n
        }
    }
    _isImplicitGrantCallback(e) {
        return !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const r = await fs(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && r)
    }
    async signOut(e={
        scope: "global"
    }) {
        return await this.initializePromise,
        await this._acquireLock(-1, async () => await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "global"
    }) {
        return await this._useSession(async r => {
            var n;
            const {data: s, error: i} = r;
            if (i)
                return this._returnResult({
                    error: i
                });
            const o = (n = s.session) === null || n === void 0 ? void 0 : n.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(YA(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return this._returnResult({
                        error: a
                    })
            }
            return e !== "others" && (await this._removeSession(),
            await yn(this.storage, `${this.storageKey}-code-verifier`)),
            this._returnResult({
                error: null
            })
        }
        )
    }
    onAuthStateChange(e) {
        const r = oj()
          , n = {
            id: r,
            callback: e,
            unsubscribe: () => {
                this._debug("#unsubscribe()", "state change callback with id removed", r),
                this.stateChangeEmitters.delete(r)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", r),
        this.stateChangeEmitters.set(r, n),
        (async () => (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            this._emitInitialSession(r)
        }
        )))(),
        {
            data: {
                subscription: n
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async r => {
            var n, s;
            try {
                const {data: {session: i}, error: o} = r;
                if (o)
                    throw o;
                await ((n = this.stateChangeEmitters.get(e)) === null || n === void 0 ? void 0 : n.callback("INITIAL_SESSION", i)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", i)
            } catch (i) {
                await ((s = this.stateChangeEmitters.get(e)) === null || s === void 0 ? void 0 : s.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", i),
                console.error(i)
            }
        }
        )
    }
    async resetPasswordForEmail(e, r={}) {
        let n = null
          , s = null;
        this.flowType === "pkce" && ([n,s] = await ni(this.storage, this.storageKey, !0));
        try {
            return await re(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: n,
                    code_challenge_method: s,
                    gotrue_meta_security: {
                        captcha_token: r.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: r.redirectTo
            })
        } catch (i) {
            if (J(i))
                return this._returnResult({
                    data: null,
                    error: i
                });
            throw i
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: r, error: n} = await this.getUser();
            if (n)
                throw n;
            return this._returnResult({
                data: {
                    identities: (e = r.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            })
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async linkIdentity(e) {
        return "token"in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e)
    }
    async linkIdentityOAuth(e) {
        var r;
        try {
            const {data: n, error: s} = await this._useSession(async i => {
                var o, a, l, u, c;
                const {data: d, error: f} = i;
                if (f)
                    throw f;
                const p = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await re(this.fetch, "GET", p, {
                    headers: this.headers,
                    jwt: (c = (u = d.session) === null || u === void 0 ? void 0 : u.access_token) !== null && c !== void 0 ? c : void 0
                })
            }
            );
            if (s)
                throw s;
            return Xe() && !(!((r = e.options) === null || r === void 0) && r.skipBrowserRedirect) && window.location.assign(n == null ? void 0 : n.url),
            this._returnResult({
                data: {
                    provider: e.provider,
                    url: n == null ? void 0 : n.url
                },
                error: null
            })
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: n
                });
            throw n
        }
    }
    async linkIdentityIdToken(e) {
        return await this._useSession(async r => {
            var n;
            try {
                const {error: s, data: {session: i}} = r;
                if (s)
                    throw s;
                const {options: o, provider: a, token: l, access_token: u, nonce: c} = e
                  , d = await re(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.access_token) !== null && n !== void 0 ? n : void 0,
                    body: {
                        provider: a,
                        id_token: l,
                        access_token: u,
                        nonce: c,
                        link_identity: !0,
                        gotrue_meta_security: {
                            captcha_token: o == null ? void 0 : o.captchaToken
                        }
                    },
                    xform: ir
                })
                  , {data: f, error: p} = d;
                return p ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: p
                }) : !f || !f.session || !f.user ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: new ri
                }) : (f.session && (await this._saveSession(f.session),
                await this._notifyAllSubscribers("USER_UPDATED", f.session)),
                this._returnResult({
                    data: f,
                    error: p
                }))
            } catch (s) {
                if (J(s))
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: s
                    });
                throw s
            }
        }
        )
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    throw o;
                return await re(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (s = (n = i.session) === null || n === void 0 ? void 0 : n.access_token) !== null && s !== void 0 ? s : void 0
                })
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _refreshAccessToken(e) {
        const r = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(r, "begin");
        try {
            const n = Date.now();
            return await cj(async s => (s > 0 && await uj(200 * Math.pow(2, s - 1)),
            this._debug(r, "refreshing attempt", s),
            await re(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: ir
            })), (s, i) => {
                const o = 200 * Math.pow(2, s);
                return i && Xd(i) && Date.now() + o - n < fi
            }
            )
        } catch (n) {
            if (this._debug(r, "error", n),
            J(n))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                });
            throw n
        } finally {
            this._debug(r, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, r) {
        const n = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: r.redirectTo,
            scopes: r.scopes,
            queryParams: r.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", r, "url", n),
        Xe() && !r.skipBrowserRedirect && window.location.assign(n),
        {
            data: {
                provider: e,
                url: n
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, r;
        const n = "#_recoverAndRefresh()";
        this._debug(n, "begin");
        try {
            const s = await fs(this.storage, this.storageKey);
            if (s && this.userStorage) {
                let o = await fs(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: s.user
                },
                await hi(this.userStorage, this.storageKey + "-user", o)),
                s.user = (e = o == null ? void 0 : o.user) !== null && e !== void 0 ? e : tf()
            } else if (s && !s.user && !s.user) {
                const o = await fs(this.storage, this.storageKey + "-user");
                o && (o != null && o.user) ? (s.user = o.user,
                await yn(this.storage, this.storageKey + "-user"),
                await hi(this.storage, this.storageKey, s)) : s.user = tf()
            }
            if (this._debug(n, "session from storage", s),
            !this._isValidSession(s)) {
                this._debug(n, "session is not valid"),
                s !== null && await this._removeSession();
                return
            }
            const i = ((r = s.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < Jd;
            if (this._debug(n, `session has${i ? "" : " not"} expired with margin of ${Jd}s`),
            i) {
                if (this.autoRefreshToken && s.refresh_token) {
                    const {error: o} = await this._callRefreshToken(s.refresh_token);
                    o && (console.error(o),
                    Xd(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (s.user && s.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(s.access_token);
                    !a && (o != null && o.user) ? (s.user = o.user,
                    await this._saveSession(s),
                    await this._notifyAllSubscribers("SIGNED_IN", s)) : this._debug(n, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(n, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", s)
        } catch (s) {
            this._debug(n, "error", s),
            console.error(s);
            return
        } finally {
            this._debug(n, "end")
        }
    }
    async _callRefreshToken(e) {
        var r, n;
        if (!e)
            throw new jt;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const s = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(s, "begin");
        try {
            this.refreshingDeferred = new td;
            const {data: i, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!i.session)
                throw new jt;
            await this._saveSession(i.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
            const a = {
                data: i.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (i) {
            if (this._debug(s, "error", i),
            J(i)) {
                const o = {
                    data: null,
                    error: i
                };
                return Xd(i) || await this._removeSession(),
                (r = this.refreshingDeferred) === null || r === void 0 || r.resolve(o),
                o
            }
            throw (n = this.refreshingDeferred) === null || n === void 0 || n.reject(i),
            i
        } finally {
            this.refreshingDeferred = null,
            this._debug(s, "end")
        }
    }
    async _notifyAllSubscribers(e, r, n=!0) {
        const s = `#_notifyAllSubscribers(${e})`;
        this._debug(s, "begin", r, `broadcast = ${n}`);
        try {
            this.broadcastChannel && n && this.broadcastChannel.postMessage({
                event: e,
                session: r
            });
            const i = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                try {
                    await a.callback(e, r)
                } catch (l) {
                    i.push(l)
                }
            }
            );
            if (await Promise.all(o),
            i.length > 0) {
                for (let a = 0; a < i.length; a += 1)
                    console.error(i[a]);
                throw i[0]
            }
        } finally {
            this._debug(s, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0;
        const r = Object.assign({}, e)
          , n = r.user && r.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !n && r.user && await hi(this.userStorage, this.storageKey + "-user", {
                user: r.user
            });
            const s = Object.assign({}, r);
            delete s.user;
            const i = Qv(s);
            await hi(this.storage, this.storageKey, i)
        } else {
            const s = Qv(r);
            await hi(this.storage, this.storageKey, s)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        await yn(this.storage, this.storageKey),
        await yn(this.storage, this.storageKey + "-code-verifier"),
        await yn(this.storage, this.storageKey + "-user"),
        this.userStorage && await yn(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && Xe() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
        } catch (r) {
            console.error("removing visibilitychange callback failed", r)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval( () => this._autoRefreshTokenTick(), fi);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e),
        setTimeout(async () => {
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async () => {
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async r => {
                            const {data: {session: n}} = r;
                            if (!n || !n.refresh_token || !n.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const s = Math.floor((n.expires_at * 1e3 - e) / fi);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${s} ticks, a tick lasts ${fi}ms, refresh threshold is ${$h} ticks`),
                            s <= $h && await this._callRefreshToken(n.refresh_token)
                        }
                        )
                    } catch (r) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", r)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof tS)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !Xe() || !(window != null && window.addEventListener))
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1),
            window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const r = `#_onVisibilityChanged(${e})`;
        this._debug(r, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
                this._debug(r, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, r, n) {
        const s = [`provider=${encodeURIComponent(r)}`];
        if (n != null && n.redirectTo && s.push(`redirect_to=${encodeURIComponent(n.redirectTo)}`),
        n != null && n.scopes && s.push(`scopes=${encodeURIComponent(n.scopes)}`),
        this.flowType === "pkce") {
            const [i,o] = await ni(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(i)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            s.push(a.toString())
        }
        if (n != null && n.queryParams) {
            const i = new URLSearchParams(n.queryParams);
            s.push(i.toString())
        }
        return n != null && n.skipBrowserRedirect && s.push(`skip_http_redirect=${n.skipBrowserRedirect}`),
        `${e}?${s.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async r => {
                var n;
                const {data: s, error: i} = r;
                return i ? this._returnResult({
                    data: null,
                    error: i
                }) : await re(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                })
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    return this._returnResult({
                        data: null,
                        error: o
                    });
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : e.factorType === "totp" ? {
                    issuer: e.issuer
                } : {})
                  , {data: l, error: u} = await re(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.session) === null || n === void 0 ? void 0 : n.access_token
                });
                return u ? this._returnResult({
                    data: null,
                    error: u
                }) : (e.factorType === "totp" && l.type === "totp" && (!((s = l == null ? void 0 : l.totp) === null || s === void 0) && s.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                this._returnResult({
                    data: l,
                    error: null
                }))
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _verify(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = Object.assign({
                        challenge_id: e.challengeId
                    }, "webauthn"in e ? {
                        webauthn: Object.assign(Object.assign({}, e.webauthn), {
                            credential_response: e.webauthn.type === "create" ? Uj(e.webauthn.credential_response) : Vj(e.webauthn.credential_response)
                        })
                    } : {
                        code: e.code
                    })
                      , {data: a, error: l} = await re(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: o,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    return l ? this._returnResult({
                        data: null,
                        error: l
                    }) : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + a.expires_in
                    }, a)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
                    this._returnResult({
                        data: a,
                        error: l
                    }))
                }
                )
            } catch (r) {
                if (J(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(-1, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = await re(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: e,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    if (o.error)
                        return o;
                    const {data: a} = o;
                    if (a.type !== "webauthn")
                        return {
                            data: a,
                            error: null
                        };
                    switch (a.webauthn.type) {
                    case "create":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: $j(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        };
                    case "request":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: Fj(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        }
                    }
                }
                )
            } catch (r) {
                if (J(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: r, error: n} = await this._challenge({
            factorId: e.factorId
        });
        return n ? this._returnResult({
            data: null,
            error: n
        }) : await this._verify({
            factorId: e.factorId,
            challengeId: r.id,
            code: e.code
        })
    }
    async _listFactors() {
        var e;
        const {data: {user: r}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const s = {
            all: [],
            phone: [],
            totp: [],
            webauthn: []
        };
        for (const i of (e = r == null ? void 0 : r.factors) !== null && e !== void 0 ? e : [])
            s.all.push(i),
            i.status === "verified" && s[i.factor_type].push(i);
        return {
            data: s,
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        var e, r;
        const {data: {session: n}, error: s} = await this.getSession();
        if (s)
            return this._returnResult({
                data: null,
                error: s
            });
        if (!n)
            return {
                data: {
                    currentLevel: null,
                    nextLevel: null,
                    currentAuthenticationMethods: []
                },
                error: null
            };
        const {payload: i} = ef(n.access_token);
        let o = null;
        i.aal && (o = i.aal);
        let a = o;
        ((r = (e = n.user.factors) === null || e === void 0 ? void 0 : e.filter(c => c.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (a = "aal2");
        const u = i.amr || [];
        return {
            data: {
                currentLevel: o,
                nextLevel: a,
                currentAuthenticationMethods: u
            },
            error: null
        }
    }
    async _getAuthorizationDetails(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? await re(this.fetch, "GET", `${this.url}/oauth/authorizations/${e}`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    xform: i => ({
                        data: i,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new jt
                })
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _approveAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new jt
                    });
                const o = await re(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "approve"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && Xe() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _denyAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new jt
                    });
                const o = await re(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "deny"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && Xe() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _listOAuthGrants() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                return n ? this._returnResult({
                    data: null,
                    error: n
                }) : r ? await re(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: r.access_token,
                    xform: s => ({
                        data: s,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new jt
                })
            }
            )
        } catch (e) {
            if (J(e))
                return this._returnResult({
                    data: null,
                    error: e
                });
            throw e
        }
    }
    async _revokeOAuthGrant(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? await re(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    query: {
                        client_id: e.clientId
                    },
                    xform: () => ({
                        data: {},
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new jt
                })
            }
            )
        } catch (r) {
            if (J(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async fetchJwk(e, r={
        keys: []
    }) {
        let n = r.keys.find(a => a.kid === e);
        if (n)
            return n;
        const s = Date.now();
        if (n = this.jwks.keys.find(a => a.kid === e),
        n && this.jwks_cached_at + QA > s)
            return n;
        const {data: i, error: o} = await re(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !i.keys || i.keys.length === 0 || (this.jwks = i,
        this.jwks_cached_at = s,
        n = i.keys.find(a => a.kid === e),
        !n) ? null : n
    }
    async getClaims(e, r={}) {
        try {
            let n = e;
            if (!n) {
                const {data: p, error: g} = await this.getSession();
                if (g || !p.session)
                    return this._returnResult({
                        data: null,
                        error: g
                    });
                n = p.session.access_token
            }
            const {header: s, payload: i, signature: o, raw: {header: a, payload: l}} = ef(n);
            r != null && r.allowExpired || vj(i.exp);
            const u = !s.alg || s.alg.startsWith("HS") || !s.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(s.kid, r != null && r.keys ? {
                keys: r.keys
            } : r == null ? void 0 : r.jwks);
            if (!u) {
                const {error: p} = await this.getUser(n);
                if (p)
                    throw p;
                return {
                    data: {
                        claims: i,
                        header: s,
                        signature: o
                    },
                    error: null
                }
            }
            const c = yj(s.alg)
              , d = await crypto.subtle.importKey("jwk", u, c, !0, ["verify"]);
            if (!await crypto.subtle.verify(c, d, o, sj(`${a}.${l}`)))
                throw new Vh("Invalid JWT signature");
            return {
                data: {
                    claims: i,
                    header: s,
                    signature: o
                },
                error: null
            }
        } catch (n) {
            if (J(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
}
Ba.nextInstanceID = {};
const Zj = Ba;
class Yj extends Zj {
    constructor(e) {
        super(e)
    }
}
class Jj {
    constructor(e, r, n) {
        var s, i, o;
        this.supabaseUrl = e,
        this.supabaseKey = r;
        const a = WA(e);
        if (!r)
            throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1",a),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",a),
        this.storageUrl = new URL("storage/v1",a),
        this.functionsUrl = new URL("functions/v1",a);
        const l = `sb-${a.hostname.split(".")[0]}-auth-token`
          , u = {
            db: MA,
            realtime: $A,
            auth: Object.assign(Object.assign({}, LA), {
                storageKey: l
            }),
            global: DA
        }
          , c = zA(n ?? {}, u);
        this.storageKey = (s = c.auth.storageKey) !== null && s !== void 0 ? s : "",
        this.headers = (i = c.global.headers) !== null && i !== void 0 ? i : {},
        c.accessToken ? (this.accessToken = c.accessToken,
        this.auth = new Proxy({},{
            get: (d, f) => {
                throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(f)} is not possible`)
            }
        })) : this.auth = this._initSupabaseAuthClient((o = c.auth) !== null && o !== void 0 ? o : {}, this.headers, c.global.fetch),
        this.fetch = VA(r, this._getAccessToken.bind(this), c.global.fetch),
        this.realtime = this._initRealtimeClient(Object.assign({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, c.realtime)),
        this.accessToken && this.accessToken().then(d => this.realtime.setAuth(d)).catch(d => console.warn("Failed to set initial Realtime auth token:", d)),
        this.rest = new HR(new URL("rest/v1",a).href,{
            headers: this.headers,
            schema: c.db.schema,
            fetch: this.fetch
        }),
        this.storage = new jA(this.storageUrl.href,this.headers,this.fetch,n == null ? void 0 : n.storage),
        c.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new BR(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(e) {
        return this.rest.from(e)
    }
    schema(e) {
        return this.rest.schema(e)
    }
    rpc(e, r={}, n={
        head: !1,
        get: !1,
        count: void 0
    }) {
        return this.rest.rpc(e, r, n)
    }
    channel(e, r={
        config: {}
    }) {
        return this.realtime.channel(e, r)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(e) {
        return this.realtime.removeChannel(e)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    async _getAccessToken() {
        var e, r;
        if (this.accessToken)
            return await this.accessToken();
        const {data: n} = await this.auth.getSession();
        return (r = (e = n.session) === null || e === void 0 ? void 0 : e.access_token) !== null && r !== void 0 ? r : this.supabaseKey
    }
    _initSupabaseAuthClient({autoRefreshToken: e, persistSession: r, detectSessionInUrl: n, storage: s, userStorage: i, storageKey: o, flowType: a, lock: l, debug: u, throwOnError: c}, d, f) {
        const p = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new Yj({
            url: this.authUrl.href,
            headers: Object.assign(Object.assign({}, p), d),
            storageKey: o,
            autoRefreshToken: e,
            persistSession: r,
            detectSessionInUrl: n,
            storage: s,
            userStorage: i,
            flowType: a,
            lock: l,
            debug: u,
            throwOnError: c,
            fetch: f,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(g => g.toLowerCase() === "authorization")
        })
    }
    _initRealtimeClient(e) {
        return new lA(this.realtimeUrl.href,Object.assign(Object.assign({}, e), {
            params: Object.assign({
                apikey: this.supabaseKey
            }, e == null ? void 0 : e.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange( (r, n) => {
            this._handleTokenChanged(r, "CLIENT", n == null ? void 0 : n.access_token)
        }
        )
    }
    _handleTokenChanged(e, r, n) {
        (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== n ? (this.changedAccessToken = n,
        this.realtime.setAuth(n)) : e === "SIGNED_OUT" && (this.realtime.setAuth(),
        r == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
const Xj = (t, e, r) => new Jj(t,e,r);
function eN() {
    if (typeof window < "u" || typeof process > "u")
        return !1;
    const t = process.version;
    if (t == null)
        return !1;
    const e = t.match(/^v(\d+)\./);
    return e ? parseInt(e[1], 10) <= 18 : !1
}
eN() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const tN = void 0
  , rN = void 0;
throw new Error("Missing Supabase environment variables");
const Ft = Xj(tN, rN)
  , sS = b.createContext(void 0);
function nN({children: t}) {
    const [e,r] = b.useState(null)
      , [n,s] = b.useState(!0);
    b.useEffect( () => {
        Ft.auth.getSession().then( ({data: {session: c}}) => {
            r((c == null ? void 0 : c.user) ?? null),
            s(!1)
        }
        );
        const {data: {subscription: u}} = Ft.auth.onAuthStateChange( (c, d) => {
            r((d == null ? void 0 : d.user) ?? null)
        }
        );
        return () => u.unsubscribe()
    }
    , []);
    const l = {
        user: e,
        loading: n,
        signIn: async (u, c) => {
            const {error: d} = await Ft.auth.signInWithPassword({
                email: u,
                password: c
            });
            if (d)
                throw d
        }
        ,
        signUp: async (u, c) => {
            const {error: d} = await Ft.auth.signUp({
                email: u,
                password: c
            });
            if (d)
                throw d
        }
        ,
        signOut: async () => {
            const {error: u} = await Ft.auth.signOut();
            if (u)
                throw u
        }
    };
    return y.jsx(sS.Provider, {
        value: l,
        children: t
    })
}
function rd() {
    const t = b.useContext(sS);
    if (t === void 0)
        throw new Error("useAuth must be used within an AuthProvider");
    return t
}
function tu({children: t}) {
    const {user: e, loading: r} = rd()
      , [,n] = Zs();
    return b.useEffect( () => {
        !r && !e && n("/login")
    }
    , [e, r, n]),
    r ? y.jsx("div", {
        className: "flex items-center justify-center min-h-screen bg-background",
        children: y.jsxs("div", {
            className: "text-center",
            children: [y.jsx("div", {
                className: "w-16 h-16 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto mb-4"
            }), y.jsx("p", {
                className: "text-muted-foreground",
                children: "Loading..."
            })]
        })
    }) : e ? y.jsx(y.Fragment, {
        children: t
    }) : null
}
function sN() {
    const [t,e] = Zs()
      , r = [{
        path: "/",
        icon: wO,
        label: "Dashboard",
        testId: "nav-dashboard"
    }, {
        path: "/add-plant",
        icon: bO,
        label: "Add Plant",
        testId: "nav-add-plant"
    }, {
        path: "/profile",
        icon: pb,
        label: "Profile",
        testId: "nav-profile"
    }];
    return y.jsx("nav", {
        className: "fixed bottom-0 left-0 right-0 bg-card border-t border-border z-50 lg:hidden",
        children: y.jsx("div", {
            className: "flex items-center justify-around h-16",
            children: r.map(n => {
                const s = n.icon
                  , i = t === n.path;
                return y.jsxs("button", {
                    onClick: () => e(n.path),
                    className: ye("flex flex-col items-center justify-center flex-1 h-full gap-1 hover-elevate active-elevate-2 transition-colors", i ? "text-primary" : "text-muted-foreground"),
                    "data-testid": n.testId,
                    children: [y.jsx(s, {
                        className: "w-6 h-6"
                    }), y.jsx("span", {
                        className: "text-xs font-medium",
                        children: n.label
                    })]
                }, n.path)
            }
            )
        })
    })
}
const _m = Gc("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 hover-elevate active-elevate-2", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground border border-primary-border",
            destructive: "bg-destructive text-destructive-foreground border border-destructive-border",
            outline: " border [border-color:var(--button-outline)]  shadow-xs active:shadow-none ",
            secondary: "border bg-secondary text-secondary-foreground border border-secondary-border ",
            ghost: "border border-transparent"
        },
        size: {
            default: "min-h-9 px-4 py-2",
            sm: "min-h-8 rounded-md px-3 text-xs",
            lg: "min-h-10 rounded-md px-8",
            icon: "h-9 w-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , mr = b.forwardRef( ({className: t, variant: e, size: r, asChild: n=!1, ...s}, i) => {
    const o = n ? I_ : "button";
    return y.jsx(o, {
        className: ye(_m({
            variant: e,
            size: r,
            className: t
        })),
        ref: i,
        ...s
    })
}
);
mr.displayName = "Button";
const zi = b.forwardRef( ({className: t, type: e, ...r}, n) => y.jsx("input", {
    type: e,
    className: ye("flex h-9 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", t),
    ref: n,
    ...r
}));
zi.displayName = "Input";
const ls = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("shadcn-card rounded-xl border bg-card border-card-border text-card-foreground shadow-sm", t),
    ...e
}));
ls.displayName = "Card";
const gl = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("flex flex-col space-y-1.5 p-6", t),
    ...e
}));
gl.displayName = "CardHeader";
const vl = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("text-2xl font-semibold leading-none tracking-tight", t),
    ...e
}));
vl.displayName = "CardTitle";
const bm = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("text-sm text-muted-foreground", t),
    ...e
}));
bm.displayName = "CardDescription";
const us = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("p-6 pt-0", t),
    ...e
}));
us.displayName = "CardContent";
const iN = b.forwardRef( ({className: t, ...e}, r) => y.jsx("div", {
    ref: r,
    className: ye("flex items-center p-6 pt-0", t),
    ...e
}));
iN.displayName = "CardFooter";
var oN = "Label"
  , iS = b.forwardRef( (t, e) => y.jsx(Be.label, {
    ...t,
    ref: e,
    onMouseDown: r => {
        var s;
        r.target.closest("button, input, select, textarea") || ((s = t.onMouseDown) == null || s.call(t, r),
        !r.defaultPrevented && r.detail > 1 && r.preventDefault())
    }
}));
iS.displayName = oN;
var oS = iS;
const aN = Gc("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70")
  , uc = b.forwardRef( ({className: t, ...e}, r) => y.jsx(oS, {
    ref: r,
    className: ye(aN(), t),
    ...e
}));
uc.displayName = oS.displayName;
function lN() {
    const [t,e] = b.useState(!1)
      , [r,n] = b.useState("")
      , [s,i] = b.useState("")
      , [o,a] = b.useState(!1)
      , {signIn: l, signUp: u} = rd()
      , [,c] = Zs()
      , {toast: d} = ko()
      , f = async p => {
        p.preventDefault(),
        a(!0);
        try {
            t ? (await u(r, s),
            d({
                title: "Account created!",
                description: "If email confirmation is enabled, please check your email. Otherwise, you can sign in now."
            }),
            e(!1)) : (await l(r, s),
            c("/"))
        } catch (g) {
            let h = g.message;
            g.message.includes("Invalid login credentials") && (h = "Invalid email or password. If you just signed up, you may need to confirm your email first."),
            d({
                title: "Error",
                description: h,
                variant: "destructive"
            })
        } finally {
            a(!1)
        }
    }
    ;
    return y.jsx("div", {
        className: "min-h-screen flex items-center justify-center bg-muted/30 p-4",
        children: y.jsxs(ls, {
            className: "w-full max-w-md",
            children: [y.jsxs(gl, {
                className: "text-center space-y-3",
                children: [y.jsx("div", {
                    className: "flex justify-center",
                    children: y.jsx("div", {
                        className: "w-16 h-16 rounded-full bg-primary/10 flex items-center justify-center",
                        children: y.jsx(fb, {
                            className: "w-8 h-8 text-primary"
                        })
                    })
                }), y.jsx(vl, {
                    className: "text-3xl font-medium",
                    children: "GreenThumb"
                }), y.jsx(bm, {
                    children: t ? "Create an account to start caring for your plants" : "Welcome back! Sign in to your account"
                })]
            }), y.jsx(us, {
                children: y.jsxs("form", {
                    onSubmit: f,
                    className: "space-y-4",
                    children: [y.jsxs("div", {
                        className: "space-y-2",
                        children: [y.jsx(uc, {
                            htmlFor: "email",
                            children: "Email"
                        }), y.jsx(zi, {
                            id: "email",
                            type: "email",
                            placeholder: "you@example.com",
                            value: r,
                            onChange: p => n(p.target.value),
                            required: !0,
                            "data-testid": "input-email"
                        })]
                    }), y.jsxs("div", {
                        className: "space-y-2",
                        children: [y.jsx(uc, {
                            htmlFor: "password",
                            children: "Password"
                        }), y.jsx(zi, {
                            id: "password",
                            type: "password",
                            placeholder: "",
                            value: s,
                            onChange: p => i(p.target.value),
                            required: !0,
                            minLength: 6,
                            "data-testid": "input-password"
                        })]
                    }), y.jsx(mr, {
                        type: "submit",
                        className: "w-full",
                        disabled: o,
                        "data-testid": "button-submit",
                        children: o ? "Please wait..." : t ? "Sign Up" : "Sign In"
                    }), y.jsx("div", {
                        className: "text-center text-sm",
                        children: y.jsx("button", {
                            type: "button",
                            onClick: () => e(!t),
                            className: "text-primary hover-elevate active-elevate-2 px-2 py-1 rounded",
                            "data-testid": "button-toggle-mode",
                            children: t ? "Already have an account? Sign in" : "Don't have an account? Sign up"
                        })
                    })]
                })
            })]
        })
    })
}
const uN = Gc("whitespace-nowrap inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 hover-elevate ", {
    variants: {
        variant: {
            default: "border-transparent bg-primary text-primary-foreground shadow-xs",
            secondary: "border-transparent bg-secondary text-secondary-foreground",
            destructive: "border-transparent bg-destructive text-destructive-foreground shadow-xs",
            outline: " border [border-color:var(--badge-outline)] shadow-xs"
        }
    },
    defaultVariants: {
        variant: "default"
    }
});
function cc({className: t, variant: e, ...r}) {
    return y.jsx("div", {
        className: ye(uN({
            variant: e
        }), t),
        ...r
    })
}
function Jr({className: t, ...e}) {
    return y.jsx("div", {
        className: ye("animate-pulse rounded-md bg-muted", t),
        ...e
    })
}
function xe(t) {
    const e = Object.prototype.toString.call(t);
    return t instanceof Date || typeof t == "object" && e === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || e === "[object Number]" || typeof t == "string" || e === "[object String]" ? new Date(t) : new Date(NaN)
}
function cn(t, e) {
    return t instanceof Date ? new t.constructor(e) : new Date(e)
}
function Ai(t, e) {
    const r = xe(t);
    return isNaN(e) ? cn(t, NaN) : (e && r.setDate(r.getDate() + e),
    r)
}
const aS = 6048e5
  , cN = 864e5
  , ru = 43200
  , ry = 1440;
let dN = {};
function yl() {
    return dN
}
function za(t, e) {
    var a, l, u, c;
    const r = yl()
      , n = (e == null ? void 0 : e.weekStartsOn) ?? ((l = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0
      , s = xe(t)
      , i = s.getDay()
      , o = (i < n ? 7 : 0) + i - n;
    return s.setDate(s.getDate() - o),
    s.setHours(0, 0, 0, 0),
    s
}
function dc(t) {
    return za(t, {
        weekStartsOn: 1
    })
}
function lS(t) {
    const e = xe(t)
      , r = e.getFullYear()
      , n = cn(t, 0);
    n.setFullYear(r + 1, 0, 4),
    n.setHours(0, 0, 0, 0);
    const s = dc(n)
      , i = cn(t, 0);
    i.setFullYear(r, 0, 4),
    i.setHours(0, 0, 0, 0);
    const o = dc(i);
    return e.getTime() >= s.getTime() ? r + 1 : e.getTime() >= o.getTime() ? r : r - 1
}
function fc(t) {
    const e = xe(t);
    return e.setHours(0, 0, 0, 0),
    e
}
function hc(t) {
    const e = xe(t)
      , r = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return r.setUTCFullYear(e.getFullYear()),
    +t - +r
}
function fN(t, e) {
    const r = fc(t)
      , n = fc(e)
      , s = +r - hc(r)
      , i = +n - hc(n);
    return Math.round((s - i) / cN)
}
function hN(t) {
    const e = lS(t)
      , r = cn(t, 0);
    return r.setFullYear(e, 0, 4),
    r.setHours(0, 0, 0, 0),
    dc(r)
}
function Eu(t, e) {
    const r = xe(t)
      , n = xe(e)
      , s = r.getTime() - n.getTime();
    return s < 0 ? -1 : s > 0 ? 1 : s
}
function uS(t) {
    return cn(t, Date.now())
}
function pN(t, e) {
    const r = fc(t)
      , n = fc(e);
    return +r == +n
}
function mN(t) {
    return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]"
}
function gN(t) {
    if (!mN(t) && typeof t != "number")
        return !1;
    const e = xe(t);
    return !isNaN(Number(e))
}
function vN(t, e) {
    const r = xe(t)
      , n = xe(e)
      , s = r.getFullYear() - n.getFullYear()
      , i = r.getMonth() - n.getMonth();
    return s * 12 + i
}
function yN(t) {
    return e => {
        const n = (t ? Math[t] : Math.trunc)(e);
        return n === 0 ? 0 : n
    }
}
function wN(t, e) {
    return +xe(t) - +xe(e)
}
function _N(t) {
    const e = xe(t);
    return e.setHours(23, 59, 59, 999),
    e
}
function bN(t) {
    const e = xe(t)
      , r = e.getMonth();
    return e.setFullYear(e.getFullYear(), r + 1, 0),
    e.setHours(23, 59, 59, 999),
    e
}
function xN(t) {
    const e = xe(t);
    return +_N(e) == +bN(e)
}
function SN(t, e) {
    const r = xe(t)
      , n = xe(e)
      , s = Eu(r, n)
      , i = Math.abs(vN(r, n));
    let o;
    if (i < 1)
        o = 0;
    else {
        r.getMonth() === 1 && r.getDate() > 27 && r.setDate(30),
        r.setMonth(r.getMonth() - s * i);
        let a = Eu(r, n) === -s;
        xN(xe(t)) && i === 1 && Eu(t, n) === 1 && (a = !1),
        o = s * (i - Number(a))
    }
    return o === 0 ? 0 : o
}
function EN(t, e, r) {
    const n = wN(t, e) / 1e3;
    return yN(r == null ? void 0 : r.roundingMethod)(n)
}
function kN(t) {
    const e = xe(t)
      , r = cn(t, 0);
    return r.setFullYear(e.getFullYear(), 0, 1),
    r.setHours(0, 0, 0, 0),
    r
}
const CN = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , TN = (t, e, r) => {
    let n;
    const s = CN[t];
    return typeof s == "string" ? n = s : e === 1 ? n = s.one : n = s.other.replace("{{count}}", e.toString()),
    r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + n : n + " ago" : n
}
;
function nf(t) {
    return (e={}) => {
        const r = e.width ? String(e.width) : t.defaultWidth;
        return t.formats[r] || t.formats[t.defaultWidth]
    }
}
const ON = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , PN = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , RN = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , AN = {
    date: nf({
        formats: ON,
        defaultWidth: "full"
    }),
    time: nf({
        formats: PN,
        defaultWidth: "full"
    }),
    dateTime: nf({
        formats: RN,
        defaultWidth: "full"
    })
}
  , jN = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , NN = (t, e, r, n) => jN[t];
function qo(t) {
    return (e, r) => {
        const n = r != null && r.context ? String(r.context) : "standalone";
        let s;
        if (n === "formatting" && t.formattingValues) {
            const o = t.defaultFormattingWidth || t.defaultWidth
              , a = r != null && r.width ? String(r.width) : o;
            s = t.formattingValues[a] || t.formattingValues[o]
        } else {
            const o = t.defaultWidth
              , a = r != null && r.width ? String(r.width) : t.defaultWidth;
            s = t.values[a] || t.values[o]
        }
        const i = t.argumentCallback ? t.argumentCallback(e) : e;
        return s[i]
    }
}
const IN = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , DN = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , MN = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , LN = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , $N = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , FN = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , UN = (t, e) => {
    const r = Number(t)
      , n = r % 100;
    if (n > 20 || n < 10)
        switch (n % 10) {
        case 1:
            return r + "st";
        case 2:
            return r + "nd";
        case 3:
            return r + "rd"
        }
    return r + "th"
}
  , VN = {
    ordinalNumber: UN,
    era: qo({
        values: IN,
        defaultWidth: "wide"
    }),
    quarter: qo({
        values: DN,
        defaultWidth: "wide",
        argumentCallback: t => t - 1
    }),
    month: qo({
        values: MN,
        defaultWidth: "wide"
    }),
    day: qo({
        values: LN,
        defaultWidth: "wide"
    }),
    dayPeriod: qo({
        values: $N,
        defaultWidth: "wide",
        formattingValues: FN,
        defaultFormattingWidth: "wide"
    })
};
function Ko(t) {
    return (e, r={}) => {
        const n = r.width
          , s = n && t.matchPatterns[n] || t.matchPatterns[t.defaultMatchWidth]
          , i = e.match(s);
        if (!i)
            return null;
        const o = i[0]
          , a = n && t.parsePatterns[n] || t.parsePatterns[t.defaultParseWidth]
          , l = Array.isArray(a) ? zN(a, d => d.test(o)) : BN(a, d => d.test(o));
        let u;
        u = t.valueCallback ? t.valueCallback(l) : l,
        u = r.valueCallback ? r.valueCallback(u) : u;
        const c = e.slice(o.length);
        return {
            value: u,
            rest: c
        }
    }
}
function BN(t, e) {
    for (const r in t)
        if (Object.prototype.hasOwnProperty.call(t, r) && e(t[r]))
            return r
}
function zN(t, e) {
    for (let r = 0; r < t.length; r++)
        if (e(t[r]))
            return r
}
function WN(t) {
    return (e, r={}) => {
        const n = e.match(t.matchPattern);
        if (!n)
            return null;
        const s = n[0]
          , i = e.match(t.parsePattern);
        if (!i)
            return null;
        let o = t.valueCallback ? t.valueCallback(i[0]) : i[0];
        o = r.valueCallback ? r.valueCallback(o) : o;
        const a = e.slice(s.length);
        return {
            value: o,
            rest: a
        }
    }
}
const HN = /^(\d+)(th|st|nd|rd)?/i
  , qN = /\d+/i
  , KN = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , GN = {
    any: [/^b/i, /^(a|c)/i]
}
  , QN = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , ZN = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , YN = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , JN = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , XN = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , eI = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , tI = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , rI = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , nI = {
    ordinalNumber: WN({
        matchPattern: HN,
        parsePattern: qN,
        valueCallback: t => parseInt(t, 10)
    }),
    era: Ko({
        matchPatterns: KN,
        defaultMatchWidth: "wide",
        parsePatterns: GN,
        defaultParseWidth: "any"
    }),
    quarter: Ko({
        matchPatterns: QN,
        defaultMatchWidth: "wide",
        parsePatterns: ZN,
        defaultParseWidth: "any",
        valueCallback: t => t + 1
    }),
    month: Ko({
        matchPatterns: YN,
        defaultMatchWidth: "wide",
        parsePatterns: JN,
        defaultParseWidth: "any"
    }),
    day: Ko({
        matchPatterns: XN,
        defaultMatchWidth: "wide",
        parsePatterns: eI,
        defaultParseWidth: "any"
    }),
    dayPeriod: Ko({
        matchPatterns: tI,
        defaultMatchWidth: "any",
        parsePatterns: rI,
        defaultParseWidth: "any"
    })
}
  , cS = {
    code: "en-US",
    formatDistance: TN,
    formatLong: AN,
    formatRelative: NN,
    localize: VN,
    match: nI,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
function sI(t) {
    const e = xe(t);
    return fN(e, kN(e)) + 1
}
function iI(t) {
    const e = xe(t)
      , r = +dc(e) - +hN(e);
    return Math.round(r / aS) + 1
}
function dS(t, e) {
    var c, d, f, p;
    const r = xe(t)
      , n = r.getFullYear()
      , s = yl()
      , i = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((d = (c = e == null ? void 0 : e.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((p = (f = s.locale) == null ? void 0 : f.options) == null ? void 0 : p.firstWeekContainsDate) ?? 1
      , o = cn(t, 0);
    o.setFullYear(n + 1, 0, i),
    o.setHours(0, 0, 0, 0);
    const a = za(o, e)
      , l = cn(t, 0);
    l.setFullYear(n, 0, i),
    l.setHours(0, 0, 0, 0);
    const u = za(l, e);
    return r.getTime() >= a.getTime() ? n + 1 : r.getTime() >= u.getTime() ? n : n - 1
}
function oI(t, e) {
    var a, l, u, c;
    const r = yl()
      , n = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((l = (a = e == null ? void 0 : e.locale) == null ? void 0 : a.options) == null ? void 0 : l.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1
      , s = dS(t, e)
      , i = cn(t, 0);
    return i.setFullYear(s, 0, n),
    i.setHours(0, 0, 0, 0),
    za(i, e)
}
function aI(t, e) {
    const r = xe(t)
      , n = +za(r, e) - +oI(r, e);
    return Math.round(n / aS) + 1
}
function be(t, e) {
    const r = t < 0 ? "-" : ""
      , n = Math.abs(t).toString().padStart(e, "0");
    return r + n
}
const wn = {
    y(t, e) {
        const r = t.getFullYear()
          , n = r > 0 ? r : 1 - r;
        return be(e === "yy" ? n % 100 : n, e.length)
    },
    M(t, e) {
        const r = t.getMonth();
        return e === "M" ? String(r + 1) : be(r + 1, 2)
    },
    d(t, e) {
        return be(t.getDate(), e.length)
    },
    a(t, e) {
        const r = t.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return r.toUpperCase();
        case "aaa":
            return r;
        case "aaaaa":
            return r[0];
        case "aaaa":
        default:
            return r === "am" ? "a.m." : "p.m."
        }
    },
    h(t, e) {
        return be(t.getHours() % 12 || 12, e.length)
    },
    H(t, e) {
        return be(t.getHours(), e.length)
    },
    m(t, e) {
        return be(t.getMinutes(), e.length)
    },
    s(t, e) {
        return be(t.getSeconds(), e.length)
    },
    S(t, e) {
        const r = e.length
          , n = t.getMilliseconds()
          , s = Math.trunc(n * Math.pow(10, r - 3));
        return be(s, e.length)
    }
}
  , ai = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , ny = {
    G: function(t, e, r) {
        const n = t.getFullYear() > 0 ? 1 : 0;
        switch (e) {
        case "G":
        case "GG":
        case "GGG":
            return r.era(n, {
                width: "abbreviated"
            });
        case "GGGGG":
            return r.era(n, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return r.era(n, {
                width: "wide"
            })
        }
    },
    y: function(t, e, r) {
        if (e === "yo") {
            const n = t.getFullYear()
              , s = n > 0 ? n : 1 - n;
            return r.ordinalNumber(s, {
                unit: "year"
            })
        }
        return wn.y(t, e)
    },
    Y: function(t, e, r, n) {
        const s = dS(t, n)
          , i = s > 0 ? s : 1 - s;
        if (e === "YY") {
            const o = i % 100;
            return be(o, 2)
        }
        return e === "Yo" ? r.ordinalNumber(i, {
            unit: "year"
        }) : be(i, e.length)
    },
    R: function(t, e) {
        const r = lS(t);
        return be(r, e.length)
    },
    u: function(t, e) {
        const r = t.getFullYear();
        return be(r, e.length)
    },
    Q: function(t, e, r) {
        const n = Math.ceil((t.getMonth() + 1) / 3);
        switch (e) {
        case "Q":
            return String(n);
        case "QQ":
            return be(n, 2);
        case "Qo":
            return r.ordinalNumber(n, {
                unit: "quarter"
            });
        case "QQQ":
            return r.quarter(n, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return r.quarter(n, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return r.quarter(n, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(t, e, r) {
        const n = Math.ceil((t.getMonth() + 1) / 3);
        switch (e) {
        case "q":
            return String(n);
        case "qq":
            return be(n, 2);
        case "qo":
            return r.ordinalNumber(n, {
                unit: "quarter"
            });
        case "qqq":
            return r.quarter(n, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return r.quarter(n, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return r.quarter(n, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(t, e, r) {
        const n = t.getMonth();
        switch (e) {
        case "M":
        case "MM":
            return wn.M(t, e);
        case "Mo":
            return r.ordinalNumber(n + 1, {
                unit: "month"
            });
        case "MMM":
            return r.month(n, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return r.month(n, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return r.month(n, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(t, e, r) {
        const n = t.getMonth();
        switch (e) {
        case "L":
            return String(n + 1);
        case "LL":
            return be(n + 1, 2);
        case "Lo":
            return r.ordinalNumber(n + 1, {
                unit: "month"
            });
        case "LLL":
            return r.month(n, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return r.month(n, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return r.month(n, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(t, e, r, n) {
        const s = aI(t, n);
        return e === "wo" ? r.ordinalNumber(s, {
            unit: "week"
        }) : be(s, e.length)
    },
    I: function(t, e, r) {
        const n = iI(t);
        return e === "Io" ? r.ordinalNumber(n, {
            unit: "week"
        }) : be(n, e.length)
    },
    d: function(t, e, r) {
        return e === "do" ? r.ordinalNumber(t.getDate(), {
            unit: "date"
        }) : wn.d(t, e)
    },
    D: function(t, e, r) {
        const n = sI(t);
        return e === "Do" ? r.ordinalNumber(n, {
            unit: "dayOfYear"
        }) : be(n, e.length)
    },
    E: function(t, e, r) {
        const n = t.getDay();
        switch (e) {
        case "E":
        case "EE":
        case "EEE":
            return r.day(n, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return r.day(n, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return r.day(n, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return r.day(n, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(t, e, r, n) {
        const s = t.getDay()
          , i = (s - n.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "e":
            return String(i);
        case "ee":
            return be(i, 2);
        case "eo":
            return r.ordinalNumber(i, {
                unit: "day"
            });
        case "eee":
            return r.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return r.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return r.day(s, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return r.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(t, e, r, n) {
        const s = t.getDay()
          , i = (s - n.weekStartsOn + 8) % 7 || 7;
        switch (e) {
        case "c":
            return String(i);
        case "cc":
            return be(i, e.length);
        case "co":
            return r.ordinalNumber(i, {
                unit: "day"
            });
        case "ccc":
            return r.day(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return r.day(s, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return r.day(s, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return r.day(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(t, e, r) {
        const n = t.getDay()
          , s = n === 0 ? 7 : n;
        switch (e) {
        case "i":
            return String(s);
        case "ii":
            return be(s, e.length);
        case "io":
            return r.ordinalNumber(s, {
                unit: "day"
            });
        case "iii":
            return r.day(n, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return r.day(n, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return r.day(n, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return r.day(n, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(t, e, r) {
        const s = t.getHours() / 12 >= 1 ? "pm" : "am";
        switch (e) {
        case "a":
        case "aa":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(t, e, r) {
        const n = t.getHours();
        let s;
        switch (n === 12 ? s = ai.noon : n === 0 ? s = ai.midnight : s = n / 12 >= 1 ? "pm" : "am",
        e) {
        case "b":
        case "bb":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(t, e, r) {
        const n = t.getHours();
        let s;
        switch (n >= 17 ? s = ai.evening : n >= 12 ? s = ai.afternoon : n >= 4 ? s = ai.morning : s = ai.night,
        e) {
        case "B":
        case "BB":
        case "BBB":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(t, e, r) {
        if (e === "ho") {
            let n = t.getHours() % 12;
            return n === 0 && (n = 12),
            r.ordinalNumber(n, {
                unit: "hour"
            })
        }
        return wn.h(t, e)
    },
    H: function(t, e, r) {
        return e === "Ho" ? r.ordinalNumber(t.getHours(), {
            unit: "hour"
        }) : wn.H(t, e)
    },
    K: function(t, e, r) {
        const n = t.getHours() % 12;
        return e === "Ko" ? r.ordinalNumber(n, {
            unit: "hour"
        }) : be(n, e.length)
    },
    k: function(t, e, r) {
        let n = t.getHours();
        return n === 0 && (n = 24),
        e === "ko" ? r.ordinalNumber(n, {
            unit: "hour"
        }) : be(n, e.length)
    },
    m: function(t, e, r) {
        return e === "mo" ? r.ordinalNumber(t.getMinutes(), {
            unit: "minute"
        }) : wn.m(t, e)
    },
    s: function(t, e, r) {
        return e === "so" ? r.ordinalNumber(t.getSeconds(), {
            unit: "second"
        }) : wn.s(t, e)
    },
    S: function(t, e) {
        return wn.S(t, e)
    },
    X: function(t, e, r) {
        const n = t.getTimezoneOffset();
        if (n === 0)
            return "Z";
        switch (e) {
        case "X":
            return iy(n);
        case "XXXX":
        case "XX":
            return vs(n);
        case "XXXXX":
        case "XXX":
        default:
            return vs(n, ":")
        }
    },
    x: function(t, e, r) {
        const n = t.getTimezoneOffset();
        switch (e) {
        case "x":
            return iy(n);
        case "xxxx":
        case "xx":
            return vs(n);
        case "xxxxx":
        case "xxx":
        default:
            return vs(n, ":")
        }
    },
    O: function(t, e, r) {
        const n = t.getTimezoneOffset();
        switch (e) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + sy(n, ":");
        case "OOOO":
        default:
            return "GMT" + vs(n, ":")
        }
    },
    z: function(t, e, r) {
        const n = t.getTimezoneOffset();
        switch (e) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + sy(n, ":");
        case "zzzz":
        default:
            return "GMT" + vs(n, ":")
        }
    },
    t: function(t, e, r) {
        const n = Math.trunc(t.getTime() / 1e3);
        return be(n, e.length)
    },
    T: function(t, e, r) {
        const n = t.getTime();
        return be(n, e.length)
    }
};
function sy(t, e="") {
    const r = t > 0 ? "-" : "+"
      , n = Math.abs(t)
      , s = Math.trunc(n / 60)
      , i = n % 60;
    return i === 0 ? r + String(s) : r + String(s) + e + be(i, 2)
}
function iy(t, e) {
    return t % 60 === 0 ? (t > 0 ? "-" : "+") + be(Math.abs(t) / 60, 2) : vs(t, e)
}
function vs(t, e="") {
    const r = t > 0 ? "-" : "+"
      , n = Math.abs(t)
      , s = be(Math.trunc(n / 60), 2)
      , i = be(n % 60, 2);
    return r + s + e + i
}
const oy = (t, e) => {
    switch (t) {
    case "P":
        return e.date({
            width: "short"
        });
    case "PP":
        return e.date({
            width: "medium"
        });
    case "PPP":
        return e.date({
            width: "long"
        });
    case "PPPP":
    default:
        return e.date({
            width: "full"
        })
    }
}
  , fS = (t, e) => {
    switch (t) {
    case "p":
        return e.time({
            width: "short"
        });
    case "pp":
        return e.time({
            width: "medium"
        });
    case "ppp":
        return e.time({
            width: "long"
        });
    case "pppp":
    default:
        return e.time({
            width: "full"
        })
    }
}
  , lI = (t, e) => {
    const r = t.match(/(P+)(p+)?/) || []
      , n = r[1]
      , s = r[2];
    if (!s)
        return oy(t, e);
    let i;
    switch (n) {
    case "P":
        i = e.dateTime({
            width: "short"
        });
        break;
    case "PP":
        i = e.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        i = e.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        i = e.dateTime({
            width: "full"
        });
        break
    }
    return i.replace("{{date}}", oy(n, e)).replace("{{time}}", fS(s, e))
}
  , uI = {
    p: fS,
    P: lI
}
  , cI = /^D+$/
  , dI = /^Y+$/
  , fI = ["D", "DD", "YY", "YYYY"];
function hI(t) {
    return cI.test(t)
}
function pI(t) {
    return dI.test(t)
}
function mI(t, e, r) {
    const n = gI(t, e, r);
    if (console.warn(n),
    fI.includes(t))
        throw new RangeError(n)
}
function gI(t, e, r) {
    const n = t[0] === "Y" ? "years" : "days of the month";
    return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${n} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const vI = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , yI = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , wI = /^'([^]*?)'?$/
  , _I = /''/g
  , bI = /[a-zA-Z]/;
function ay(t, e, r) {
    var c, d, f, p;
    const n = yl()
      , s = n.locale ?? cS
      , i = n.firstWeekContainsDate ?? ((d = (c = n.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? 1
      , o = n.weekStartsOn ?? ((p = (f = n.locale) == null ? void 0 : f.options) == null ? void 0 : p.weekStartsOn) ?? 0
      , a = xe(t);
    if (!gN(a))
        throw new RangeError("Invalid time value");
    let l = e.match(yI).map(g => {
        const h = g[0];
        if (h === "p" || h === "P") {
            const w = uI[h];
            return w(g, s.formatLong)
        }
        return g
    }
    ).join("").match(vI).map(g => {
        if (g === "''")
            return {
                isToken: !1,
                value: "'"
            };
        const h = g[0];
        if (h === "'")
            return {
                isToken: !1,
                value: xI(g)
            };
        if (ny[h])
            return {
                isToken: !0,
                value: g
            };
        if (h.match(bI))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + h + "`");
        return {
            isToken: !1,
            value: g
        }
    }
    );
    s.localize.preprocessor && (l = s.localize.preprocessor(a, l));
    const u = {
        firstWeekContainsDate: i,
        weekStartsOn: o,
        locale: s
    };
    return l.map(g => {
        if (!g.isToken)
            return g.value;
        const h = g.value;
        (pI(h) || hI(h)) && mI(h, e, String(t));
        const w = ny[h[0]];
        return w(a, h, s.localize, u)
    }
    ).join("")
}
function xI(t) {
    const e = t.match(wI);
    return e ? e[1].replace(_I, "'") : t
}
function SI(t, e, r) {
    const n = yl()
      , s = (r == null ? void 0 : r.locale) ?? n.locale ?? cS
      , i = 2520
      , o = Eu(t, e);
    if (isNaN(o))
        throw new RangeError("Invalid time value");
    const a = Object.assign({}, r, {
        addSuffix: r == null ? void 0 : r.addSuffix,
        comparison: o
    });
    let l, u;
    o > 0 ? (l = xe(e),
    u = xe(t)) : (l = xe(t),
    u = xe(e));
    const c = EN(u, l)
      , d = (hc(u) - hc(l)) / 1e3
      , f = Math.round((c - d) / 60);
    let p;
    if (f < 2)
        return r != null && r.includeSeconds ? c < 5 ? s.formatDistance("lessThanXSeconds", 5, a) : c < 10 ? s.formatDistance("lessThanXSeconds", 10, a) : c < 20 ? s.formatDistance("lessThanXSeconds", 20, a) : c < 40 ? s.formatDistance("halfAMinute", 0, a) : c < 60 ? s.formatDistance("lessThanXMinutes", 1, a) : s.formatDistance("xMinutes", 1, a) : f === 0 ? s.formatDistance("lessThanXMinutes", 1, a) : s.formatDistance("xMinutes", f, a);
    if (f < 45)
        return s.formatDistance("xMinutes", f, a);
    if (f < 90)
        return s.formatDistance("aboutXHours", 1, a);
    if (f < ry) {
        const g = Math.round(f / 60);
        return s.formatDistance("aboutXHours", g, a)
    } else {
        if (f < i)
            return s.formatDistance("xDays", 1, a);
        if (f < ru) {
            const g = Math.round(f / ry);
            return s.formatDistance("xDays", g, a)
        } else if (f < ru * 2)
            return p = Math.round(f / ru),
            s.formatDistance("aboutXMonths", p, a)
    }
    if (p = SN(u, l),
    p < 12) {
        const g = Math.round(f / ru);
        return s.formatDistance("xMonths", g, a)
    } else {
        const g = p % 12
          , h = Math.trunc(p / 12);
        return g < 3 ? s.formatDistance("aboutXYears", h, a) : g < 9 ? s.formatDistance("overXYears", h, a) : s.formatDistance("almostXYears", h + 1, a)
    }
}
function Bh(t, e) {
    return SI(t, uS(t), e)
}
function zh(t) {
    return +xe(t) < Date.now()
}
function pc(t) {
    return pN(t, uS(t))
}
function ly({plant: t, onWater: e, isWatering: r, onClick: n}) {
    const s = Ai(new Date(t.last_watered_date), t.water_frequency_days)
      , i = zh(s) && !pc(s)
      , o = pc(s)
      , a = i || o
      , u = ( () => {
        if (i) {
            const c = Math.floor((Date.now() - s.getTime()) / 864e5);
            return {
                text: `Overdue by ${c} ${c === 1 ? "day" : "days"}`,
                variant: "destructive"
            }
        }
        return o ? {
            text: "Due today",
            variant: "default"
        } : {
            text: `Next watering in ${Bh(s)}`,
            variant: "secondary"
        }
    }
    )();
    return y.jsxs(ls, {
        className: "overflow-hidden hover-elevate cursor-pointer transition-all",
        onClick: n,
        children: [y.jsx("div", {
            className: "relative aspect-video overflow-hidden bg-muted",
            children: y.jsx("img", {
                src: t.photo_url,
                alt: t.name,
                className: "w-full h-full object-cover",
                onError: c => {
                    c.target.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 24 24" fill="none" stroke="%232E7D32" stroke-width="2"%3E%3Cpath d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"%3E%3C/path%3E%3Cpath d="M7.5 12H5a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2h-2.5"%3E%3C/path%3E%3C/svg%3E'
                }
            })
        }), y.jsxs(us, {
            className: "p-4 space-y-3",
            children: [y.jsxs("div", {
                className: "space-y-2",
                children: [y.jsx("h3", {
                    className: "text-lg font-medium text-foreground",
                    "data-testid": `text-plant-name-${t.id}`,
                    children: t.name
                }), y.jsx("div", {
                    className: "flex items-center gap-2",
                    children: y.jsxs(cc, {
                        variant: "secondary",
                        className: "text-xs",
                        children: [y.jsx(hb, {
                            className: "w-3 h-3 mr-1"
                        }), t.location]
                    })
                }), y.jsxs(cc, {
                    variant: u.variant,
                    className: "text-xs",
                    "data-testid": `text-status-${t.id}`,
                    children: [y.jsx(db, {
                        className: "w-3 h-3 mr-1"
                    }), u.text]
                })]
            }), t.notes && y.jsx("p", {
                className: "text-sm text-muted-foreground line-clamp-2",
                children: t.notes
            }), y.jsx(mr, {
                onClick: c => {
                    c.stopPropagation(),
                    e(t.id)
                }
                ,
                disabled: r,
                className: "w-full",
                variant: a ? "default" : "secondary",
                "data-testid": `button-water-${t.id}`,
                children: r ? "Watering..." : "Water Plant"
            })]
        })]
    })
}
function EI() {
    return y.jsxs(ls, {
        className: "overflow-hidden",
        children: [y.jsx(Jr, {
            className: "aspect-video w-full"
        }), y.jsxs(us, {
            className: "p-4 space-y-3",
            children: [y.jsx(Jr, {
                className: "h-6 w-3/4"
            }), y.jsx("div", {
                className: "flex gap-2",
                children: y.jsx(Jr, {
                    className: "h-5 w-20"
                })
            }), y.jsx(Jr, {
                className: "h-5 w-full"
            }), y.jsx(Jr, {
                className: "h-10 w-full"
            })]
        })]
    })
}
function kI() {
    const [,t] = Zs()
      , {toast: e} = ko()
      , [r,n] = b.useState(null)
      , {data: s, isLoading: i} = j_({
        queryKey: ["/api/plants"],
        queryFn: async () => {
            const {data: d, error: f} = await Ft.from("plants").select("*").order("last_watered_date", {
                ascending: !0
            });
            if (f)
                throw f;
            return d
        }
    })
      , o = ec({
        mutationFn: async d => {
            const {data: f, error: p} = await Ft.from("plants").update({
                last_watered_date: new Date().toISOString()
            }).eq("id", d).select().single();
            if (p)
                throw p;
            return f
        }
        ,
        onMutate: async d => {
            n(d),
            await Nr.cancelQueries({
                queryKey: ["/api/plants"]
            });
            const f = Nr.getQueryData(["/api/plants"]);
            return Nr.setQueryData(["/api/plants"], p => (p == null ? void 0 : p.map(g => g.id === d ? {
                ...g,
                last_watered_date: new Date().toISOString()
            } : g)) || []),
            {
                previousPlants: f
            }
        }
        ,
        onError: (d, f, p) => {
            Nr.setQueryData(["/api/plants"], p == null ? void 0 : p.previousPlants),
            e({
                title: "Error",
                description: "Failed to update watering status",
                variant: "destructive"
            })
        }
        ,
        onSuccess: () => {
            e({
                title: "Plant watered!",
                description: "Watering date updated successfully"
            })
        }
        ,
        onSettled: () => {
            n(null),
            Nr.invalidateQueries({
                queryKey: ["/api/plants"]
            })
        }
    })
      , a = d => {
        o.mutate(d)
    }
      , l = s ? [...s].sort( (d, f) => {
        const p = Ai(new Date(d.last_watered_date), d.water_frequency_days)
          , g = Ai(new Date(f.last_watered_date), f.water_frequency_days);
        return p.getTime() - g.getTime()
    }
    ) : []
      , u = l.filter(d => {
        const f = Ai(new Date(d.last_watered_date), d.water_frequency_days);
        return zh(f) || pc(f)
    }
    )
      , c = l.filter(d => {
        const f = Ai(new Date(d.last_watered_date), d.water_frequency_days);
        return !zh(f) && !pc(f)
    }
    );
    return i ? y.jsx("div", {
        className: "p-4 space-y-6 pb-24",
        children: y.jsxs("div", {
            className: "space-y-4",
            children: [y.jsx("h2", {
                className: "text-xl font-medium",
                children: "Loading plants..."
            }), y.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4",
                children: [1, 2, 3].map(d => y.jsx(EI, {}, d))
            })]
        })
    }) : !s || s.length === 0 ? y.jsxs("div", {
        className: "flex flex-col items-center justify-center min-h-[60vh] p-4 text-center",
        children: [y.jsx("div", {
            className: "w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center mb-4",
            children: y.jsx(xO, {
                className: "w-10 h-10 text-primary"
            })
        }), y.jsx("h2", {
            className: "text-2xl font-medium mb-2",
            children: "No plants yet"
        }), y.jsx("p", {
            className: "text-muted-foreground mb-6 max-w-md",
            children: "Start your plant care journey by adding your first plant. Track watering schedules and keep your green friends thriving!"
        }), y.jsx(mr, {
            onClick: () => t("/add-plant"),
            "data-testid": "button-add-first-plant",
            children: "Add Your First Plant"
        })]
    }) : y.jsxs("div", {
        className: "p-4 space-y-6 pb-24",
        children: [u.length > 0 && y.jsxs("div", {
            className: "space-y-4",
            children: [y.jsxs("div", {
                className: "flex items-center gap-2",
                children: [y.jsx("div", {
                    className: "w-2 h-2 rounded-full bg-destructive animate-pulse"
                }), y.jsx("h2", {
                    className: "text-xl font-medium text-foreground",
                    children: "Needs Water"
                })]
            }), y.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4",
                "data-testid": "section-needs-water",
                children: u.map(d => y.jsx(ly, {
                    plant: d,
                    onWater: a,
                    isWatering: r === d.id,
                    onClick: () => t(`/plant/${d.id}`)
                }, d.id))
            })]
        }), c.length > 0 && y.jsxs("div", {
            className: "space-y-4",
            children: [y.jsxs("div", {
                className: "flex items-center gap-2",
                children: [y.jsx("div", {
                    className: "w-2 h-2 rounded-full bg-primary"
                }), y.jsx("h2", {
                    className: "text-xl font-medium text-foreground",
                    children: "All Good"
                })]
            }), y.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4",
                "data-testid": "section-all-good",
                children: c.map(d => y.jsx(ly, {
                    plant: d,
                    onWater: a,
                    isWatering: r === d.id,
                    onClick: () => t(`/plant/${d.id}`)
                }, d.id))
            })]
        })]
    })
}
var wl = t => t.type === "checkbox"
  , ks = t => t instanceof Date
  , gt = t => t == null;
const hS = t => typeof t == "object";
var Ve = t => !gt(t) && !Array.isArray(t) && hS(t) && !ks(t)
  , pS = t => Ve(t) && t.target ? wl(t.target) ? t.target.checked : t.target.value : t
  , CI = t => t.substring(0, t.search(/\.\d+(\.|$)/)) || t
  , mS = (t, e) => t.has(CI(e))
  , TI = t => {
    const e = t.constructor && t.constructor.prototype;
    return Ve(e) && e.hasOwnProperty("isPrototypeOf")
}
  , xm = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function et(t) {
    let e;
    const r = Array.isArray(t)
      , n = typeof FileList < "u" ? t instanceof FileList : !1;
    if (t instanceof Date)
        e = new Date(t);
    else if (t instanceof Set)
        e = new Set(t);
    else if (!(xm && (t instanceof Blob || n)) && (r || Ve(t)))
        if (e = r ? [] : {},
        !r && !TI(t))
            e = t;
        else
            for (const s in t)
                t.hasOwnProperty(s) && (e[s] = et(t[s]));
    else
        return t;
    return e
}
var nd = t => Array.isArray(t) ? t.filter(Boolean) : []
  , Fe = t => t === void 0
  , U = (t, e, r) => {
    if (!e || !Ve(t))
        return r;
    const n = nd(e.split(/[,[\].]+?/)).reduce( (s, i) => gt(s) ? s : s[i], t);
    return Fe(n) || n === t ? Fe(t[e]) ? r : t[e] : n
}
  , Dt = t => typeof t == "boolean"
  , Sm = t => /^\w*$/.test(t)
  , gS = t => nd(t.replace(/["|']|\]/g, "").split(/\.|\[/))
  , we = (t, e, r) => {
    let n = -1;
    const s = Sm(e) ? [e] : gS(e)
      , i = s.length
      , o = i - 1;
    for (; ++n < i; ) {
        const a = s[n];
        let l = r;
        if (n !== o) {
            const u = t[a];
            l = Ve(u) || Array.isArray(u) ? u : isNaN(+s[n + 1]) ? {} : []
        }
        if (a === "__proto__" || a === "constructor" || a === "prototype")
            return;
        t[a] = l,
        t = t[a]
    }
}
;
const mc = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , hr = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , Wr = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , vS = le.createContext(null)
  , sd = () => le.useContext(vS)
  , OI = t => {
    const {children: e, ...r} = t;
    return le.createElement(vS.Provider, {
        value: r
    }, e)
}
;
var yS = (t, e, r, n=!0) => {
    const s = {
        defaultValues: e._defaultValues
    };
    for (const i in t)
        Object.defineProperty(s, i, {
            get: () => {
                const o = i;
                return e._proxyFormState[o] !== hr.all && (e._proxyFormState[o] = !n || hr.all),
                r && (r[o] = !0),
                t[o]
            }
        });
    return s
}
;
function PI(t) {
    const e = sd()
      , {control: r=e.control, disabled: n, name: s, exact: i} = t || {}
      , [o,a] = le.useState(r._formState)
      , l = le.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    })
      , u = le.useRef(s);
    return u.current = s,
    le.useEffect( () => r._subscribe({
        name: u.current,
        formState: l.current,
        exact: i,
        callback: c => {
            !n && a({
                ...r._formState,
                ...c
            })
        }
    }), [r, n, i]),
    le.useEffect( () => {
        l.current.isValid && r._setValid(!0)
    }
    , [r]),
    le.useMemo( () => yS(o, r, l.current, !1), [o, r])
}
var Ir = t => typeof t == "string"
  , wS = (t, e, r, n, s) => Ir(t) ? (n && e.watch.add(t),
U(r, t, s)) : Array.isArray(t) ? t.map(i => (n && e.watch.add(i),
U(r, i))) : (n && (e.watchAll = !0),
r);
function RI(t) {
    const e = sd()
      , {control: r=e.control, name: n, defaultValue: s, disabled: i, exact: o} = t || {}
      , a = le.useRef(n)
      , l = le.useRef(s);
    a.current = n,
    le.useEffect( () => r._subscribe({
        name: a.current,
        formState: {
            values: !0
        },
        exact: o,
        callback: d => !i && c(wS(a.current, r._names, d.values || r._formValues, !1, l.current))
    }), [r, i, o]);
    const [u,c] = le.useState(r._getWatch(n, s));
    return le.useEffect( () => r._removeUnmounted()),
    u
}
function AI(t) {
    const e = sd()
      , {name: r, disabled: n, control: s=e.control, shouldUnregister: i} = t
      , o = mS(s._names.array, r)
      , a = RI({
        control: s,
        name: r,
        defaultValue: U(s._formValues, r, U(s._defaultValues, r, t.defaultValue)),
        exact: !0
    })
      , l = PI({
        control: s,
        name: r,
        exact: !0
    })
      , u = le.useRef(t)
      , c = le.useRef(s.register(r, {
        ...t.rules,
        value: a,
        ...Dt(t.disabled) ? {
            disabled: t.disabled
        } : {}
    }))
      , d = le.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!U(l.errors, r)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!U(l.dirtyFields, r)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!U(l.touchedFields, r)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!U(l.validatingFields, r)
        },
        error: {
            enumerable: !0,
            get: () => U(l.errors, r)
        }
    }), [l, r])
      , f = le.useCallback(w => c.current.onChange({
        target: {
            value: pS(w),
            name: r
        },
        type: mc.CHANGE
    }), [r])
      , p = le.useCallback( () => c.current.onBlur({
        target: {
            value: U(s._formValues, r),
            name: r
        },
        type: mc.BLUR
    }), [r, s._formValues])
      , g = le.useCallback(w => {
        const v = U(s._fields, r);
        v && w && (v._f.ref = {
            focus: () => w.focus(),
            select: () => w.select(),
            setCustomValidity: m => w.setCustomValidity(m),
            reportValidity: () => w.reportValidity()
        })
    }
    , [s._fields, r])
      , h = le.useMemo( () => ({
        name: r,
        value: a,
        ...Dt(n) || l.disabled ? {
            disabled: l.disabled || n
        } : {},
        onChange: f,
        onBlur: p,
        ref: g
    }), [r, n, l.disabled, f, p, g, a]);
    return le.useEffect( () => {
        const w = s._options.shouldUnregister || i;
        s.register(r, {
            ...u.current.rules,
            ...Dt(u.current.disabled) ? {
                disabled: u.current.disabled
            } : {}
        });
        const v = (m, _) => {
            const x = U(s._fields, m);
            x && x._f && (x._f.mount = _)
        }
        ;
        if (v(r, !0),
        w) {
            const m = et(U(s._options.defaultValues, r));
            we(s._defaultValues, r, m),
            Fe(U(s._formValues, r)) && we(s._formValues, r, m)
        }
        return !o && s.register(r),
        () => {
            (o ? w && !s._state.action : w) ? s.unregister(r) : v(r, !1)
        }
    }
    , [r, s, o, i]),
    le.useEffect( () => {
        s._setDisabledField({
            disabled: n,
            name: r
        })
    }
    , [n, r, s]),
    le.useMemo( () => ({
        field: h,
        formState: l,
        fieldState: d
    }), [h, l, d])
}
const jI = t => t.render(AI(t));
var _S = (t, e, r, n, s) => e ? {
    ...r[t],
    types: {
        ...r[t] && r[t].types ? r[t].types : {},
        [n]: s || !0
    }
} : {}
  , va = t => Array.isArray(t) ? t : [t]
  , uy = () => {
    let t = [];
    return {
        get observers() {
            return t
        },
        next: s => {
            for (const i of t)
                i.next && i.next(s)
        }
        ,
        subscribe: s => (t.push(s),
        {
            unsubscribe: () => {
                t = t.filter(i => i !== s)
            }
        }),
        unsubscribe: () => {
            t = []
        }
    }
}
  , Wh = t => gt(t) || !hS(t);
function Tn(t, e) {
    if (Wh(t) || Wh(e))
        return t === e;
    if (ks(t) && ks(e))
        return t.getTime() === e.getTime();
    const r = Object.keys(t)
      , n = Object.keys(e);
    if (r.length !== n.length)
        return !1;
    for (const s of r) {
        const i = t[s];
        if (!n.includes(s))
            return !1;
        if (s !== "ref") {
            const o = e[s];
            if (ks(i) && ks(o) || Ve(i) && Ve(o) || Array.isArray(i) && Array.isArray(o) ? !Tn(i, o) : i !== o)
                return !1
        }
    }
    return !0
}
var pt = t => Ve(t) && !Object.keys(t).length
  , Em = t => t.type === "file"
  , pr = t => typeof t == "function"
  , gc = t => {
    if (!xm)
        return !1;
    const e = t ? t.ownerDocument : 0;
    return t instanceof (e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement)
}
  , bS = t => t.type === "select-multiple"
  , km = t => t.type === "radio"
  , NI = t => km(t) || wl(t)
  , sf = t => gc(t) && t.isConnected;
function II(t, e) {
    const r = e.slice(0, -1).length;
    let n = 0;
    for (; n < r; )
        t = Fe(t) ? n++ : t[e[n++]];
    return t
}
function DI(t) {
    for (const e in t)
        if (t.hasOwnProperty(e) && !Fe(t[e]))
            return !1;
    return !0
}
function Ke(t, e) {
    const r = Array.isArray(e) ? e : Sm(e) ? [e] : gS(e)
      , n = r.length === 1 ? t : II(t, r)
      , s = r.length - 1
      , i = r[s];
    return n && delete n[i],
    s !== 0 && (Ve(n) && pt(n) || Array.isArray(n) && DI(n)) && Ke(t, r.slice(0, -1)),
    t
}
var xS = t => {
    for (const e in t)
        if (pr(t[e]))
            return !0;
    return !1
}
;
function vc(t, e={}) {
    const r = Array.isArray(t);
    if (Ve(t) || r)
        for (const n in t)
            Array.isArray(t[n]) || Ve(t[n]) && !xS(t[n]) ? (e[n] = Array.isArray(t[n]) ? [] : {},
            vc(t[n], e[n])) : gt(t[n]) || (e[n] = !0);
    return e
}
function SS(t, e, r) {
    const n = Array.isArray(t);
    if (Ve(t) || n)
        for (const s in t)
            Array.isArray(t[s]) || Ve(t[s]) && !xS(t[s]) ? Fe(e) || Wh(r[s]) ? r[s] = Array.isArray(t[s]) ? vc(t[s], []) : {
                ...vc(t[s])
            } : SS(t[s], gt(e) ? {} : e[s], r[s]) : r[s] = !Tn(t[s], e[s]);
    return r
}
var Go = (t, e) => SS(t, e, vc(e));
const cy = {
    value: !1,
    isValid: !1
}
  , dy = {
    value: !0,
    isValid: !0
};
var ES = t => {
    if (Array.isArray(t)) {
        if (t.length > 1) {
            const e = t.filter(r => r && r.checked && !r.disabled).map(r => r.value);
            return {
                value: e,
                isValid: !!e.length
            }
        }
        return t[0].checked && !t[0].disabled ? t[0].attributes && !Fe(t[0].attributes.value) ? Fe(t[0].value) || t[0].value === "" ? dy : {
            value: t[0].value,
            isValid: !0
        } : dy : cy
    }
    return cy
}
  , kS = (t, {valueAsNumber: e, valueAsDate: r, setValueAs: n}) => Fe(t) ? t : e ? t === "" ? NaN : t && +t : r && Ir(t) ? new Date(t) : n ? n(t) : t;
const fy = {
    isValid: !1,
    value: null
};
var CS = t => Array.isArray(t) ? t.reduce( (e, r) => r && r.checked && !r.disabled ? {
    isValid: !0,
    value: r.value
} : e, fy) : fy;
function hy(t) {
    const e = t.ref;
    return Em(e) ? e.files : km(e) ? CS(t.refs).value : bS(e) ? [...e.selectedOptions].map( ({value: r}) => r) : wl(e) ? ES(t.refs).value : kS(Fe(e.value) ? t.ref.value : e.value, t)
}
var MI = (t, e, r, n) => {
    const s = {};
    for (const i of t) {
        const o = U(e, i);
        o && we(s, i, o._f)
    }
    return {
        criteriaMode: r,
        names: [...t],
        fields: s,
        shouldUseNativeValidation: n
    }
}
  , yc = t => t instanceof RegExp
  , Qo = t => Fe(t) ? t : yc(t) ? t.source : Ve(t) ? yc(t.value) ? t.value.source : t.value : t
  , py = t => ({
    isOnSubmit: !t || t === hr.onSubmit,
    isOnBlur: t === hr.onBlur,
    isOnChange: t === hr.onChange,
    isOnAll: t === hr.all,
    isOnTouch: t === hr.onTouched
});
const my = "AsyncFunction";
var LI = t => !!t && !!t.validate && !!(pr(t.validate) && t.validate.constructor.name === my || Ve(t.validate) && Object.values(t.validate).find(e => e.constructor.name === my))
  , $I = t => t.mount && (t.required || t.min || t.max || t.maxLength || t.minLength || t.pattern || t.validate)
  , gy = (t, e, r) => !r && (e.watchAll || e.watch.has(t) || [...e.watch].some(n => t.startsWith(n) && /^\.\w+/.test(t.slice(n.length))));
const ya = (t, e, r, n) => {
    for (const s of r || Object.keys(t)) {
        const i = U(t, s);
        if (i) {
            const {_f: o, ...a} = i;
            if (o) {
                if (o.refs && o.refs[0] && e(o.refs[0], s) && !n)
                    return !0;
                if (o.ref && e(o.ref, o.name) && !n)
                    return !0;
                if (ya(a, e))
                    break
            } else if (Ve(a) && ya(a, e))
                break
        }
    }
}
;
function vy(t, e, r) {
    const n = U(t, r);
    if (n || Sm(r))
        return {
            error: n,
            name: r
        };
    const s = r.split(".");
    for (; s.length; ) {
        const i = s.join(".")
          , o = U(e, i)
          , a = U(t, i);
        if (o && !Array.isArray(o) && r !== i)
            return {
                name: r
            };
        if (a && a.type)
            return {
                name: i,
                error: a
            };
        s.pop()
    }
    return {
        name: r
    }
}
var FI = (t, e, r, n) => {
    r(t);
    const {name: s, ...i} = t;
    return pt(i) || Object.keys(i).length >= Object.keys(e).length || Object.keys(i).find(o => e[o] === (!n || hr.all))
}
  , UI = (t, e, r) => !t || !e || t === e || va(t).some(n => n && (r ? n === e : n.startsWith(e) || e.startsWith(n)))
  , VI = (t, e, r, n, s) => s.isOnAll ? !1 : !r && s.isOnTouch ? !(e || t) : (r ? n.isOnBlur : s.isOnBlur) ? !t : (r ? n.isOnChange : s.isOnChange) ? t : !0
  , BI = (t, e) => !nd(U(t, e)).length && Ke(t, e)
  , zI = (t, e, r) => {
    const n = va(U(t, r));
    return we(n, "root", e[r]),
    we(t, r, n),
    t
}
  , ku = t => Ir(t);
function yy(t, e, r="validate") {
    if (ku(t) || Array.isArray(t) && t.every(ku) || Dt(t) && !t)
        return {
            type: r,
            message: ku(t) ? t : "",
            ref: e
        }
}
var li = t => Ve(t) && !yc(t) ? t : {
    value: t,
    message: ""
}
  , wy = async (t, e, r, n, s, i) => {
    const {ref: o, refs: a, required: l, maxLength: u, minLength: c, min: d, max: f, pattern: p, validate: g, name: h, valueAsNumber: w, mount: v} = t._f
      , m = U(r, h);
    if (!v || e.has(h))
        return {};
    const _ = a ? a[0] : o
      , x = D => {
        s && _.reportValidity && (_.setCustomValidity(Dt(D) ? "" : D || ""),
        _.reportValidity())
    }
      , k = {}
      , T = km(o)
      , C = wl(o)
      , P = T || C
      , j = (w || Em(o)) && Fe(o.value) && Fe(m) || gc(o) && o.value === "" || m === "" || Array.isArray(m) && !m.length
      , $ = _S.bind(null, h, n, k)
      , X = (D, H, M, ie=Wr.maxLength, te=Wr.minLength) => {
        const oe = D ? H : M;
        k[h] = {
            type: D ? ie : te,
            message: oe,
            ref: o,
            ...$(D ? ie : te, oe)
        }
    }
    ;
    if (i ? !Array.isArray(m) || !m.length : l && (!P && (j || gt(m)) || Dt(m) && !m || C && !ES(a).isValid || T && !CS(a).isValid)) {
        const {value: D, message: H} = ku(l) ? {
            value: !!l,
            message: l
        } : li(l);
        if (D && (k[h] = {
            type: Wr.required,
            message: H,
            ref: _,
            ...$(Wr.required, H)
        },
        !n))
            return x(H),
            k
    }
    if (!j && (!gt(d) || !gt(f))) {
        let D, H;
        const M = li(f)
          , ie = li(d);
        if (!gt(m) && !isNaN(m)) {
            const te = o.valueAsNumber || m && +m;
            gt(M.value) || (D = te > M.value),
            gt(ie.value) || (H = te < ie.value)
        } else {
            const te = o.valueAsDate || new Date(m)
              , oe = Y => new Date(new Date().toDateString() + " " + Y)
              , A = o.type == "time"
              , V = o.type == "week";
            Ir(M.value) && m && (D = A ? oe(m) > oe(M.value) : V ? m > M.value : te > new Date(M.value)),
            Ir(ie.value) && m && (H = A ? oe(m) < oe(ie.value) : V ? m < ie.value : te < new Date(ie.value))
        }
        if ((D || H) && (X(!!D, M.message, ie.message, Wr.max, Wr.min),
        !n))
            return x(k[h].message),
            k
    }
    if ((u || c) && !j && (Ir(m) || i && Array.isArray(m))) {
        const D = li(u)
          , H = li(c)
          , M = !gt(D.value) && m.length > +D.value
          , ie = !gt(H.value) && m.length < +H.value;
        if ((M || ie) && (X(M, D.message, H.message),
        !n))
            return x(k[h].message),
            k
    }
    if (p && !j && Ir(m)) {
        const {value: D, message: H} = li(p);
        if (yc(D) && !m.match(D) && (k[h] = {
            type: Wr.pattern,
            message: H,
            ref: o,
            ...$(Wr.pattern, H)
        },
        !n))
            return x(H),
            k
    }
    if (g) {
        if (pr(g)) {
            const D = await g(m, r)
              , H = yy(D, _);
            if (H && (k[h] = {
                ...H,
                ...$(Wr.validate, H.message)
            },
            !n))
                return x(H.message),
                k
        } else if (Ve(g)) {
            let D = {};
            for (const H in g) {
                if (!pt(D) && !n)
                    break;
                const M = yy(await g[H](m, r), _, H);
                M && (D = {
                    ...M,
                    ...$(H, M.message)
                },
                x(M.message),
                n && (k[h] = D))
            }
            if (!pt(D) && (k[h] = {
                ref: _,
                ...D
            },
            !n))
                return k
        }
    }
    return x(!0),
    k
}
;
const WI = {
    mode: hr.onSubmit,
    reValidateMode: hr.onChange,
    shouldFocusError: !0
};
function HI(t={}) {
    let e = {
        ...WI,
        ...t
    }
      , r = {
        submitCount: 0,
        isDirty: !1,
        isLoading: pr(e.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: e.errors || {},
        disabled: e.disabled || !1
    };
    const n = {};
    let s = Ve(e.defaultValues) || Ve(e.values) ? et(e.values || e.defaultValues) || {} : {}, i = e.shouldUnregister ? {} : et(s), o = {
        action: !1,
        mount: !1,
        watch: !1
    }, a = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, l, u = 0;
    const c = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    };
    let d = {
        ...c
    };
    const f = {
        array: uy(),
        state: uy()
    }
      , p = py(e.mode)
      , g = py(e.reValidateMode)
      , h = e.criteriaMode === hr.all
      , w = S => O => {
        clearTimeout(u),
        u = setTimeout(S, O)
    }
      , v = async S => {
        if (!e.disabled && (c.isValid || d.isValid || S)) {
            const O = e.resolver ? pt((await j()).errors) : await X(n, !0);
            O !== r.isValid && f.state.next({
                isValid: O
            })
        }
    }
      , m = (S, O) => {
        !e.disabled && (c.isValidating || c.validatingFields || d.isValidating || d.validatingFields) && ((S || Array.from(a.mount)).forEach(R => {
            R && (O ? we(r.validatingFields, R, O) : Ke(r.validatingFields, R))
        }
        ),
        f.state.next({
            validatingFields: r.validatingFields,
            isValidating: !pt(r.validatingFields)
        }))
    }
      , _ = (S, O=[], R, q, F=!0, L=!0) => {
        if (q && R && !e.disabled) {
            if (o.action = !0,
            L && Array.isArray(U(n, S))) {
                const G = R(U(n, S), q.argA, q.argB);
                F && we(n, S, G)
            }
            if (L && Array.isArray(U(r.errors, S))) {
                const G = R(U(r.errors, S), q.argA, q.argB);
                F && we(r.errors, S, G),
                BI(r.errors, S)
            }
            if ((c.touchedFields || d.touchedFields) && L && Array.isArray(U(r.touchedFields, S))) {
                const G = R(U(r.touchedFields, S), q.argA, q.argB);
                F && we(r.touchedFields, S, G)
            }
            (c.dirtyFields || d.dirtyFields) && (r.dirtyFields = Go(s, i)),
            f.state.next({
                name: S,
                isDirty: H(S, O),
                dirtyFields: r.dirtyFields,
                errors: r.errors,
                isValid: r.isValid
            })
        } else
            we(i, S, O)
    }
      , x = (S, O) => {
        we(r.errors, S, O),
        f.state.next({
            errors: r.errors
        })
    }
      , k = S => {
        r.errors = S,
        f.state.next({
            errors: r.errors,
            isValid: !1
        })
    }
      , T = (S, O, R, q) => {
        const F = U(n, S);
        if (F) {
            const L = U(i, S, Fe(R) ? U(s, S) : R);
            Fe(L) || q && q.defaultChecked || O ? we(i, S, O ? L : hy(F._f)) : te(S, L),
            o.mount && v()
        }
    }
      , C = (S, O, R, q, F) => {
        let L = !1
          , G = !1;
        const ve = {
            name: S
        };
        if (!e.disabled) {
            if (!R || q) {
                (c.isDirty || d.isDirty) && (G = r.isDirty,
                r.isDirty = ve.isDirty = H(),
                L = G !== ve.isDirty);
                const ze = Tn(U(s, S), O);
                G = !!U(r.dirtyFields, S),
                ze ? Ke(r.dirtyFields, S) : we(r.dirtyFields, S, !0),
                ve.dirtyFields = r.dirtyFields,
                L = L || (c.dirtyFields || d.dirtyFields) && G !== !ze
            }
            if (R) {
                const ze = U(r.touchedFields, S);
                ze || (we(r.touchedFields, S, R),
                ve.touchedFields = r.touchedFields,
                L = L || (c.touchedFields || d.touchedFields) && ze !== R)
            }
            L && F && f.state.next(ve)
        }
        return L ? ve : {}
    }
      , P = (S, O, R, q) => {
        const F = U(r.errors, S)
          , L = (c.isValid || d.isValid) && Dt(O) && r.isValid !== O;
        if (e.delayError && R ? (l = w( () => x(S, R)),
        l(e.delayError)) : (clearTimeout(u),
        l = null,
        R ? we(r.errors, S, R) : Ke(r.errors, S)),
        (R ? !Tn(F, R) : F) || !pt(q) || L) {
            const G = {
                ...q,
                ...L && Dt(O) ? {
                    isValid: O
                } : {},
                errors: r.errors,
                name: S
            };
            r = {
                ...r,
                ...G
            },
            f.state.next(G)
        }
    }
      , j = async S => {
        m(S, !0);
        const O = await e.resolver(i, e.context, MI(S || a.mount, n, e.criteriaMode, e.shouldUseNativeValidation));
        return m(S),
        O
    }
      , $ = async S => {
        const {errors: O} = await j(S);
        if (S)
            for (const R of S) {
                const q = U(O, R);
                q ? we(r.errors, R, q) : Ke(r.errors, R)
            }
        else
            r.errors = O;
        return O
    }
      , X = async (S, O, R={
        valid: !0
    }) => {
        for (const q in S) {
            const F = S[q];
            if (F) {
                const {_f: L, ...G} = F;
                if (L) {
                    const ve = a.array.has(L.name)
                      , ze = F._f && LI(F._f);
                    ze && c.validatingFields && m([q], !0);
                    const it = await wy(F, a.disabled, i, h, e.shouldUseNativeValidation && !O, ve);
                    if (ze && c.validatingFields && m([q]),
                    it[L.name] && (R.valid = !1,
                    O))
                        break;
                    !O && (U(it, L.name) ? ve ? zI(r.errors, it, L.name) : we(r.errors, L.name, it[L.name]) : Ke(r.errors, L.name))
                }
                !pt(G) && await X(G, O, R)
            }
        }
        return R.valid
    }
      , D = () => {
        for (const S of a.unMount) {
            const O = U(n, S);
            O && (O._f.refs ? O._f.refs.every(R => !sf(R)) : !sf(O._f.ref)) && Ys(S)
        }
        a.unMount = new Set
    }
      , H = (S, O) => !e.disabled && (S && O && we(i, S, O),
    !Tn(Ee(), s))
      , M = (S, O, R) => wS(S, a, {
        ...o.mount ? i : Fe(O) ? s : Ir(S) ? {
            [S]: O
        } : O
    }, R, O)
      , ie = S => nd(U(o.mount ? i : s, S, e.shouldUnregister ? U(s, S, []) : []))
      , te = (S, O, R={}) => {
        const q = U(n, S);
        let F = O;
        if (q) {
            const L = q._f;
            L && (!L.disabled && we(i, S, kS(O, L)),
            F = gc(L.ref) && gt(O) ? "" : O,
            bS(L.ref) ? [...L.ref.options].forEach(G => G.selected = F.includes(G.value)) : L.refs ? wl(L.ref) ? L.refs.length > 1 ? L.refs.forEach(G => (!G.defaultChecked || !G.disabled) && (G.checked = Array.isArray(F) ? !!F.find(ve => ve === G.value) : F === G.value)) : L.refs[0] && (L.refs[0].checked = !!F) : L.refs.forEach(G => G.checked = G.value === F) : Em(L.ref) ? L.ref.value = "" : (L.ref.value = F,
            L.ref.type || f.state.next({
                name: S,
                values: et(i)
            })))
        }
        (R.shouldDirty || R.shouldTouch) && C(S, F, R.shouldTouch, R.shouldDirty, !0),
        R.shouldValidate && ae(S)
    }
      , oe = (S, O, R) => {
        for (const q in O) {
            const F = O[q]
              , L = `${S}.${q}`
              , G = U(n, L);
            (a.array.has(S) || Ve(F) || G && !G._f) && !ks(F) ? oe(L, F, R) : te(L, F, R)
        }
    }
      , A = (S, O, R={}) => {
        const q = U(n, S)
          , F = a.array.has(S)
          , L = et(O);
        we(i, S, L),
        F ? (f.array.next({
            name: S,
            values: et(i)
        }),
        (c.isDirty || c.dirtyFields || d.isDirty || d.dirtyFields) && R.shouldDirty && f.state.next({
            name: S,
            dirtyFields: Go(s, i),
            isDirty: H(S, L)
        })) : q && !q._f && !gt(L) ? oe(S, L, R) : te(S, L, R),
        gy(S, a) && f.state.next({
            ...r
        }),
        f.state.next({
            name: o.mount ? S : void 0,
            values: et(i)
        })
    }
      , V = async S => {
        o.mount = !0;
        const O = S.target;
        let R = O.name
          , q = !0;
        const F = U(n, R)
          , L = G => {
            q = Number.isNaN(G) || ks(G) && isNaN(G.getTime()) || Tn(G, U(i, R, G))
        }
        ;
        if (F) {
            let G, ve;
            const ze = O.type ? hy(F._f) : pS(S)
              , it = S.type === mc.BLUR || S.type === mc.FOCUS_OUT
              , LE = !$I(F._f) && !e.resolver && !U(r.errors, R) && !F._f.deps || VI(it, U(r.touchedFields, R), r.isSubmitted, g, p)
              , cd = gy(R, a, it);
            we(i, R, ze),
            it ? (F._f.onBlur && F._f.onBlur(S),
            l && l(0)) : F._f.onChange && F._f.onChange(S);
            const dd = C(R, ze, it)
              , $E = !pt(dd) || cd;
            if (!it && f.state.next({
                name: R,
                type: S.type,
                values: et(i)
            }),
            LE)
                return (c.isValid || d.isValid) && (e.mode === "onBlur" ? it && v() : it || v()),
                $E && f.state.next({
                    name: R,
                    ...cd ? {} : dd
                });
            if (!it && cd && f.state.next({
                ...r
            }),
            e.resolver) {
                const {errors: Fm} = await j([R]);
                if (L(ze),
                q) {
                    const FE = vy(r.errors, n, R)
                      , Um = vy(Fm, n, FE.name || R);
                    G = Um.error,
                    R = Um.name,
                    ve = pt(Fm)
                }
            } else
                m([R], !0),
                G = (await wy(F, a.disabled, i, h, e.shouldUseNativeValidation))[R],
                m([R]),
                L(ze),
                q && (G ? ve = !1 : (c.isValid || d.isValid) && (ve = await X(n, !0)));
            q && (F._f.deps && ae(F._f.deps),
            P(R, ve, G, dd))
        }
    }
      , Y = (S, O) => {
        if (U(r.errors, O) && S.focus)
            return S.focus(),
            1
    }
      , ae = async (S, O={}) => {
        let R, q;
        const F = va(S);
        if (e.resolver) {
            const L = await $(Fe(S) ? S : F);
            R = pt(L),
            q = S ? !F.some(G => U(L, G)) : R
        } else
            S ? (q = (await Promise.all(F.map(async L => {
                const G = U(n, L);
                return await X(G && G._f ? {
                    [L]: G
                } : G)
            }
            ))).every(Boolean),
            !(!q && !r.isValid) && v()) : q = R = await X(n);
        return f.state.next({
            ...!Ir(S) || (c.isValid || d.isValid) && R !== r.isValid ? {} : {
                name: S
            },
            ...e.resolver || !S ? {
                isValid: R
            } : {},
            errors: r.errors
        }),
        O.shouldFocus && !q && ya(n, Y, S ? F : a.mount),
        q
    }
      , Ee = S => {
        const O = {
            ...o.mount ? i : s
        };
        return Fe(S) ? O : Ir(S) ? U(O, S) : S.map(R => U(O, R))
    }
      , xt = (S, O) => ({
        invalid: !!U((O || r).errors, S),
        isDirty: !!U((O || r).dirtyFields, S),
        error: U((O || r).errors, S),
        isValidating: !!U(r.validatingFields, S),
        isTouched: !!U((O || r).touchedFields, S)
    })
      , St = S => {
        S && va(S).forEach(O => Ke(r.errors, O)),
        f.state.next({
            errors: S ? r.errors : {}
        })
    }
      , pn = (S, O, R) => {
        const q = (U(n, S, {
            _f: {}
        })._f || {}).ref
          , F = U(r.errors, S) || {}
          , {ref: L, message: G, type: ve, ...ze} = F;
        we(r.errors, S, {
            ...ze,
            ...O,
            ref: q
        }),
        f.state.next({
            name: S,
            errors: r.errors,
            isValid: !1
        }),
        R && R.shouldFocus && q && q.focus && q.focus()
    }
      , nr = (S, O) => pr(S) ? f.state.subscribe({
        next: R => S(M(void 0, O), R)
    }) : M(S, O, !0)
      , kr = S => f.state.subscribe({
        next: O => {
            UI(S.name, O.name, S.exact) && FI(O, S.formState || c, Xs, S.reRenderRoot) && S.callback({
                values: {
                    ...i
                },
                ...r,
                ...O
            })
        }
    }).unsubscribe
      , bl = S => (o.mount = !0,
    d = {
        ...d,
        ...S.formState
    },
    kr({
        ...S,
        formState: d
    }))
      , Ys = (S, O={}) => {
        for (const R of S ? va(S) : a.mount)
            a.mount.delete(R),
            a.array.delete(R),
            O.keepValue || (Ke(n, R),
            Ke(i, R)),
            !O.keepError && Ke(r.errors, R),
            !O.keepDirty && Ke(r.dirtyFields, R),
            !O.keepTouched && Ke(r.touchedFields, R),
            !O.keepIsValidating && Ke(r.validatingFields, R),
            !e.shouldUnregister && !O.keepDefaultValue && Ke(s, R);
        f.state.next({
            values: et(i)
        }),
        f.state.next({
            ...r,
            ...O.keepDirty ? {
                isDirty: H()
            } : {}
        }),
        !O.keepIsValid && v()
    }
      , No = ({disabled: S, name: O}) => {
        (Dt(S) && o.mount || S || a.disabled.has(O)) && (S ? a.disabled.add(O) : a.disabled.delete(O))
    }
      , Js = (S, O={}) => {
        let R = U(n, S);
        const q = Dt(O.disabled) || Dt(e.disabled);
        return we(n, S, {
            ...R || {},
            _f: {
                ...R && R._f ? R._f : {
                    ref: {
                        name: S
                    }
                },
                name: S,
                mount: !0,
                ...O
            }
        }),
        a.mount.add(S),
        R ? No({
            disabled: Dt(O.disabled) ? O.disabled : e.disabled,
            name: S
        }) : T(S, !0, O.value),
        {
            ...q ? {
                disabled: O.disabled || e.disabled
            } : {},
            ...e.progressive ? {
                required: !!O.required,
                min: Qo(O.min),
                max: Qo(O.max),
                minLength: Qo(O.minLength),
                maxLength: Qo(O.maxLength),
                pattern: Qo(O.pattern)
            } : {},
            name: S,
            onChange: V,
            onBlur: V,
            ref: F => {
                if (F) {
                    Js(S, O),
                    R = U(n, S);
                    const L = Fe(F.value) && F.querySelectorAll && F.querySelectorAll("input,select,textarea")[0] || F
                      , G = NI(L)
                      , ve = R._f.refs || [];
                    if (G ? ve.find(ze => ze === L) : L === R._f.ref)
                        return;
                    we(n, S, {
                        _f: {
                            ...R._f,
                            ...G ? {
                                refs: [...ve.filter(sf), L, ...Array.isArray(U(s, S)) ? [{}] : []],
                                ref: {
                                    type: L.type,
                                    name: S
                                }
                            } : {
                                ref: L
                            }
                        }
                    }),
                    T(S, !1, void 0, L)
                } else
                    R = U(n, S, {}),
                    R._f && (R._f.mount = !1),
                    (e.shouldUnregister || O.shouldUnregister) && !(mS(a.array, S) && o.action) && a.unMount.add(S)
            }
        }
    }
      , Io = () => e.shouldFocusError && ya(n, Y, a.mount)
      , cs = S => {
        Dt(S) && (f.state.next({
            disabled: S
        }),
        ya(n, (O, R) => {
            const q = U(n, R);
            q && (O.disabled = q._f.disabled || S,
            Array.isArray(q._f.refs) && q._f.refs.forEach(F => {
                F.disabled = q._f.disabled || S
            }
            ))
        }
        , 0, !1))
    }
      , Do = (S, O) => async R => {
        let q;
        R && (R.preventDefault && R.preventDefault(),
        R.persist && R.persist());
        let F = et(i);
        if (f.state.next({
            isSubmitting: !0
        }),
        e.resolver) {
            const {errors: L, values: G} = await j();
            r.errors = L,
            F = G
        } else
            await X(n);
        if (a.disabled.size)
            for (const L of a.disabled)
                we(F, L, void 0);
        if (Ke(r.errors, "root"),
        pt(r.errors)) {
            f.state.next({
                errors: {}
            });
            try {
                await S(F, R)
            } catch (L) {
                q = L
            }
        } else
            O && await O({
                ...r.errors
            }, R),
            Io(),
            setTimeout(Io);
        if (f.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: pt(r.errors) && !q,
            submitCount: r.submitCount + 1,
            errors: r.errors
        }),
        q)
            throw q
    }
      , ld = (S, O={}) => {
        U(n, S) && (Fe(O.defaultValue) ? A(S, et(U(s, S))) : (A(S, O.defaultValue),
        we(s, S, et(O.defaultValue))),
        O.keepTouched || Ke(r.touchedFields, S),
        O.keepDirty || (Ke(r.dirtyFields, S),
        r.isDirty = O.defaultValue ? H(S, et(U(s, S))) : H()),
        O.keepError || (Ke(r.errors, S),
        c.isValid && v()),
        f.state.next({
            ...r
        }))
    }
      , xl = (S, O={}) => {
        const R = S ? et(S) : s
          , q = et(R)
          , F = pt(S)
          , L = F ? s : q;
        if (O.keepDefaultValues || (s = R),
        !O.keepValues) {
            if (O.keepDirtyValues) {
                const G = new Set([...a.mount, ...Object.keys(Go(s, i))]);
                for (const ve of Array.from(G))
                    U(r.dirtyFields, ve) ? we(L, ve, U(i, ve)) : A(ve, U(L, ve))
            } else {
                if (xm && Fe(S))
                    for (const G of a.mount) {
                        const ve = U(n, G);
                        if (ve && ve._f) {
                            const ze = Array.isArray(ve._f.refs) ? ve._f.refs[0] : ve._f.ref;
                            if (gc(ze)) {
                                const it = ze.closest("form");
                                if (it) {
                                    it.reset();
                                    break
                                }
                            }
                        }
                    }
                for (const G of a.mount)
                    A(G, U(L, G))
            }
            i = et(L),
            f.array.next({
                values: {
                    ...L
                }
            }),
            f.state.next({
                values: {
                    ...L
                }
            })
        }
        a = {
            mount: O.keepDirtyValues ? a.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        o.mount = !c.isValid || !!O.keepIsValid || !!O.keepDirtyValues,
        o.watch = !!e.shouldUnregister,
        f.state.next({
            submitCount: O.keepSubmitCount ? r.submitCount : 0,
            isDirty: F ? !1 : O.keepDirty ? r.isDirty : !!(O.keepDefaultValues && !Tn(S, s)),
            isSubmitted: O.keepIsSubmitted ? r.isSubmitted : !1,
            dirtyFields: F ? {} : O.keepDirtyValues ? O.keepDefaultValues && i ? Go(s, i) : r.dirtyFields : O.keepDefaultValues && S ? Go(s, S) : O.keepDirty ? r.dirtyFields : {},
            touchedFields: O.keepTouched ? r.touchedFields : {},
            errors: O.keepErrors ? r.errors : {},
            isSubmitSuccessful: O.keepIsSubmitSuccessful ? r.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , Sl = (S, O) => xl(pr(S) ? S(i) : S, O)
      , ud = (S, O={}) => {
        const R = U(n, S)
          , q = R && R._f;
        if (q) {
            const F = q.refs ? q.refs[0] : q.ref;
            F.focus && (F.focus(),
            O.shouldSelect && pr(F.select) && F.select())
        }
    }
      , Xs = S => {
        r = {
            ...r,
            ...S
        }
    }
      , $m = {
        control: {
            register: Js,
            unregister: Ys,
            getFieldState: xt,
            handleSubmit: Do,
            setError: pn,
            _subscribe: kr,
            _runSchema: j,
            _getWatch: M,
            _getDirty: H,
            _setValid: v,
            _setFieldArray: _,
            _setDisabledField: No,
            _setErrors: k,
            _getFieldArray: ie,
            _reset: xl,
            _resetDefaultValues: () => pr(e.defaultValues) && e.defaultValues().then(S => {
                Sl(S, e.resetOptions),
                f.state.next({
                    isLoading: !1
                })
            }
            ),
            _removeUnmounted: D,
            _disableForm: cs,
            _subjects: f,
            _proxyFormState: c,
            get _fields() {
                return n
            },
            get _formValues() {
                return i
            },
            get _state() {
                return o
            },
            set _state(S) {
                o = S
            },
            get _defaultValues() {
                return s
            },
            get _names() {
                return a
            },
            set _names(S) {
                a = S
            },
            get _formState() {
                return r
            },
            get _options() {
                return e
            },
            set _options(S) {
                e = {
                    ...e,
                    ...S
                }
            }
        },
        subscribe: bl,
        trigger: ae,
        register: Js,
        handleSubmit: Do,
        watch: nr,
        setValue: A,
        getValues: Ee,
        reset: Sl,
        resetField: ld,
        clearErrors: St,
        unregister: Ys,
        setError: pn,
        setFocus: ud,
        getFieldState: xt
    };
    return {
        ...$m,
        formControl: $m
    }
}
function qI(t={}) {
    const e = le.useRef(void 0)
      , r = le.useRef(void 0)
      , [n,s] = le.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: pr(t.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: t.errors || {},
        disabled: t.disabled || !1,
        defaultValues: pr(t.defaultValues) ? void 0 : t.defaultValues
    });
    e.current || (e.current = {
        ...t.formControl ? t.formControl : HI(t),
        formState: n
    },
    t.formControl && t.defaultValues && !pr(t.defaultValues) && t.formControl.reset(t.defaultValues, t.resetOptions));
    const i = e.current.control;
    return i._options = t,
    le.useLayoutEffect( () => i._subscribe({
        formState: i._proxyFormState,
        callback: () => s({
            ...i._formState
        }),
        reRenderRoot: !0
    }), [i]),
    le.useEffect( () => i._disableForm(t.disabled), [i, t.disabled]),
    le.useEffect( () => {
        if (i._proxyFormState.isDirty) {
            const o = i._getDirty();
            o !== n.isDirty && i._subjects.state.next({
                isDirty: o
            })
        }
    }
    , [i, n.isDirty]),
    le.useEffect( () => {
        t.values && !Tn(t.values, r.current) ? (i._reset(t.values, i._options.resetOptions),
        r.current = t.values,
        s(o => ({
            ...o
        }))) : i._resetDefaultValues()
    }
    , [t.values, i]),
    le.useEffect( () => {
        t.errors && !pt(t.errors) && i._setErrors(t.errors)
    }
    , [t.errors, i]),
    le.useEffect( () => {
        i._state.mount || (i._setValid(),
        i._state.mount = !0),
        i._state.watch && (i._state.watch = !1,
        i._subjects.state.next({
            ...i._formState
        })),
        i._removeUnmounted()
    }
    ),
    le.useEffect( () => {
        t.shouldUnregister && i._subjects.state.next({
            values: i._getWatch()
        })
    }
    , [t.shouldUnregister, i]),
    e.current.formState = yS(n, i),
    e.current
}
const _y = (t, e, r) => {
    if (t && "reportValidity"in t) {
        const n = U(r, e);
        t.setCustomValidity(n && n.message || ""),
        t.reportValidity()
    }
}
  , TS = (t, e) => {
    for (const r in e.fields) {
        const n = e.fields[r];
        n && n.ref && "reportValidity"in n.ref ? _y(n.ref, r, t) : n.refs && n.refs.forEach(s => _y(s, r, t))
    }
}
  , KI = (t, e) => {
    e.shouldUseNativeValidation && TS(t, e);
    const r = {};
    for (const n in t) {
        const s = U(e.fields, n)
          , i = Object.assign(t[n] || {}, {
            ref: s && s.ref
        });
        if (GI(e.names || Object.keys(t), n)) {
            const o = Object.assign({}, U(r, n));
            we(o, "root", i),
            we(r, n, o)
        } else
            we(r, n, i)
    }
    return r
}
  , GI = (t, e) => t.some(r => r.startsWith(e + "."));
var QI = function(t, e) {
    for (var r = {}; t.length; ) {
        var n = t[0]
          , s = n.code
          , i = n.message
          , o = n.path.join(".");
        if (!r[o])
            if ("unionErrors"in n) {
                var a = n.unionErrors[0].errors[0];
                r[o] = {
                    message: a.message,
                    type: a.code
                }
            } else
                r[o] = {
                    message: i,
                    type: s
                };
        if ("unionErrors"in n && n.unionErrors.forEach(function(c) {
            return c.errors.forEach(function(d) {
                return t.push(d)
            })
        }),
        e) {
            var l = r[o].types
              , u = l && l[n.code];
            r[o] = _S(o, e, r, s, u ? [].concat(u, n.message) : n.message)
        }
        t.shift()
    }
    return r
}, ZI = function(t, e, r) {
    return r === void 0 && (r = {}),
    function(n, s, i) {
        try {
            return Promise.resolve(function(o, a) {
                try {
                    var l = Promise.resolve(t[r.mode === "sync" ? "parse" : "parseAsync"](n, e)).then(function(u) {
                        return i.shouldUseNativeValidation && TS({}, i),
                        {
                            errors: {},
                            values: r.raw ? n : u
                        }
                    })
                } catch (u) {
                    return a(u)
                }
                return l && l.then ? l.then(void 0, a) : l
            }(0, function(o) {
                if (function(a) {
                    return Array.isArray(a == null ? void 0 : a.errors)
                }(o))
                    return {
                        values: {},
                        errors: KI(QI(o.errors, !i.shouldUseNativeValidation && i.criteriaMode === "all"), i)
                    };
                throw o
            }))
        } catch (o) {
            return Promise.reject(o)
        }
    }
}, me;
(function(t) {
    t.assertEqual = s => s;
    function e(s) {}
    t.assertIs = e;
    function r(s) {
        throw new Error
    }
    t.assertNever = r,
    t.arrayToEnum = s => {
        const i = {};
        for (const o of s)
            i[o] = o;
        return i
    }
    ,
    t.getValidEnumValues = s => {
        const i = t.objectKeys(s).filter(a => typeof s[s[a]] != "number")
          , o = {};
        for (const a of i)
            o[a] = s[a];
        return t.objectValues(o)
    }
    ,
    t.objectValues = s => t.objectKeys(s).map(function(i) {
        return s[i]
    }),
    t.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
        const i = [];
        for (const o in s)
            Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
        return i
    }
    ,
    t.find = (s, i) => {
        for (const o of s)
            if (i(o))
                return o
    }
    ,
    t.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
    function n(s, i=" | ") {
        return s.map(o => typeof o == "string" ? `'${o}'` : o).join(i)
    }
    t.joinValues = n,
    t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i
}
)(me || (me = {}));
var Hh;
(function(t) {
    t.mergeShapes = (e, r) => ({
        ...e,
        ...r
    })
}
)(Hh || (Hh = {}));
const W = me.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , Zr = t => {
    switch (typeof t) {
    case "undefined":
        return W.undefined;
    case "string":
        return W.string;
    case "number":
        return isNaN(t) ? W.nan : W.number;
    case "boolean":
        return W.boolean;
    case "function":
        return W.function;
    case "bigint":
        return W.bigint;
    case "symbol":
        return W.symbol;
    case "object":
        return Array.isArray(t) ? W.array : t === null ? W.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? W.promise : typeof Map < "u" && t instanceof Map ? W.map : typeof Set < "u" && t instanceof Set ? W.set : typeof Date < "u" && t instanceof Date ? W.date : W.object;
    default:
        return W.unknown
    }
}
  , N = me.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , YI = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class zt extends Error {
    get errors() {
        return this.issues
    }
    constructor(e) {
        super(),
        this.issues = [],
        this.addIssue = n => {
            this.issues = [...this.issues, n]
        }
        ,
        this.addIssues = (n=[]) => {
            this.issues = [...this.issues, ...n]
        }
        ;
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r,
        this.name = "ZodError",
        this.issues = e
    }
    format(e) {
        const r = e || function(i) {
            return i.message
        }
          , n = {
            _errors: []
        }
          , s = i => {
            for (const o of i.issues)
                if (o.code === "invalid_union")
                    o.unionErrors.map(s);
                else if (o.code === "invalid_return_type")
                    s(o.returnTypeError);
                else if (o.code === "invalid_arguments")
                    s(o.argumentsError);
                else if (o.path.length === 0)
                    n._errors.push(r(o));
                else {
                    let a = n
                      , l = 0;
                    for (; l < o.path.length; ) {
                        const u = o.path[l];
                        l === o.path.length - 1 ? (a[u] = a[u] || {
                            _errors: []
                        },
                        a[u]._errors.push(r(o))) : a[u] = a[u] || {
                            _errors: []
                        },
                        a = a[u],
                        l++
                    }
                }
        }
        ;
        return s(this),
        n
    }
    static assert(e) {
        if (!(e instanceof zt))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, me.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e=r => r.message) {
        const r = {}
          , n = [];
        for (const s of this.issues)
            s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [],
            r[s.path[0]].push(e(s))) : n.push(e(s));
        return {
            formErrors: n,
            fieldErrors: r
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
zt.create = t => new zt(t);
const yo = (t, e) => {
    let r;
    switch (t.code) {
    case N.invalid_type:
        t.received === W.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
        break;
    case N.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(t.expected, me.jsonStringifyReplacer)}`;
        break;
    case N.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${me.joinValues(t.keys, ", ")}`;
        break;
    case N.invalid_union:
        r = "Invalid input";
        break;
    case N.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${me.joinValues(t.options)}`;
        break;
    case N.invalid_enum_value:
        r = `Invalid enum value. Expected ${me.joinValues(t.options)}, received '${t.received}'`;
        break;
    case N.invalid_arguments:
        r = "Invalid function arguments";
        break;
    case N.invalid_return_type:
        r = "Invalid function return type";
        break;
    case N.invalid_date:
        r = "Invalid date";
        break;
    case N.invalid_string:
        typeof t.validation == "object" ? "includes"in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`,
        typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith"in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith"in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : me.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
        break;
    case N.too_small:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
        break;
    case N.too_big:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
        break;
    case N.custom:
        r = "Invalid input";
        break;
    case N.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
    case N.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
    case N.not_finite:
        r = "Number must be finite";
        break;
    default:
        r = e.defaultError,
        me.assertNever(t)
    }
    return {
        message: r
    }
}
;
let OS = yo;
function JI(t) {
    OS = t
}
function wc() {
    return OS
}
const _c = t => {
    const {data: e, path: r, errorMaps: n, issueData: s} = t
      , i = [...r, ...s.path || []]
      , o = {
        ...s,
        path: i
    };
    if (s.message !== void 0)
        return {
            ...s,
            path: i,
            message: s.message
        };
    let a = "";
    const l = n.filter(u => !!u).slice().reverse();
    for (const u of l)
        a = u(o, {
            data: e,
            defaultError: a
        }).message;
    return {
        ...s,
        path: i,
        message: a
    }
}
  , XI = [];
function B(t, e) {
    const r = wc()
      , n = _c({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, r, r === yo ? void 0 : yo].filter(s => !!s)
    });
    t.common.issues.push(n)
}
class dt {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, r) {
        const n = [];
        for (const s of r) {
            if (s.status === "aborted")
                return se;
            s.status === "dirty" && e.dirty(),
            n.push(s.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
    static async mergeObjectAsync(e, r) {
        const n = [];
        for (const s of r) {
            const i = await s.key
              , o = await s.value;
            n.push({
                key: i,
                value: o
            })
        }
        return dt.mergeObjectSync(e, n)
    }
    static mergeObjectSync(e, r) {
        const n = {};
        for (const s of r) {
            const {key: i, value: o} = s;
            if (i.status === "aborted" || o.status === "aborted")
                return se;
            i.status === "dirty" && e.dirty(),
            o.status === "dirty" && e.dirty(),
            i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (n[i.value] = o.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
}
const se = Object.freeze({
    status: "aborted"
})
  , ji = t => ({
    status: "dirty",
    value: t
})
  , wt = t => ({
    status: "valid",
    value: t
})
  , qh = t => t.status === "aborted"
  , Kh = t => t.status === "dirty"
  , Ws = t => t.status === "valid"
  , Wa = t => typeof Promise < "u" && t instanceof Promise;
function bc(t, e, r, n) {
    if (typeof e == "function" ? t !== e || !n : !e.has(t))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return e.get(t)
}
function PS(t, e, r, n, s) {
    if (typeof e == "function" ? t !== e || !s : !e.has(t))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return e.set(t, r),
    r
}
var Q;
(function(t) {
    t.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {},
    t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
}
)(Q || (Q = {}));
var na, sa;
class Ur {
    constructor(e, r, n, s) {
        this._cachedPath = [],
        this.parent = e,
        this.data = r,
        this._path = n,
        this._key = s
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const by = (t, e) => {
    if (Ws(e))
        return {
            success: !0,
            data: e.value
        };
    if (!t.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const r = new zt(t.common.issues);
            return this._error = r,
            this._error
        }
    }
}
;
function ue(t) {
    if (!t)
        return {};
    const {errorMap: e, invalid_type_error: r, required_error: n, description: s} = t;
    if (e && (r || n))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: s
    } : {
        errorMap: (o, a) => {
            var l, u;
            const {message: c} = t;
            return o.code === "invalid_enum_value" ? {
                message: c ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: (l = c ?? n) !== null && l !== void 0 ? l : a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: (u = c ?? r) !== null && u !== void 0 ? u : a.defaultError
            }
        }
        ,
        description: s
    }
}
class fe {
    get description() {
        return this._def.description
    }
    _getType(e) {
        return Zr(e.data)
    }
    _getOrReturnCtx(e, r) {
        return r || {
            common: e.parent.common,
            data: e.data,
            parsedType: Zr(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new dt,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: Zr(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const r = this._parse(e);
        if (Wa(r))
            throw new Error("Synchronous parse encountered promise.");
        return r
    }
    _parseAsync(e) {
        const r = this._parse(e);
        return Promise.resolve(r)
    }
    parse(e, r) {
        const n = this.safeParse(e, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    safeParse(e, r) {
        var n;
        const s = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Zr(e)
        }
          , i = this._parseSync({
            data: e,
            path: s.path,
            parent: s
        });
        return by(s, i)
    }
    "~validate"(e) {
        var r, n;
        const s = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Zr(e)
        };
        if (!this["~standard"].async)
            try {
                const i = this._parseSync({
                    data: e,
                    path: [],
                    parent: s
                });
                return Ws(i) ? {
                    value: i.value
                } : {
                    issues: s.common.issues
                }
            } catch (i) {
                !((n = (r = i == null ? void 0 : i.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0),
                s.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: e,
            path: [],
            parent: s
        }).then(i => Ws(i) ? {
            value: i.value
        } : {
            issues: s.common.issues
        })
    }
    async parseAsync(e, r) {
        const n = await this.safeParseAsync(e, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    async safeParseAsync(e, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: Zr(e)
        }
          , s = this._parse({
            data: e,
            path: n.path,
            parent: n
        })
          , i = await (Wa(s) ? s : Promise.resolve(s));
        return by(n, i)
    }
    refine(e, r) {
        const n = s => typeof r == "string" || typeof r > "u" ? {
            message: r
        } : typeof r == "function" ? r(s) : r;
        return this._refinement( (s, i) => {
            const o = e(s)
              , a = () => i.addIssue({
                code: N.custom,
                ...n(s)
            });
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (a(),
            !1)) : o ? !0 : (a(),
            !1)
        }
        )
    }
    refinement(e, r) {
        return this._refinement( (n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r),
        !1))
    }
    _refinement(e) {
        return new Sr({
            schema: this,
            typeName: ne.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    constructor(e) {
        this.spa = this.safeParseAsync,
        this._def = e,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: r => this["~validate"](r)
        }
    }
    optional() {
        return $r.create(this, this._def)
    }
    nullable() {
        return rs.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return wr.create(this)
    }
    promise() {
        return _o.create(this, this._def)
    }
    or(e) {
        return Ga.create([this, e], this._def)
    }
    and(e) {
        return Qa.create(this, e, this._def)
    }
    transform(e) {
        return new Sr({
            ...ue(this._def),
            schema: this,
            typeName: ne.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const r = typeof e == "function" ? e : () => e;
        return new el({
            ...ue(this._def),
            innerType: this,
            defaultValue: r,
            typeName: ne.ZodDefault
        })
    }
    brand() {
        return new Cm({
            typeName: ne.ZodBranded,
            type: this,
            ...ue(this._def)
        })
    }
    catch(e) {
        const r = typeof e == "function" ? e : () => e;
        return new tl({
            ...ue(this._def),
            innerType: this,
            catchValue: r,
            typeName: ne.ZodCatch
        })
    }
    describe(e) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return _l.create(this, e)
    }
    readonly() {
        return rl.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const eD = /^c[^\s-]{8,}$/i
  , tD = /^[0-9a-z]+$/
  , rD = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , nD = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , sD = /^[a-z0-9_-]{21}$/i
  , iD = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , oD = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , aD = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , lD = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let of;
const uD = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , cD = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , dD = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , fD = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , hD = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , pD = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , RS = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , mD = new RegExp(`^${RS}$`);
function AS(t) {
    let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`),
    e
}
function gD(t) {
    return new RegExp(`^${AS(t)}$`)
}
function jS(t) {
    let e = `${RS}T${AS(t)}`;
    const r = [];
    return r.push(t.local ? "Z?" : "Z"),
    t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    e = `${e}(${r.join("|")})`,
    new RegExp(`^${e}$`)
}
function vD(t, e) {
    return !!((e === "v4" || !e) && uD.test(t) || (e === "v6" || !e) && dD.test(t))
}
function yD(t, e) {
    if (!iD.test(t))
        return !1;
    try {
        const [r] = t.split(".")
          , n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "=")
          , s = JSON.parse(atob(n));
        return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e)
    } catch {
        return !1
    }
}
function wD(t, e) {
    return !!((e === "v4" || !e) && cD.test(t) || (e === "v6" || !e) && fD.test(t))
}
class gr extends fe {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== W.string) {
            const i = this._getOrReturnCtx(e);
            return B(i, {
                code: N.invalid_type,
                expected: W.string,
                received: i.parsedType
            }),
            se
        }
        const n = new dt;
        let s;
        for (const i of this._def.checks)
            if (i.kind === "min")
                e.data.length < i.value && (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "max")
                e.data.length > i.value && (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "length") {
                const o = e.data.length > i.value
                  , a = e.data.length < i.value;
                (o || a) && (s = this._getOrReturnCtx(e, s),
                o ? B(s, {
                    code: N.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }) : a && B(s, {
                    code: N.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }),
                n.dirty())
            } else if (i.kind === "email")
                aD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "email",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "emoji")
                of || (of = new RegExp(lD,"u")),
                of.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "emoji",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "uuid")
                nD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "uuid",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "nanoid")
                sD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "nanoid",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid")
                eD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "cuid",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid2")
                tD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "cuid2",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "ulid")
                rD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "ulid",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "url")
                try {
                    new URL(e.data)
                } catch {
                    s = this._getOrReturnCtx(e, s),
                    B(s, {
                        validation: "url",
                        code: N.invalid_string,
                        message: i.message
                    }),
                    n.dirty()
                }
            else
                i.kind === "regex" ? (i.regex.lastIndex = 0,
                i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "regex",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: {
                        includes: i.value,
                        position: i.position
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: {
                        startsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: {
                        endsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "datetime" ? jS(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: "datetime",
                    message: i.message
                }),
                n.dirty()) : i.kind === "date" ? mD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: "date",
                    message: i.message
                }),
                n.dirty()) : i.kind === "time" ? gD(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    code: N.invalid_string,
                    validation: "time",
                    message: i.message
                }),
                n.dirty()) : i.kind === "duration" ? oD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "duration",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "ip" ? vD(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "ip",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "jwt" ? yD(e.data, i.alg) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "jwt",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "cidr" ? wD(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "cidr",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64" ? hD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "base64",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64url" ? pD.test(e.data) || (s = this._getOrReturnCtx(e, s),
                B(s, {
                    validation: "base64url",
                    code: N.invalid_string,
                    message: i.message
                }),
                n.dirty()) : me.assertNever(i);
        return {
            status: n.value,
            value: e.data
        }
    }
    _regex(e, r, n) {
        return this.refinement(s => e.test(s), {
            validation: r,
            code: N.invalid_string,
            ...Q.errToObj(n)
        })
    }
    _addCheck(e) {
        return new gr({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...Q.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...Q.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...Q.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...Q.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...Q.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...Q.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...Q.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...Q.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...Q.errToObj(e)
        })
    }
    base64url(e) {
        return this._addCheck({
            kind: "base64url",
            ...Q.errToObj(e)
        })
    }
    jwt(e) {
        return this._addCheck({
            kind: "jwt",
            ...Q.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...Q.errToObj(e)
        })
    }
    cidr(e) {
        return this._addCheck({
            kind: "cidr",
            ...Q.errToObj(e)
        })
    }
    datetime(e) {
        var r, n;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1,
            local: (n = e == null ? void 0 : e.local) !== null && n !== void 0 ? n : !1,
            ...Q.errToObj(e == null ? void 0 : e.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            ...Q.errToObj(e == null ? void 0 : e.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...Q.errToObj(e)
        })
    }
    regex(e, r) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...Q.errToObj(r)
        })
    }
    includes(e, r) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: r == null ? void 0 : r.position,
            ...Q.errToObj(r == null ? void 0 : r.message)
        })
    }
    startsWith(e, r) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...Q.errToObj(r)
        })
    }
    endsWith(e, r) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...Q.errToObj(r)
        })
    }
    min(e, r) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...Q.errToObj(r)
        })
    }
    max(e, r) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...Q.errToObj(r)
        })
    }
    length(e, r) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...Q.errToObj(r)
        })
    }
    nonempty(e) {
        return this.min(1, Q.errToObj(e))
    }
    trim() {
        return new gr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new gr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new gr({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(e => e.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(e => e.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(e => e.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(e => e.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(e => e.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(e => e.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(e => e.kind === "base64url")
    }
    get minLength() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}
gr.create = t => {
    var e;
    return new gr({
        checks: [],
        typeName: ne.ZodString,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
        ...ue(t)
    })
}
;
function _D(t, e) {
    const r = (t.toString().split(".")[1] || "").length
      , n = (e.toString().split(".")[1] || "").length
      , s = r > n ? r : n
      , i = parseInt(t.toFixed(s).replace(".", ""))
      , o = parseInt(e.toFixed(s).replace(".", ""));
    return i % o / Math.pow(10, s)
}
class Xn extends fe {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== W.number) {
            const i = this._getOrReturnCtx(e);
            return B(i, {
                code: N.invalid_type,
                expected: W.number,
                received: i.parsedType
            }),
            se
        }
        let n;
        const s = new dt;
        for (const i of this._def.checks)
            i.kind === "int" ? me.isInteger(e.data) || (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.invalid_type,
                expected: "integer",
                received: "float",
                message: i.message
            }),
            s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.too_small,
                minimum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.too_big,
                maximum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? _D(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.not_finite,
                message: i.message
            }),
            s.dirty()) : me.assertNever(i);
        return {
            status: s.value,
            value: e.data
        }
    }
    gte(e, r) {
        return this.setLimit("min", e, !0, Q.toString(r))
    }
    gt(e, r) {
        return this.setLimit("min", e, !1, Q.toString(r))
    }
    lte(e, r) {
        return this.setLimit("max", e, !0, Q.toString(r))
    }
    lt(e, r) {
        return this.setLimit("max", e, !1, Q.toString(r))
    }
    setLimit(e, r, n, s) {
        return new Xn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: r,
                inclusive: n,
                message: Q.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new Xn({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: Q.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: Q.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: Q.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: Q.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: Q.toString(e)
        })
    }
    multipleOf(e, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Q.toString(r)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: Q.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: Q.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: Q.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && me.isInteger(e.value))
    }
    get isFinite() {
        let e = null
          , r = null;
        for (const n of this._def.checks) {
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
                return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value)
        }
        return Number.isFinite(r) && Number.isFinite(e)
    }
}
Xn.create = t => new Xn({
    checks: [],
    typeName: ne.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...ue(t)
});
class es extends fe {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce)
            try {
                e.data = BigInt(e.data)
            } catch {
                return this._getInvalidInput(e)
            }
        if (this._getType(e) !== W.bigint)
            return this._getInvalidInput(e);
        let n;
        const s = new dt;
        for (const i of this._def.checks)
            i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.too_small,
                type: "bigint",
                minimum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.too_big,
                type: "bigint",
                maximum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n),
            B(n, {
                code: N.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : me.assertNever(i);
        return {
            status: s.value,
            value: e.data
        }
    }
    _getInvalidInput(e) {
        const r = this._getOrReturnCtx(e);
        return B(r, {
            code: N.invalid_type,
            expected: W.bigint,
            received: r.parsedType
        }),
        se
    }
    gte(e, r) {
        return this.setLimit("min", e, !0, Q.toString(r))
    }
    gt(e, r) {
        return this.setLimit("min", e, !1, Q.toString(r))
    }
    lte(e, r) {
        return this.setLimit("max", e, !0, Q.toString(r))
    }
    lt(e, r) {
        return this.setLimit("max", e, !1, Q.toString(r))
    }
    setLimit(e, r, n, s) {
        return new es({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: r,
                inclusive: n,
                message: Q.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new es({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: Q.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: Q.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: Q.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: Q.toString(e)
        })
    }
    multipleOf(e, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: Q.toString(r)
        })
    }
    get minValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}
es.create = t => {
    var e;
    return new es({
        checks: [],
        typeName: ne.ZodBigInt,
        coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
        ...ue(t)
    })
}
;
class Ha extends fe {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== W.boolean) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.boolean,
                received: n.parsedType
            }),
            se
        }
        return wt(e.data)
    }
}
Ha.create = t => new Ha({
    typeName: ne.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...ue(t)
});
class Hs extends fe {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== W.date) {
            const i = this._getOrReturnCtx(e);
            return B(i, {
                code: N.invalid_type,
                expected: W.date,
                received: i.parsedType
            }),
            se
        }
        if (isNaN(e.data.getTime())) {
            const i = this._getOrReturnCtx(e);
            return B(i, {
                code: N.invalid_date
            }),
            se
        }
        const n = new dt;
        let s;
        for (const i of this._def.checks)
            i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s),
            B(s, {
                code: N.too_small,
                message: i.message,
                inclusive: !0,
                exact: !1,
                minimum: i.value,
                type: "date"
            }),
            n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s),
            B(s, {
                code: N.too_big,
                message: i.message,
                inclusive: !0,
                exact: !1,
                maximum: i.value,
                type: "date"
            }),
            n.dirty()) : me.assertNever(i);
        return {
            status: n.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new Hs({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, r) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: Q.toString(r)
        })
    }
    max(e, r) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: Q.toString(r)
        })
    }
    get minDate() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e != null ? new Date(e) : null
    }
}
Hs.create = t => new Hs({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: ne.ZodDate,
    ...ue(t)
});
class xc extends fe {
    _parse(e) {
        if (this._getType(e) !== W.symbol) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.symbol,
                received: n.parsedType
            }),
            se
        }
        return wt(e.data)
    }
}
xc.create = t => new xc({
    typeName: ne.ZodSymbol,
    ...ue(t)
});
class qa extends fe {
    _parse(e) {
        if (this._getType(e) !== W.undefined) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.undefined,
                received: n.parsedType
            }),
            se
        }
        return wt(e.data)
    }
}
qa.create = t => new qa({
    typeName: ne.ZodUndefined,
    ...ue(t)
});
class Ka extends fe {
    _parse(e) {
        if (this._getType(e) !== W.null) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.null,
                received: n.parsedType
            }),
            se
        }
        return wt(e.data)
    }
}
Ka.create = t => new Ka({
    typeName: ne.ZodNull,
    ...ue(t)
});
class wo extends fe {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(e) {
        return wt(e.data)
    }
}
wo.create = t => new wo({
    typeName: ne.ZodAny,
    ...ue(t)
});
class Ds extends fe {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(e) {
        return wt(e.data)
    }
}
Ds.create = t => new Ds({
    typeName: ne.ZodUnknown,
    ...ue(t)
});
class dn extends fe {
    _parse(e) {
        const r = this._getOrReturnCtx(e);
        return B(r, {
            code: N.invalid_type,
            expected: W.never,
            received: r.parsedType
        }),
        se
    }
}
dn.create = t => new dn({
    typeName: ne.ZodNever,
    ...ue(t)
});
class Sc extends fe {
    _parse(e) {
        if (this._getType(e) !== W.undefined) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.void,
                received: n.parsedType
            }),
            se
        }
        return wt(e.data)
    }
}
Sc.create = t => new Sc({
    typeName: ne.ZodVoid,
    ...ue(t)
});
class wr extends fe {
    _parse(e) {
        const {ctx: r, status: n} = this._processInputParams(e)
          , s = this._def;
        if (r.parsedType !== W.array)
            return B(r, {
                code: N.invalid_type,
                expected: W.array,
                received: r.parsedType
            }),
            se;
        if (s.exactLength !== null) {
            const o = r.data.length > s.exactLength.value
              , a = r.data.length < s.exactLength.value;
            (o || a) && (B(r, {
                code: o ? N.too_big : N.too_small,
                minimum: a ? s.exactLength.value : void 0,
                maximum: o ? s.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: s.exactLength.message
            }),
            n.dirty())
        }
        if (s.minLength !== null && r.data.length < s.minLength.value && (B(r, {
            code: N.too_small,
            minimum: s.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.minLength.message
        }),
        n.dirty()),
        s.maxLength !== null && r.data.length > s.maxLength.value && (B(r, {
            code: N.too_big,
            maximum: s.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.maxLength.message
        }),
        n.dirty()),
        r.common.async)
            return Promise.all([...r.data].map( (o, a) => s.type._parseAsync(new Ur(r,o,r.path,a)))).then(o => dt.mergeArray(n, o));
        const i = [...r.data].map( (o, a) => s.type._parseSync(new Ur(r,o,r.path,a)));
        return dt.mergeArray(n, i)
    }
    get element() {
        return this._def.type
    }
    min(e, r) {
        return new wr({
            ...this._def,
            minLength: {
                value: e,
                message: Q.toString(r)
            }
        })
    }
    max(e, r) {
        return new wr({
            ...this._def,
            maxLength: {
                value: e,
                message: Q.toString(r)
            }
        })
    }
    length(e, r) {
        return new wr({
            ...this._def,
            exactLength: {
                value: e,
                message: Q.toString(r)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
wr.create = (t, e) => new wr({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ne.ZodArray,
    ...ue(e)
});
function pi(t) {
    if (t instanceof Ne) {
        const e = {};
        for (const r in t.shape) {
            const n = t.shape[r];
            e[r] = $r.create(pi(n))
        }
        return new Ne({
            ...t._def,
            shape: () => e
        })
    } else
        return t instanceof wr ? new wr({
            ...t._def,
            type: pi(t.element)
        }) : t instanceof $r ? $r.create(pi(t.unwrap())) : t instanceof rs ? rs.create(pi(t.unwrap())) : t instanceof Vr ? Vr.create(t.items.map(e => pi(e))) : t
}
class Ne extends fe {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const e = this._def.shape()
          , r = me.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: r
        }
    }
    _parse(e) {
        if (this._getType(e) !== W.object) {
            const u = this._getOrReturnCtx(e);
            return B(u, {
                code: N.invalid_type,
                expected: W.object,
                received: u.parsedType
            }),
            se
        }
        const {status: n, ctx: s} = this._processInputParams(e)
          , {shape: i, keys: o} = this._getCached()
          , a = [];
        if (!(this._def.catchall instanceof dn && this._def.unknownKeys === "strip"))
            for (const u in s.data)
                o.includes(u) || a.push(u);
        const l = [];
        for (const u of o) {
            const c = i[u]
              , d = s.data[u];
            l.push({
                key: {
                    status: "valid",
                    value: u
                },
                value: c._parse(new Ur(s,d,s.path,u)),
                alwaysSet: u in s.data
            })
        }
        if (this._def.catchall instanceof dn) {
            const u = this._def.unknownKeys;
            if (u === "passthrough")
                for (const c of a)
                    l.push({
                        key: {
                            status: "valid",
                            value: c
                        },
                        value: {
                            status: "valid",
                            value: s.data[c]
                        }
                    });
            else if (u === "strict")
                a.length > 0 && (B(s, {
                    code: N.unrecognized_keys,
                    keys: a
                }),
                n.dirty());
            else if (u !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const u = this._def.catchall;
            for (const c of a) {
                const d = s.data[c];
                l.push({
                    key: {
                        status: "valid",
                        value: c
                    },
                    value: u._parse(new Ur(s,d,s.path,c)),
                    alwaysSet: c in s.data
                })
            }
        }
        return s.common.async ? Promise.resolve().then(async () => {
            const u = [];
            for (const c of l) {
                const d = await c.key
                  , f = await c.value;
                u.push({
                    key: d,
                    value: f,
                    alwaysSet: c.alwaysSet
                })
            }
            return u
        }
        ).then(u => dt.mergeObjectSync(n, u)) : dt.mergeObjectSync(n, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return Q.errToObj,
        new Ne({
            ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (r, n) => {
                    var s, i, o, a;
                    const l = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && o !== void 0 ? o : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (a = Q.errToObj(e).message) !== null && a !== void 0 ? a : l
                    } : {
                        message: l
                    }
                }
            } : {}
        })
    }
    strip() {
        return new Ne({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new Ne({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new Ne({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new Ne({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: ne.ZodObject
        })
    }
    setKey(e, r) {
        return this.augment({
            [e]: r
        })
    }
    catchall(e) {
        return new Ne({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const r = {};
        return me.objectKeys(e).forEach(n => {
            e[n] && this.shape[n] && (r[n] = this.shape[n])
        }
        ),
        new Ne({
            ...this._def,
            shape: () => r
        })
    }
    omit(e) {
        const r = {};
        return me.objectKeys(this.shape).forEach(n => {
            e[n] || (r[n] = this.shape[n])
        }
        ),
        new Ne({
            ...this._def,
            shape: () => r
        })
    }
    deepPartial() {
        return pi(this)
    }
    partial(e) {
        const r = {};
        return me.objectKeys(this.shape).forEach(n => {
            const s = this.shape[n];
            e && !e[n] ? r[n] = s : r[n] = s.optional()
        }
        ),
        new Ne({
            ...this._def,
            shape: () => r
        })
    }
    required(e) {
        const r = {};
        return me.objectKeys(this.shape).forEach(n => {
            if (e && !e[n])
                r[n] = this.shape[n];
            else {
                let i = this.shape[n];
                for (; i instanceof $r; )
                    i = i._def.innerType;
                r[n] = i
            }
        }
        ),
        new Ne({
            ...this._def,
            shape: () => r
        })
    }
    keyof() {
        return NS(me.objectKeys(this.shape))
    }
}
Ne.create = (t, e) => new Ne({
    shape: () => t,
    unknownKeys: "strip",
    catchall: dn.create(),
    typeName: ne.ZodObject,
    ...ue(e)
});
Ne.strictCreate = (t, e) => new Ne({
    shape: () => t,
    unknownKeys: "strict",
    catchall: dn.create(),
    typeName: ne.ZodObject,
    ...ue(e)
});
Ne.lazycreate = (t, e) => new Ne({
    shape: t,
    unknownKeys: "strip",
    catchall: dn.create(),
    typeName: ne.ZodObject,
    ...ue(e)
});
class Ga extends fe {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = this._def.options;
        function s(i) {
            for (const a of i)
                if (a.result.status === "valid")
                    return a.result;
            for (const a of i)
                if (a.result.status === "dirty")
                    return r.common.issues.push(...a.ctx.common.issues),
                    a.result;
            const o = i.map(a => new zt(a.ctx.common.issues));
            return B(r, {
                code: N.invalid_union,
                unionErrors: o
            }),
            se
        }
        if (r.common.async)
            return Promise.all(n.map(async i => {
                const o = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await i._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: o
                    }),
                    ctx: o
                }
            }
            )).then(s);
        {
            let i;
            const o = [];
            for (const l of n) {
                const u = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }
                  , c = l._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: u
                });
                if (c.status === "valid")
                    return c;
                c.status === "dirty" && !i && (i = {
                    result: c,
                    ctx: u
                }),
                u.common.issues.length && o.push(u.common.issues)
            }
            if (i)
                return r.common.issues.push(...i.ctx.common.issues),
                i.result;
            const a = o.map(l => new zt(l));
            return B(r, {
                code: N.invalid_union,
                unionErrors: a
            }),
            se
        }
    }
    get options() {
        return this._def.options
    }
}
Ga.create = (t, e) => new Ga({
    options: t,
    typeName: ne.ZodUnion,
    ...ue(e)
});
const qr = t => t instanceof Ya ? qr(t.schema) : t instanceof Sr ? qr(t.innerType()) : t instanceof Ja ? [t.value] : t instanceof ts ? t.options : t instanceof Xa ? me.objectValues(t.enum) : t instanceof el ? qr(t._def.innerType) : t instanceof qa ? [void 0] : t instanceof Ka ? [null] : t instanceof $r ? [void 0, ...qr(t.unwrap())] : t instanceof rs ? [null, ...qr(t.unwrap())] : t instanceof Cm || t instanceof rl ? qr(t.unwrap()) : t instanceof tl ? qr(t._def.innerType) : [];
class id extends fe {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== W.object)
            return B(r, {
                code: N.invalid_type,
                expected: W.object,
                received: r.parsedType
            }),
            se;
        const n = this.discriminator
          , s = r.data[n]
          , i = this.optionsMap.get(s);
        return i ? r.common.async ? i._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : i._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (B(r, {
            code: N.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [n]
        }),
        se)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(e, r, n) {
        const s = new Map;
        for (const i of r) {
            const o = qr(i.shape[e]);
            if (!o.length)
                throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const a of o) {
                if (s.has(a))
                    throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
                s.set(a, i)
            }
        }
        return new id({
            typeName: ne.ZodDiscriminatedUnion,
            discriminator: e,
            options: r,
            optionsMap: s,
            ...ue(n)
        })
    }
}
function Gh(t, e) {
    const r = Zr(t)
      , n = Zr(e);
    if (t === e)
        return {
            valid: !0,
            data: t
        };
    if (r === W.object && n === W.object) {
        const s = me.objectKeys(e)
          , i = me.objectKeys(t).filter(a => s.indexOf(a) !== -1)
          , o = {
            ...t,
            ...e
        };
        for (const a of i) {
            const l = Gh(t[a], e[a]);
            if (!l.valid)
                return {
                    valid: !1
                };
            o[a] = l.data
        }
        return {
            valid: !0,
            data: o
        }
    } else if (r === W.array && n === W.array) {
        if (t.length !== e.length)
            return {
                valid: !1
            };
        const s = [];
        for (let i = 0; i < t.length; i++) {
            const o = t[i]
              , a = e[i]
              , l = Gh(o, a);
            if (!l.valid)
                return {
                    valid: !1
                };
            s.push(l.data)
        }
        return {
            valid: !0,
            data: s
        }
    } else
        return r === W.date && n === W.date && +t == +e ? {
            valid: !0,
            data: t
        } : {
            valid: !1
        }
}
class Qa extends fe {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e)
          , s = (i, o) => {
            if (qh(i) || qh(o))
                return se;
            const a = Gh(i.value, o.value);
            return a.valid ? ((Kh(i) || Kh(o)) && r.dirty(),
            {
                status: r.value,
                value: a.data
            }) : (B(n, {
                code: N.invalid_intersection_types
            }),
            se)
        }
        ;
        return n.common.async ? Promise.all([this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        })]).then( ([i,o]) => s(i, o)) : s(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }))
    }
}
Qa.create = (t, e, r) => new Qa({
    left: t,
    right: e,
    typeName: ne.ZodIntersection,
    ...ue(r)
});
class Vr extends fe {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.array)
            return B(n, {
                code: N.invalid_type,
                expected: W.array,
                received: n.parsedType
            }),
            se;
        if (n.data.length < this._def.items.length)
            return B(n, {
                code: N.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            se;
        !this._def.rest && n.data.length > this._def.items.length && (B(n, {
            code: N.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        r.dirty());
        const i = [...n.data].map( (o, a) => {
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new Ur(n,o,n.path,a)) : null
        }
        ).filter(o => !!o);
        return n.common.async ? Promise.all(i).then(o => dt.mergeArray(r, o)) : dt.mergeArray(r, i)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new Vr({
            ...this._def,
            rest: e
        })
    }
}
Vr.create = (t, e) => {
    if (!Array.isArray(t))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Vr({
        items: t,
        typeName: ne.ZodTuple,
        rest: null,
        ...ue(e)
    })
}
;
class Za extends fe {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.object)
            return B(n, {
                code: N.invalid_type,
                expected: W.object,
                received: n.parsedType
            }),
            se;
        const s = []
          , i = this._def.keyType
          , o = this._def.valueType;
        for (const a in n.data)
            s.push({
                key: i._parse(new Ur(n,a,n.path,a)),
                value: o._parse(new Ur(n,n.data[a],n.path,a)),
                alwaysSet: a in n.data
            });
        return n.common.async ? dt.mergeObjectAsync(r, s) : dt.mergeObjectSync(r, s)
    }
    get element() {
        return this._def.valueType
    }
    static create(e, r, n) {
        return r instanceof fe ? new Za({
            keyType: e,
            valueType: r,
            typeName: ne.ZodRecord,
            ...ue(n)
        }) : new Za({
            keyType: gr.create(),
            valueType: e,
            typeName: ne.ZodRecord,
            ...ue(r)
        })
    }
}
class Ec extends fe {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.map)
            return B(n, {
                code: N.invalid_type,
                expected: W.map,
                received: n.parsedType
            }),
            se;
        const s = this._def.keyType
          , i = this._def.valueType
          , o = [...n.data.entries()].map( ([a,l], u) => ({
            key: s._parse(new Ur(n,a,n.path,[u, "key"])),
            value: i._parse(new Ur(n,l,n.path,[u, "value"]))
        }));
        if (n.common.async) {
            const a = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const u = await l.key
                      , c = await l.value;
                    if (u.status === "aborted" || c.status === "aborted")
                        return se;
                    (u.status === "dirty" || c.status === "dirty") && r.dirty(),
                    a.set(u.value, c.value)
                }
                return {
                    status: r.value,
                    value: a
                }
            }
            )
        } else {
            const a = new Map;
            for (const l of o) {
                const u = l.key
                  , c = l.value;
                if (u.status === "aborted" || c.status === "aborted")
                    return se;
                (u.status === "dirty" || c.status === "dirty") && r.dirty(),
                a.set(u.value, c.value)
            }
            return {
                status: r.value,
                value: a
            }
        }
    }
}
Ec.create = (t, e, r) => new Ec({
    valueType: e,
    keyType: t,
    typeName: ne.ZodMap,
    ...ue(r)
});
class qs extends fe {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.set)
            return B(n, {
                code: N.invalid_type,
                expected: W.set,
                received: n.parsedType
            }),
            se;
        const s = this._def;
        s.minSize !== null && n.data.size < s.minSize.value && (B(n, {
            code: N.too_small,
            minimum: s.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.minSize.message
        }),
        r.dirty()),
        s.maxSize !== null && n.data.size > s.maxSize.value && (B(n, {
            code: N.too_big,
            maximum: s.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.maxSize.message
        }),
        r.dirty());
        const i = this._def.valueType;
        function o(l) {
            const u = new Set;
            for (const c of l) {
                if (c.status === "aborted")
                    return se;
                c.status === "dirty" && r.dirty(),
                u.add(c.value)
            }
            return {
                status: r.value,
                value: u
            }
        }
        const a = [...n.data.values()].map( (l, u) => i._parse(new Ur(n,l,n.path,u)));
        return n.common.async ? Promise.all(a).then(l => o(l)) : o(a)
    }
    min(e, r) {
        return new qs({
            ...this._def,
            minSize: {
                value: e,
                message: Q.toString(r)
            }
        })
    }
    max(e, r) {
        return new qs({
            ...this._def,
            maxSize: {
                value: e,
                message: Q.toString(r)
            }
        })
    }
    size(e, r) {
        return this.min(e, r).max(e, r)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
qs.create = (t, e) => new qs({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: ne.ZodSet,
    ...ue(e)
});
class Wi extends fe {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== W.function)
            return B(r, {
                code: N.invalid_type,
                expected: W.function,
                received: r.parsedType
            }),
            se;
        function n(a, l) {
            return _c({
                data: a,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, wc(), yo].filter(u => !!u),
                issueData: {
                    code: N.invalid_arguments,
                    argumentsError: l
                }
            })
        }
        function s(a, l) {
            return _c({
                data: a,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, wc(), yo].filter(u => !!u),
                issueData: {
                    code: N.invalid_return_type,
                    returnTypeError: l
                }
            })
        }
        const i = {
            errorMap: r.common.contextualErrorMap
        }
          , o = r.data;
        if (this._def.returns instanceof _o) {
            const a = this;
            return wt(async function(...l) {
                const u = new zt([])
                  , c = await a._def.args.parseAsync(l, i).catch(p => {
                    throw u.addIssue(n(l, p)),
                    u
                }
                )
                  , d = await Reflect.apply(o, this, c);
                return await a._def.returns._def.type.parseAsync(d, i).catch(p => {
                    throw u.addIssue(s(d, p)),
                    u
                }
                )
            })
        } else {
            const a = this;
            return wt(function(...l) {
                const u = a._def.args.safeParse(l, i);
                if (!u.success)
                    throw new zt([n(l, u.error)]);
                const c = Reflect.apply(o, this, u.data)
                  , d = a._def.returns.safeParse(c, i);
                if (!d.success)
                    throw new zt([s(c, d.error)]);
                return d.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...e) {
        return new Wi({
            ...this._def,
            args: Vr.create(e).rest(Ds.create())
        })
    }
    returns(e) {
        return new Wi({
            ...this._def,
            returns: e
        })
    }
    implement(e) {
        return this.parse(e)
    }
    strictImplement(e) {
        return this.parse(e)
    }
    static create(e, r, n) {
        return new Wi({
            args: e || Vr.create([]).rest(Ds.create()),
            returns: r || Ds.create(),
            typeName: ne.ZodFunction,
            ...ue(n)
        })
    }
}
class Ya extends fe {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        })
    }
}
Ya.create = (t, e) => new Ya({
    getter: t,
    typeName: ne.ZodLazy,
    ...ue(e)
});
class Ja extends fe {
    _parse(e) {
        if (e.data !== this._def.value) {
            const r = this._getOrReturnCtx(e);
            return B(r, {
                received: r.data,
                code: N.invalid_literal,
                expected: this._def.value
            }),
            se
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
Ja.create = (t, e) => new Ja({
    value: t,
    typeName: ne.ZodLiteral,
    ...ue(e)
});
function NS(t, e) {
    return new ts({
        values: t,
        typeName: ne.ZodEnum,
        ...ue(e)
    })
}
class ts extends fe {
    constructor() {
        super(...arguments),
        na.set(this, void 0)
    }
    _parse(e) {
        if (typeof e.data != "string") {
            const r = this._getOrReturnCtx(e)
              , n = this._def.values;
            return B(r, {
                expected: me.joinValues(n),
                received: r.parsedType,
                code: N.invalid_type
            }),
            se
        }
        if (bc(this, na) || PS(this, na, new Set(this._def.values)),
        !bc(this, na).has(e.data)) {
            const r = this._getOrReturnCtx(e)
              , n = this._def.values;
            return B(r, {
                received: r.data,
                code: N.invalid_enum_value,
                options: n
            }),
            se
        }
        return wt(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    get Values() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    get Enum() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    extract(e, r=this._def) {
        return ts.create(e, {
            ...this._def,
            ...r
        })
    }
    exclude(e, r=this._def) {
        return ts.create(this.options.filter(n => !e.includes(n)), {
            ...this._def,
            ...r
        })
    }
}
na = new WeakMap;
ts.create = NS;
class Xa extends fe {
    constructor() {
        super(...arguments),
        sa.set(this, void 0)
    }
    _parse(e) {
        const r = me.getValidEnumValues(this._def.values)
          , n = this._getOrReturnCtx(e);
        if (n.parsedType !== W.string && n.parsedType !== W.number) {
            const s = me.objectValues(r);
            return B(n, {
                expected: me.joinValues(s),
                received: n.parsedType,
                code: N.invalid_type
            }),
            se
        }
        if (bc(this, sa) || PS(this, sa, new Set(me.getValidEnumValues(this._def.values))),
        !bc(this, sa).has(e.data)) {
            const s = me.objectValues(r);
            return B(n, {
                received: n.data,
                code: N.invalid_enum_value,
                options: s
            }),
            se
        }
        return wt(e.data)
    }
    get enum() {
        return this._def.values
    }
}
sa = new WeakMap;
Xa.create = (t, e) => new Xa({
    values: t,
    typeName: ne.ZodNativeEnum,
    ...ue(e)
});
class _o extends fe {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== W.promise && r.common.async === !1)
            return B(r, {
                code: N.invalid_type,
                expected: W.promise,
                received: r.parsedType
            }),
            se;
        const n = r.parsedType === W.promise ? r.data : Promise.resolve(r.data);
        return wt(n.then(s => this._def.type.parseAsync(s, {
            path: r.path,
            errorMap: r.common.contextualErrorMap
        })))
    }
}
_o.create = (t, e) => new _o({
    type: t,
    typeName: ne.ZodPromise,
    ...ue(e)
});
class Sr extends fe {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === ne.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e)
          , s = this._def.effect || null
          , i = {
            addIssue: o => {
                B(n, o),
                o.fatal ? r.abort() : r.dirty()
            }
            ,
            get path() {
                return n.path
            }
        };
        if (i.addIssue = i.addIssue.bind(i),
        s.type === "preprocess") {
            const o = s.transform(n.data, i);
            if (n.common.async)
                return Promise.resolve(o).then(async a => {
                    if (r.value === "aborted")
                        return se;
                    const l = await this._def.schema._parseAsync({
                        data: a,
                        path: n.path,
                        parent: n
                    });
                    return l.status === "aborted" ? se : l.status === "dirty" || r.value === "dirty" ? ji(l.value) : l
                }
                );
            {
                if (r.value === "aborted")
                    return se;
                const a = this._def.schema._parseSync({
                    data: o,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? se : a.status === "dirty" || r.value === "dirty" ? ji(a.value) : a
            }
        }
        if (s.type === "refinement") {
            const o = a => {
                const l = s.refinement(a, i);
                if (n.common.async)
                    return Promise.resolve(l);
                if (l instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a
            }
            ;
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? se : (a.status === "dirty" && r.dirty(),
                o(a.value),
                {
                    status: r.value,
                    value: a.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(a => a.status === "aborted" ? se : (a.status === "dirty" && r.dirty(),
                o(a.value).then( () => ({
                    status: r.value,
                    value: a.value
                }))))
        }
        if (s.type === "transform")
            if (n.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                if (!Ws(o))
                    return o;
                const a = s.transform(o.value, i);
                if (a instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: r.value,
                    value: a
                }
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(o => Ws(o) ? Promise.resolve(s.transform(o.value, i)).then(a => ({
                    status: r.value,
                    value: a
                })) : o);
        me.assertNever(s)
    }
}
Sr.create = (t, e, r) => new Sr({
    schema: t,
    typeName: ne.ZodEffects,
    effect: e,
    ...ue(r)
});
Sr.createWithPreprocess = (t, e, r) => new Sr({
    schema: e,
    effect: {
        type: "preprocess",
        transform: t
    },
    typeName: ne.ZodEffects,
    ...ue(r)
});
class $r extends fe {
    _parse(e) {
        return this._getType(e) === W.undefined ? wt(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
$r.create = (t, e) => new $r({
    innerType: t,
    typeName: ne.ZodOptional,
    ...ue(e)
});
class rs extends fe {
    _parse(e) {
        return this._getType(e) === W.null ? wt(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
rs.create = (t, e) => new rs({
    innerType: t,
    typeName: ne.ZodNullable,
    ...ue(e)
});
class el extends fe {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        let n = r.data;
        return r.parsedType === W.undefined && (n = this._def.defaultValue()),
        this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
el.create = (t, e) => new el({
    innerType: t,
    typeName: ne.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...ue(e)
});
class tl extends fe {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }
          , s = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return Wa(s) ? s.then(i => ({
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new zt(n.common.issues)
                },
                input: n.data
            })
        })) : {
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new zt(n.common.issues)
                },
                input: n.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
tl.create = (t, e) => new tl({
    innerType: t,
    typeName: ne.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...ue(e)
});
class kc extends fe {
    _parse(e) {
        if (this._getType(e) !== W.nan) {
            const n = this._getOrReturnCtx(e);
            return B(n, {
                code: N.invalid_type,
                expected: W.nan,
                received: n.parsedType
            }),
            se
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
kc.create = t => new kc({
    typeName: ne.ZodNaN,
    ...ue(t)
});
const bD = Symbol("zod_brand");
class Cm extends fe {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    unwrap() {
        return this._def.type
    }
}
class _l extends fe {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.common.async)
            return (async () => {
                const i = await this._def.in._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return i.status === "aborted" ? se : i.status === "dirty" ? (r.dirty(),
                ji(i.value)) : this._def.out._parseAsync({
                    data: i.value,
                    path: n.path,
                    parent: n
                })
            }
            )();
        {
            const s = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return s.status === "aborted" ? se : s.status === "dirty" ? (r.dirty(),
            {
                status: "dirty",
                value: s.value
            }) : this._def.out._parseSync({
                data: s.value,
                path: n.path,
                parent: n
            })
        }
    }
    static create(e, r) {
        return new _l({
            in: e,
            out: r,
            typeName: ne.ZodPipeline
        })
    }
}
class rl extends fe {
    _parse(e) {
        const r = this._def.innerType._parse(e)
          , n = s => (Ws(s) && (s.value = Object.freeze(s.value)),
        s);
        return Wa(r) ? r.then(s => n(s)) : n(r)
    }
    unwrap() {
        return this._def.innerType
    }
}
rl.create = (t, e) => new rl({
    innerType: t,
    typeName: ne.ZodReadonly,
    ...ue(e)
});
function xy(t, e) {
    const r = typeof t == "function" ? t(e) : typeof t == "string" ? {
        message: t
    } : t;
    return typeof r == "string" ? {
        message: r
    } : r
}
function IS(t, e={}, r) {
    return t ? wo.create().superRefine( (n, s) => {
        var i, o;
        const a = t(n);
        if (a instanceof Promise)
            return a.then(l => {
                var u, c;
                if (!l) {
                    const d = xy(e, n)
                      , f = (c = (u = d.fatal) !== null && u !== void 0 ? u : r) !== null && c !== void 0 ? c : !0;
                    s.addIssue({
                        code: "custom",
                        ...d,
                        fatal: f
                    })
                }
            }
            );
        if (!a) {
            const l = xy(e, n)
              , u = (o = (i = l.fatal) !== null && i !== void 0 ? i : r) !== null && o !== void 0 ? o : !0;
            s.addIssue({
                code: "custom",
                ...l,
                fatal: u
            })
        }
    }
    ) : wo.create()
}
const xD = {
    object: Ne.lazycreate
};
var ne;
(function(t) {
    t.ZodString = "ZodString",
    t.ZodNumber = "ZodNumber",
    t.ZodNaN = "ZodNaN",
    t.ZodBigInt = "ZodBigInt",
    t.ZodBoolean = "ZodBoolean",
    t.ZodDate = "ZodDate",
    t.ZodSymbol = "ZodSymbol",
    t.ZodUndefined = "ZodUndefined",
    t.ZodNull = "ZodNull",
    t.ZodAny = "ZodAny",
    t.ZodUnknown = "ZodUnknown",
    t.ZodNever = "ZodNever",
    t.ZodVoid = "ZodVoid",
    t.ZodArray = "ZodArray",
    t.ZodObject = "ZodObject",
    t.ZodUnion = "ZodUnion",
    t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    t.ZodIntersection = "ZodIntersection",
    t.ZodTuple = "ZodTuple",
    t.ZodRecord = "ZodRecord",
    t.ZodMap = "ZodMap",
    t.ZodSet = "ZodSet",
    t.ZodFunction = "ZodFunction",
    t.ZodLazy = "ZodLazy",
    t.ZodLiteral = "ZodLiteral",
    t.ZodEnum = "ZodEnum",
    t.ZodEffects = "ZodEffects",
    t.ZodNativeEnum = "ZodNativeEnum",
    t.ZodOptional = "ZodOptional",
    t.ZodNullable = "ZodNullable",
    t.ZodDefault = "ZodDefault",
    t.ZodCatch = "ZodCatch",
    t.ZodPromise = "ZodPromise",
    t.ZodBranded = "ZodBranded",
    t.ZodPipeline = "ZodPipeline",
    t.ZodReadonly = "ZodReadonly"
}
)(ne || (ne = {}));
const SD = (t, e={
    message: `Input not instance of ${t.name}`
}) => IS(r => r instanceof t, e)
  , DS = gr.create
  , MS = Xn.create
  , ED = kc.create
  , kD = es.create
  , LS = Ha.create
  , CD = Hs.create
  , TD = xc.create
  , OD = qa.create
  , PD = Ka.create
  , RD = wo.create
  , AD = Ds.create
  , jD = dn.create
  , ND = Sc.create
  , ID = wr.create
  , DD = Ne.create
  , MD = Ne.strictCreate
  , LD = Ga.create
  , $D = id.create
  , FD = Qa.create
  , UD = Vr.create
  , VD = Za.create
  , BD = Ec.create
  , zD = qs.create
  , WD = Wi.create
  , HD = Ya.create
  , qD = Ja.create
  , KD = ts.create
  , GD = Xa.create
  , QD = _o.create
  , Sy = Sr.create
  , ZD = $r.create
  , YD = rs.create
  , JD = Sr.createWithPreprocess
  , XD = _l.create
  , e2 = () => DS().optional()
  , t2 = () => MS().optional()
  , r2 = () => LS().optional()
  , n2 = {
    string: t => gr.create({
        ...t,
        coerce: !0
    }),
    number: t => Xn.create({
        ...t,
        coerce: !0
    }),
    boolean: t => Ha.create({
        ...t,
        coerce: !0
    }),
    bigint: t => es.create({
        ...t,
        coerce: !0
    }),
    date: t => Hs.create({
        ...t,
        coerce: !0
    })
}
  , s2 = se;
var hs = Object.freeze({
    __proto__: null,
    defaultErrorMap: yo,
    setErrorMap: JI,
    getErrorMap: wc,
    makeIssue: _c,
    EMPTY_PATH: XI,
    addIssueToContext: B,
    ParseStatus: dt,
    INVALID: se,
    DIRTY: ji,
    OK: wt,
    isAborted: qh,
    isDirty: Kh,
    isValid: Ws,
    isAsync: Wa,
    get util() {
        return me
    },
    get objectUtil() {
        return Hh
    },
    ZodParsedType: W,
    getParsedType: Zr,
    ZodType: fe,
    datetimeRegex: jS,
    ZodString: gr,
    ZodNumber: Xn,
    ZodBigInt: es,
    ZodBoolean: Ha,
    ZodDate: Hs,
    ZodSymbol: xc,
    ZodUndefined: qa,
    ZodNull: Ka,
    ZodAny: wo,
    ZodUnknown: Ds,
    ZodNever: dn,
    ZodVoid: Sc,
    ZodArray: wr,
    ZodObject: Ne,
    ZodUnion: Ga,
    ZodDiscriminatedUnion: id,
    ZodIntersection: Qa,
    ZodTuple: Vr,
    ZodRecord: Za,
    ZodMap: Ec,
    ZodSet: qs,
    ZodFunction: Wi,
    ZodLazy: Ya,
    ZodLiteral: Ja,
    ZodEnum: ts,
    ZodNativeEnum: Xa,
    ZodPromise: _o,
    ZodEffects: Sr,
    ZodTransformer: Sr,
    ZodOptional: $r,
    ZodNullable: rs,
    ZodDefault: el,
    ZodCatch: tl,
    ZodNaN: kc,
    BRAND: bD,
    ZodBranded: Cm,
    ZodPipeline: _l,
    ZodReadonly: rl,
    custom: IS,
    Schema: fe,
    ZodSchema: fe,
    late: xD,
    get ZodFirstPartyTypeKind() {
        return ne
    },
    coerce: n2,
    any: RD,
    array: ID,
    bigint: kD,
    boolean: LS,
    date: CD,
    discriminatedUnion: $D,
    effect: Sy,
    enum: KD,
    function: WD,
    instanceof: SD,
    intersection: FD,
    lazy: HD,
    literal: qD,
    map: BD,
    nan: ED,
    nativeEnum: GD,
    never: jD,
    null: PD,
    nullable: YD,
    number: MS,
    object: DD,
    oboolean: r2,
    onumber: t2,
    optional: ZD,
    ostring: e2,
    pipeline: XD,
    preprocess: JD,
    promise: QD,
    record: VD,
    set: zD,
    strictObject: MD,
    string: DS,
    symbol: TD,
    transformer: Sy,
    tuple: UD,
    undefined: OD,
    union: LD,
    unknown: AD,
    void: ND,
    NEVER: s2,
    ZodIssueCode: N,
    quotelessJson: YI,
    ZodError: zt
});
const i2 = hs.object({
    name: hs.string().min(1, "Plant name is required"),
    location: hs.string().min(1, "Location is required"),
    photo_url: hs.string().min(1, "Photo is required"),
    water_frequency_days: hs.number().min(1, "Frequency must be at least 1 day"),
    last_watered_date: hs.string(),
    notes: hs.string().optional().default("")
})
  , $S = b.forwardRef( ({className: t, ...e}, r) => y.jsx("textarea", {
    className: ye("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", t),
    ref: r,
    ...e
}));
$S.displayName = "Textarea";
const o2 = OI
  , FS = b.createContext({})
  , Zo = ({...t}) => y.jsx(FS.Provider, {
    value: {
        name: t.name
    },
    children: y.jsx(jI, {
        ...t
    })
})
  , od = () => {
    const t = b.useContext(FS)
      , e = b.useContext(US)
      , {getFieldState: r, formState: n} = sd()
      , s = r(t.name, n);
    if (!t)
        throw new Error("useFormField should be used within <FormField>");
    const {id: i} = e;
    return {
        id: i,
        name: t.name,
        formItemId: `${i}-form-item`,
        formDescriptionId: `${i}-form-item-description`,
        formMessageId: `${i}-form-item-message`,
        ...s
    }
}
  , US = b.createContext({})
  , mi = b.forwardRef( ({className: t, ...e}, r) => {
    const n = b.useId();
    return y.jsx(US.Provider, {
        value: {
            id: n
        },
        children: y.jsx("div", {
            ref: r,
            className: ye("space-y-2", t),
            ...e
        })
    })
}
);
mi.displayName = "FormItem";
const gi = b.forwardRef( ({className: t, ...e}, r) => {
    const {error: n, formItemId: s} = od();
    return y.jsx(uc, {
        ref: r,
        className: ye(n && "text-destructive", t),
        htmlFor: s,
        ...e
    })
}
);
gi.displayName = "FormLabel";
const vi = b.forwardRef( ({...t}, e) => {
    const {error: r, formItemId: n, formDescriptionId: s, formMessageId: i} = od();
    return y.jsx(I_, {
        ref: e,
        id: n,
        "aria-describedby": r ? `${s} ${i}` : `${s}`,
        "aria-invalid": !!r,
        ...t
    })
}
);
vi.displayName = "FormControl";
const a2 = b.forwardRef( ({className: t, ...e}, r) => {
    const {formDescriptionId: n} = od();
    return y.jsx("p", {
        ref: r,
        id: n,
        className: ye("text-sm text-muted-foreground", t),
        ...e
    })
}
);
a2.displayName = "FormDescription";
const yi = b.forwardRef( ({className: t, children: e, ...r}, n) => {
    const {error: s, formMessageId: i} = od()
      , o = s ? String((s == null ? void 0 : s.message) ?? "") : e;
    return o ? y.jsx("p", {
        ref: n,
        id: i,
        className: ye("text-sm font-medium text-destructive", t),
        ...r,
        children: o
    }) : null
}
);
yi.displayName = "FormMessage";
function l2() {
    const [,t] = Zs()
      , {toast: e} = ko()
      , {user: r} = rd()
      , [n,s] = b.useState(null)
      , [i,o] = b.useState(null)
      , [a,l] = b.useState(!1)
      , u = qI({
        resolver: ZI(i2),
        defaultValues: {
            name: "",
            location: "",
            photo_url: "",
            water_frequency_days: 7,
            last_watered_date: new Date().toISOString(),
            notes: ""
        }
    })
      , c = g => {
        var w;
        const h = (w = g.target.files) == null ? void 0 : w[0];
        if (h) {
            if (h.size > 5 * 1024 * 1024) {
                e({
                    title: "File too large",
                    description: "Photo must be less than 5MB",
                    variant: "destructive"
                });
                return
            }
            s(h);
            const v = new FileReader;
            v.onloadend = () => {
                o(v.result)
            }
            ,
            v.readAsDataURL(h)
        }
    }
      , d = async g => {
        if (!r)
            throw new Error("User not authenticated");
        const h = g.name.split(".").pop()
          , w = `${r.id}/${Date.now()}.${h}`
          , {error: v} = await Ft.storage.from("plant-photos").upload(w, g);
        if (v)
            throw v;
        const {data: m} = Ft.storage.from("plant-photos").getPublicUrl(w);
        return m.publicUrl
    }
      , f = ec({
        mutationFn: async g => {
            if (!r)
                throw new Error("User not authenticated");
            const {data: h, error: w} = await Ft.from("plants").insert([{
                ...g,
                user_id: r.id
            }]).select().single();
            if (w)
                throw w;
            return h
        }
        ,
        onSuccess: () => {
            e({
                title: "Plant added!",
                description: "Your new plant has been added successfully."
            }),
            Nr.invalidateQueries({
                queryKey: ["/api/plants"]
            }),
            t("/")
        }
        ,
        onError: g => {
            e({
                title: "Error",
                description: g.message,
                variant: "destructive"
            })
        }
    })
      , p = async g => {
        if (n && !g.photo_url) {
            l(!0);
            try {
                const h = await d(n);
                g.photo_url = h,
                f.mutate(g)
            } catch (h) {
                e({
                    title: "Upload failed",
                    description: h.message,
                    variant: "destructive"
                })
            } finally {
                l(!1)
            }
        } else
            f.mutate(g)
    }
    ;
    return y.jsxs("div", {
        className: "p-4 pb-24 max-w-2xl mx-auto",
        children: [y.jsxs(mr, {
            variant: "ghost",
            onClick: () => t("/"),
            className: "mb-4",
            "data-testid": "button-back",
            children: [y.jsx(cb, {
                className: "w-4 h-4 mr-2"
            }), "Back"]
        }), y.jsxs(ls, {
            children: [y.jsx(gl, {
                children: y.jsx(vl, {
                    className: "text-2xl",
                    children: "Add New Plant"
                })
            }), y.jsx(us, {
                children: y.jsx(o2, {
                    ...u,
                    children: y.jsxs("form", {
                        onSubmit: u.handleSubmit(p),
                        className: "space-y-4",
                        children: [y.jsx(Zo, {
                            control: u.control,
                            name: "name",
                            render: ({field: g}) => y.jsxs(mi, {
                                children: [y.jsx(gi, {
                                    children: "Plant Name"
                                }), y.jsx(vi, {
                                    children: y.jsx(zi, {
                                        placeholder: "e.g., Monstera Deliciosa",
                                        ...g,
                                        "data-testid": "input-plant-name"
                                    })
                                }), y.jsx(yi, {})]
                            })
                        }), y.jsx(Zo, {
                            control: u.control,
                            name: "location",
                            render: ({field: g}) => y.jsxs(mi, {
                                children: [y.jsx(gi, {
                                    children: "Location"
                                }), y.jsx(vi, {
                                    children: y.jsx(zi, {
                                        placeholder: "e.g., Living Room",
                                        ...g,
                                        "data-testid": "input-location"
                                    })
                                }), y.jsx(yi, {})]
                            })
                        }), y.jsx(Zo, {
                            control: u.control,
                            name: "photo_url",
                            render: ({field: g}) => y.jsxs(mi, {
                                children: [y.jsx(gi, {
                                    children: "Plant Photo"
                                }), y.jsx(vi, {
                                    children: y.jsx("div", {
                                        className: "space-y-3",
                                        children: i ? y.jsxs("div", {
                                            className: "relative w-full bg-muted rounded-lg overflow-hidden",
                                            children: [y.jsx("img", {
                                                src: i,
                                                alt: "Plant preview",
                                                className: "w-full h-48 object-cover",
                                                "data-testid": "img-plant-preview"
                                            }), y.jsx("button", {
                                                type: "button",
                                                onClick: () => {
                                                    s(null),
                                                    o(null),
                                                    g.onChange("")
                                                }
                                                ,
                                                className: "absolute top-2 right-2 bg-destructive text-destructive-foreground rounded-full p-1 hover:bg-destructive/90",
                                                "data-testid": "button-remove-photo",
                                                children: y.jsx(mb, {
                                                    className: "w-4 h-4"
                                                })
                                            })]
                                        }) : y.jsxs("label", {
                                            className: "flex flex-col items-center justify-center w-full h-32 border-2 border-dashed border-muted-foreground rounded-lg cursor-pointer hover:bg-muted transition-colors",
                                            "data-testid": "label-photo-upload",
                                            children: [y.jsxs("div", {
                                                className: "flex flex-col items-center justify-center pt-5 pb-6",
                                                children: [y.jsx(EO, {
                                                    className: "w-8 h-8 text-muted-foreground mb-2"
                                                }), y.jsx("p", {
                                                    className: "text-sm text-muted-foreground",
                                                    children: "Click to upload photo"
                                                }), y.jsx("p", {
                                                    className: "text-xs text-muted-foreground",
                                                    children: "PNG, JPG up to 5MB"
                                                })]
                                            }), y.jsx("input", {
                                                type: "file",
                                                accept: "image/*",
                                                onChange: c,
                                                className: "hidden",
                                                "data-testid": "input-photo-file"
                                            })]
                                        })
                                    })
                                }), y.jsx(yi, {})]
                            })
                        }), y.jsx(Zo, {
                            control: u.control,
                            name: "water_frequency_days",
                            render: ({field: g}) => y.jsxs(mi, {
                                children: [y.jsx(gi, {
                                    children: "Watering Frequency (days)"
                                }), y.jsx(vi, {
                                    children: y.jsx(zi, {
                                        type: "number",
                                        min: "1",
                                        ...g,
                                        onChange: h => g.onChange(parseInt(h.target.value)),
                                        "data-testid": "input-frequency"
                                    })
                                }), y.jsx(yi, {})]
                            })
                        }), y.jsx(Zo, {
                            control: u.control,
                            name: "notes",
                            render: ({field: g}) => y.jsxs(mi, {
                                children: [y.jsx(gi, {
                                    children: "Notes (Optional)"
                                }), y.jsx(vi, {
                                    children: y.jsx($S, {
                                        placeholder: "Care instructions, observations, etc.",
                                        ...g,
                                        "data-testid": "input-notes"
                                    })
                                }), y.jsx(yi, {})]
                            })
                        }), y.jsx(mr, {
                            type: "submit",
                            className: "w-full",
                            disabled: f.isPending || a || !n,
                            "data-testid": "button-submit-plant",
                            children: a ? "Uploading Photo..." : f.isPending ? "Adding Plant..." : "Add Plant"
                        })]
                    })
                })
            })]
        })]
    })
}
var af = "focusScope.autoFocusOnMount"
  , lf = "focusScope.autoFocusOnUnmount"
  , Ey = {
    bubbles: !1,
    cancelable: !0
}
  , u2 = "FocusScope"
  , VS = b.forwardRef( (t, e) => {
    const {loop: r=!1, trapped: n=!1, onMountAutoFocus: s, onUnmountAutoFocus: i, ...o} = t
      , [a,l] = b.useState(null)
      , u = rr(s)
      , c = rr(i)
      , d = b.useRef(null)
      , f = st(e, h => l(h))
      , p = b.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    b.useEffect( () => {
        if (n) {
            let h = function(_) {
                if (p.paused || !a)
                    return;
                const x = _.target;
                a.contains(x) ? d.current = x : bn(d.current, {
                    select: !0
                })
            }
              , w = function(_) {
                if (p.paused || !a)
                    return;
                const x = _.relatedTarget;
                x !== null && (a.contains(x) || bn(d.current, {
                    select: !0
                }))
            }
              , v = function(_) {
                if (document.activeElement === document.body)
                    for (const k of _)
                        k.removedNodes.length > 0 && bn(a)
            };
            document.addEventListener("focusin", h),
            document.addEventListener("focusout", w);
            const m = new MutationObserver(v);
            return a && m.observe(a, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", h),
                document.removeEventListener("focusout", w),
                m.disconnect()
            }
        }
    }
    , [n, a, p.paused]),
    b.useEffect( () => {
        if (a) {
            Cy.add(p);
            const h = document.activeElement;
            if (!a.contains(h)) {
                const v = new CustomEvent(af,Ey);
                a.addEventListener(af, u),
                a.dispatchEvent(v),
                v.defaultPrevented || (c2(m2(BS(a)), {
                    select: !0
                }),
                document.activeElement === h && bn(a))
            }
            return () => {
                a.removeEventListener(af, u),
                setTimeout( () => {
                    const v = new CustomEvent(lf,Ey);
                    a.addEventListener(lf, c),
                    a.dispatchEvent(v),
                    v.defaultPrevented || bn(h ?? document.body, {
                        select: !0
                    }),
                    a.removeEventListener(lf, c),
                    Cy.remove(p)
                }
                , 0)
            }
        }
    }
    , [a, u, c, p]);
    const g = b.useCallback(h => {
        if (!r && !n || p.paused)
            return;
        const w = h.key === "Tab" && !h.altKey && !h.ctrlKey && !h.metaKey
          , v = document.activeElement;
        if (w && v) {
            const m = h.currentTarget
              , [_,x] = d2(m);
            _ && x ? !h.shiftKey && v === x ? (h.preventDefault(),
            r && bn(_, {
                select: !0
            })) : h.shiftKey && v === _ && (h.preventDefault(),
            r && bn(x, {
                select: !0
            })) : v === m && h.preventDefault()
        }
    }
    , [r, n, p.paused]);
    return y.jsx(Be.div, {
        tabIndex: -1,
        ...o,
        ref: f,
        onKeyDown: g
    })
}
);
VS.displayName = u2;
function c2(t, {select: e=!1}={}) {
    const r = document.activeElement;
    for (const n of t)
        if (bn(n, {
            select: e
        }),
        document.activeElement !== r)
            return
}
function d2(t) {
    const e = BS(t)
      , r = ky(e, t)
      , n = ky(e.reverse(), t);
    return [r, n]
}
function BS(t) {
    const e = []
      , r = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: n => {
            const s = n.tagName === "INPUT" && n.type === "hidden";
            return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; r.nextNode(); )
        e.push(r.currentNode);
    return e
}
function ky(t, e) {
    for (const r of t)
        if (!f2(r, {
            upTo: e
        }))
            return r
}
function f2(t, {upTo: e}) {
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    for (; t; ) {
        if (e !== void 0 && t === e)
            return !1;
        if (getComputedStyle(t).display === "none")
            return !0;
        t = t.parentElement
    }
    return !1
}
function h2(t) {
    return t instanceof HTMLInputElement && "select"in t
}
function bn(t, {select: e=!1}={}) {
    if (t && t.focus) {
        const r = document.activeElement;
        t.focus({
            preventScroll: !0
        }),
        t !== r && h2(t) && e && t.select()
    }
}
var Cy = p2();
function p2() {
    let t = [];
    return {
        add(e) {
            const r = t[0];
            e !== r && (r == null || r.pause()),
            t = Ty(t, e),
            t.unshift(e)
        },
        remove(e) {
            var r;
            t = Ty(t, e),
            (r = t[0]) == null || r.resume()
        }
    }
}
function Ty(t, e) {
    const r = [...t]
      , n = r.indexOf(e);
    return n !== -1 && r.splice(n, 1),
    r
}
function m2(t) {
    return t.filter(e => e.tagName !== "A")
}
var uf = 0;
function g2() {
    b.useEffect( () => {
        const t = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", t[0] ?? Oy()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? Oy()),
        uf++,
        () => {
            uf === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()),
            uf--
        }
    }
    , [])
}
function Oy() {
    const t = document.createElement("span");
    return t.setAttribute("data-radix-focus-guard", ""),
    t.tabIndex = 0,
    t.style.outline = "none",
    t.style.opacity = "0",
    t.style.position = "fixed",
    t.style.pointerEvents = "none",
    t
}
var Cu = "right-scroll-bar-position"
  , Tu = "width-before-scroll-bar"
  , v2 = "with-scroll-bars-hidden"
  , y2 = "--removed-body-scroll-bar-size";
function cf(t, e) {
    return typeof t == "function" ? t(e) : t && (t.current = e),
    t
}
function w2(t, e) {
    var r = b.useState(function() {
        return {
            value: t,
            callback: e,
            facade: {
                get current() {
                    return r.value
                },
                set current(n) {
                    var s = r.value;
                    s !== n && (r.value = n,
                    r.callback(n, s))
                }
            }
        }
    })[0];
    return r.callback = e,
    r.facade
}
var _2 = typeof window < "u" ? b.useLayoutEffect : b.useEffect
  , Py = new WeakMap;
function b2(t, e) {
    var r = w2(null, function(n) {
        return t.forEach(function(s) {
            return cf(s, n)
        })
    });
    return _2(function() {
        var n = Py.get(r);
        if (n) {
            var s = new Set(n)
              , i = new Set(t)
              , o = r.current;
            s.forEach(function(a) {
                i.has(a) || cf(a, null)
            }),
            i.forEach(function(a) {
                s.has(a) || cf(a, o)
            })
        }
        Py.set(r, t)
    }, [t]),
    r
}
function x2(t) {
    return t
}
function S2(t, e) {
    e === void 0 && (e = x2);
    var r = []
      , n = !1
      , s = {
        read: function() {
            if (n)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return r.length ? r[r.length - 1] : t
        },
        useMedium: function(i) {
            var o = e(i, n);
            return r.push(o),
            function() {
                r = r.filter(function(a) {
                    return a !== o
                })
            }
        },
        assignSyncMedium: function(i) {
            for (n = !0; r.length; ) {
                var o = r;
                r = [],
                o.forEach(i)
            }
            r = {
                push: function(a) {
                    return i(a)
                },
                filter: function() {
                    return r
                }
            }
        },
        assignMedium: function(i) {
            n = !0;
            var o = [];
            if (r.length) {
                var a = r;
                r = [],
                a.forEach(i),
                o = r
            }
            var l = function() {
                var c = o;
                o = [],
                c.forEach(i)
            }
              , u = function() {
                return Promise.resolve().then(l)
            };
            u(),
            r = {
                push: function(c) {
                    o.push(c),
                    u()
                },
                filter: function(c) {
                    return o = o.filter(c),
                    r
                }
            }
        }
    };
    return s
}
function E2(t) {
    t === void 0 && (t = {});
    var e = S2(null);
    return e.options = Yt({
        async: !0,
        ssr: !1
    }, t),
    e
}
var zS = function(t) {
    var e = t.sideCar
      , r = os(t, ["sideCar"]);
    if (!e)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var n = e.read();
    if (!n)
        throw new Error("Sidecar medium not found");
    return b.createElement(n, Yt({}, r))
};
zS.isSideCarExport = !0;
function k2(t, e) {
    return t.useMedium(e),
    zS
}
var WS = E2()
  , df = function() {}
  , ad = b.forwardRef(function(t, e) {
    var r = b.useRef(null)
      , n = b.useState({
        onScrollCapture: df,
        onWheelCapture: df,
        onTouchMoveCapture: df
    })
      , s = n[0]
      , i = n[1]
      , o = t.forwardProps
      , a = t.children
      , l = t.className
      , u = t.removeScrollBar
      , c = t.enabled
      , d = t.shards
      , f = t.sideCar
      , p = t.noIsolation
      , g = t.inert
      , h = t.allowPinchZoom
      , w = t.as
      , v = w === void 0 ? "div" : w
      , m = t.gapMode
      , _ = os(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , x = f
      , k = b2([r, e])
      , T = Yt(Yt({}, _), s);
    return b.createElement(b.Fragment, null, c && b.createElement(x, {
        sideCar: WS,
        removeScrollBar: u,
        shards: d,
        noIsolation: p,
        inert: g,
        setCallbacks: i,
        allowPinchZoom: !!h,
        lockRef: r,
        gapMode: m
    }), o ? b.cloneElement(b.Children.only(a), Yt(Yt({}, T), {
        ref: k
    })) : b.createElement(v, Yt({}, T, {
        className: l,
        ref: k
    }), a))
});
ad.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
ad.classNames = {
    fullWidth: Tu,
    zeroRight: Cu
};
var C2 = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function T2() {
    if (!document)
        return null;
    var t = document.createElement("style");
    t.type = "text/css";
    var e = C2();
    return e && t.setAttribute("nonce", e),
    t
}
function O2(t, e) {
    t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}
function P2(t) {
    var e = document.head || document.getElementsByTagName("head")[0];
    e.appendChild(t)
}
var R2 = function() {
    var t = 0
      , e = null;
    return {
        add: function(r) {
            t == 0 && (e = T2()) && (O2(e, r),
            P2(e)),
            t++
        },
        remove: function() {
            t--,
            !t && e && (e.parentNode && e.parentNode.removeChild(e),
            e = null)
        }
    }
}
  , A2 = function() {
    var t = R2();
    return function(e, r) {
        b.useEffect(function() {
            return t.add(e),
            function() {
                t.remove()
            }
        }, [e && r])
    }
}
  , HS = function() {
    var t = A2()
      , e = function(r) {
        var n = r.styles
          , s = r.dynamic;
        return t(n, s),
        null
    };
    return e
}
  , j2 = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , ff = function(t) {
    return parseInt(t || "", 10) || 0
}
  , N2 = function(t) {
    var e = window.getComputedStyle(document.body)
      , r = e[t === "padding" ? "paddingLeft" : "marginLeft"]
      , n = e[t === "padding" ? "paddingTop" : "marginTop"]
      , s = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [ff(r), ff(n), ff(s)]
}
  , I2 = function(t) {
    if (t === void 0 && (t = "margin"),
    typeof window > "u")
        return j2;
    var e = N2(t)
      , r = document.documentElement.clientWidth
      , n = window.innerWidth;
    return {
        left: e[0],
        top: e[1],
        right: e[2],
        gap: Math.max(0, n - r + e[2] - e[0])
    }
}
  , D2 = HS()
  , Hi = "data-scroll-locked"
  , M2 = function(t, e, r, n) {
    var s = t.left
      , i = t.top
      , o = t.right
      , a = t.gap;
    return r === void 0 && (r = "margin"),
    `
  .`.concat(v2, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(a, "px ").concat(n, `;
  }
  body[`).concat(Hi, `] {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(n, ";"), r === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(n, `;
    `), r === "padding" && "padding-right: ".concat(a, "px ").concat(n, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Cu, ` {
    right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Tu, ` {
    margin-right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Cu, " .").concat(Cu, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(Tu, " .").concat(Tu, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body[`).concat(Hi, `] {
    `).concat(y2, ": ").concat(a, `px;
  }
`)
}
  , Ry = function() {
    var t = parseInt(document.body.getAttribute(Hi) || "0", 10);
    return isFinite(t) ? t : 0
}
  , L2 = function() {
    b.useEffect(function() {
        return document.body.setAttribute(Hi, (Ry() + 1).toString()),
        function() {
            var t = Ry() - 1;
            t <= 0 ? document.body.removeAttribute(Hi) : document.body.setAttribute(Hi, t.toString())
        }
    }, [])
}
  , $2 = function(t) {
    var e = t.noRelative
      , r = t.noImportant
      , n = t.gapMode
      , s = n === void 0 ? "margin" : n;
    L2();
    var i = b.useMemo(function() {
        return I2(s)
    }, [s]);
    return b.createElement(D2, {
        styles: M2(i, !e, s, r ? "" : "!important")
    })
}
  , Qh = !1;
if (typeof window < "u")
    try {
        var nu = Object.defineProperty({}, "passive", {
            get: function() {
                return Qh = !0,
                !0
            }
        });
        window.addEventListener("test", nu, nu),
        window.removeEventListener("test", nu, nu)
    } catch {
        Qh = !1
    }
var ui = Qh ? {
    passive: !1
} : !1
  , F2 = function(t) {
    return t.tagName === "TEXTAREA"
}
  , qS = function(t, e) {
    if (!(t instanceof Element))
        return !1;
    var r = window.getComputedStyle(t);
    return r[e] !== "hidden" && !(r.overflowY === r.overflowX && !F2(t) && r[e] === "visible")
}
  , U2 = function(t) {
    return qS(t, "overflowY")
}
  , V2 = function(t) {
    return qS(t, "overflowX")
}
  , Ay = function(t, e) {
    var r = e.ownerDocument
      , n = e;
    do {
        typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
        var s = KS(t, n);
        if (s) {
            var i = GS(t, n)
              , o = i[1]
              , a = i[2];
            if (o > a)
                return !0
        }
        n = n.parentNode
    } while (n && n !== r.body);
    return !1
}
  , B2 = function(t) {
    var e = t.scrollTop
      , r = t.scrollHeight
      , n = t.clientHeight;
    return [e, r, n]
}
  , z2 = function(t) {
    var e = t.scrollLeft
      , r = t.scrollWidth
      , n = t.clientWidth;
    return [e, r, n]
}
  , KS = function(t, e) {
    return t === "v" ? U2(e) : V2(e)
}
  , GS = function(t, e) {
    return t === "v" ? B2(e) : z2(e)
}
  , W2 = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}
  , H2 = function(t, e, r, n, s) {
    var i = W2(t, window.getComputedStyle(e).direction)
      , o = i * n
      , a = r.target
      , l = e.contains(a)
      , u = !1
      , c = o > 0
      , d = 0
      , f = 0;
    do {
        var p = GS(t, a)
          , g = p[0]
          , h = p[1]
          , w = p[2]
          , v = h - w - i * g;
        (g || v) && KS(t, a) && (d += v,
        f += g),
        a instanceof ShadowRoot ? a = a.host : a = a.parentNode
    } while (!l && a !== document.body || l && (e.contains(a) || e === a));
    return (c && (Math.abs(d) < 1 || !s) || !c && (Math.abs(f) < 1 || !s)) && (u = !0),
    u
}
  , su = function(t) {
    return "changedTouches"in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}
  , jy = function(t) {
    return [t.deltaX, t.deltaY]
}
  , Ny = function(t) {
    return t && "current"in t ? t.current : t
}
  , q2 = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}
  , K2 = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}
  , G2 = 0
  , ci = [];
function Q2(t) {
    var e = b.useRef([])
      , r = b.useRef([0, 0])
      , n = b.useRef()
      , s = b.useState(G2++)[0]
      , i = b.useState(HS)[0]
      , o = b.useRef(t);
    b.useEffect(function() {
        o.current = t
    }, [t]),
    b.useEffect(function() {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(s));
            var h = dm([t.lockRef.current], (t.shards || []).map(Ny), !0).filter(Boolean);
            return h.forEach(function(w) {
                return w.classList.add("allow-interactivity-".concat(s))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(s)),
                h.forEach(function(w) {
                    return w.classList.remove("allow-interactivity-".concat(s))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var a = b.useCallback(function(h, w) {
        if ("touches"in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
            return !o.current.allowPinchZoom;
        var v = su(h), m = r.current, _ = "deltaX"in h ? h.deltaX : m[0] - v[0], x = "deltaY"in h ? h.deltaY : m[1] - v[1], k, T = h.target, C = Math.abs(_) > Math.abs(x) ? "h" : "v";
        if ("touches"in h && C === "h" && T.type === "range")
            return !1;
        var P = Ay(C, T);
        if (!P)
            return !0;
        if (P ? k = C : (k = C === "v" ? "h" : "v",
        P = Ay(C, T)),
        !P)
            return !1;
        if (!n.current && "changedTouches"in h && (_ || x) && (n.current = k),
        !k)
            return !0;
        var j = n.current || k;
        return H2(j, w, h, j === "h" ? _ : x, !0)
    }, [])
      , l = b.useCallback(function(h) {
        var w = h;
        if (!(!ci.length || ci[ci.length - 1] !== i)) {
            var v = "deltaY"in w ? jy(w) : su(w)
              , m = e.current.filter(function(k) {
                return k.name === w.type && (k.target === w.target || w.target === k.shadowParent) && q2(k.delta, v)
            })[0];
            if (m && m.should) {
                w.cancelable && w.preventDefault();
                return
            }
            if (!m) {
                var _ = (o.current.shards || []).map(Ny).filter(Boolean).filter(function(k) {
                    return k.contains(w.target)
                })
                  , x = _.length > 0 ? a(w, _[0]) : !o.current.noIsolation;
                x && w.cancelable && w.preventDefault()
            }
        }
    }, [])
      , u = b.useCallback(function(h, w, v, m) {
        var _ = {
            name: h,
            delta: w,
            target: v,
            should: m,
            shadowParent: Z2(v)
        };
        e.current.push(_),
        setTimeout(function() {
            e.current = e.current.filter(function(x) {
                return x !== _
            })
        }, 1)
    }, [])
      , c = b.useCallback(function(h) {
        r.current = su(h),
        n.current = void 0
    }, [])
      , d = b.useCallback(function(h) {
        u(h.type, jy(h), h.target, a(h, t.lockRef.current))
    }, [])
      , f = b.useCallback(function(h) {
        u(h.type, su(h), h.target, a(h, t.lockRef.current))
    }, []);
    b.useEffect(function() {
        return ci.push(i),
        t.setCallbacks({
            onScrollCapture: d,
            onWheelCapture: d,
            onTouchMoveCapture: f
        }),
        document.addEventListener("wheel", l, ui),
        document.addEventListener("touchmove", l, ui),
        document.addEventListener("touchstart", c, ui),
        function() {
            ci = ci.filter(function(h) {
                return h !== i
            }),
            document.removeEventListener("wheel", l, ui),
            document.removeEventListener("touchmove", l, ui),
            document.removeEventListener("touchstart", c, ui)
        }
    }, []);
    var p = t.removeScrollBar
      , g = t.inert;
    return b.createElement(b.Fragment, null, g ? b.createElement(i, {
        styles: K2(s)
    }) : null, p ? b.createElement($2, {
        gapMode: t.gapMode
    }) : null)
}
function Z2(t) {
    for (var e = null; t !== null; )
        t instanceof ShadowRoot && (e = t.host,
        t = t.host),
        t = t.parentNode;
    return e
}
const Y2 = k2(WS, Q2);
var QS = b.forwardRef(function(t, e) {
    return b.createElement(ad, Yt({}, t, {
        ref: e,
        sideCar: Y2
    }))
});
QS.classNames = ad.classNames;
var J2 = function(t) {
    if (typeof document > "u")
        return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
}
  , di = new WeakMap
  , iu = new WeakMap
  , ou = {}
  , hf = 0
  , ZS = function(t) {
    return t && (t.host || ZS(t.parentNode))
}
  , X2 = function(t, e) {
    return e.map(function(r) {
        if (t.contains(r))
            return r;
        var n = ZS(r);
        return n && t.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", t, ". Doing nothing"),
        null)
    }).filter(function(r) {
        return !!r
    })
}
  , eM = function(t, e, r, n) {
    var s = X2(e, Array.isArray(t) ? t : [t]);
    ou[r] || (ou[r] = new WeakMap);
    var i = ou[r]
      , o = []
      , a = new Set
      , l = new Set(s)
      , u = function(d) {
        !d || a.has(d) || (a.add(d),
        u(d.parentNode))
    };
    s.forEach(u);
    var c = function(d) {
        !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
            if (a.has(f))
                c(f);
            else
                try {
                    var p = f.getAttribute(n)
                      , g = p !== null && p !== "false"
                      , h = (di.get(f) || 0) + 1
                      , w = (i.get(f) || 0) + 1;
                    di.set(f, h),
                    i.set(f, w),
                    o.push(f),
                    h === 1 && g && iu.set(f, !0),
                    w === 1 && f.setAttribute(r, "true"),
                    g || f.setAttribute(n, "true")
                } catch (v) {
                    console.error("aria-hidden: cannot operate on ", f, v)
                }
        })
    };
    return c(e),
    a.clear(),
    hf++,
    function() {
        o.forEach(function(d) {
            var f = di.get(d) - 1
              , p = i.get(d) - 1;
            di.set(d, f),
            i.set(d, p),
            f || (iu.has(d) || d.removeAttribute(n),
            iu.delete(d)),
            p || d.removeAttribute(r)
        }),
        hf--,
        hf || (di = new WeakMap,
        di = new WeakMap,
        iu = new WeakMap,
        ou = {})
    }
}
  , tM = function(t, e, r) {
    r === void 0 && (r = "data-aria-hidden");
    var n = Array.from(Array.isArray(t) ? t : [t])
      , s = J2(t);
    return s ? (n.push.apply(n, Array.from(s.querySelectorAll("[aria-live]"))),
    eM(n, s, r, "aria-hidden")) : function() {
        return null
    }
}
  , Tm = "Dialog"
  , [YS,JS] = Co(Tm)
  , [rM,Er] = YS(Tm)
  , XS = t => {
    const {__scopeDialog: e, children: r, open: n, defaultOpen: s, onOpenChange: i, modal: o=!0} = t
      , a = b.useRef(null)
      , l = b.useRef(null)
      , [u=!1,c] = V_({
        prop: n,
        defaultProp: s,
        onChange: i
    });
    return y.jsx(rM, {
        scope: e,
        triggerRef: a,
        contentRef: l,
        contentId: Hd(),
        titleId: Hd(),
        descriptionId: Hd(),
        open: u,
        onOpenChange: c,
        onOpenToggle: b.useCallback( () => c(d => !d), [c]),
        modal: o,
        children: r
    })
}
;
XS.displayName = Tm;
var eE = "DialogTrigger"
  , tE = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, ...n} = t
      , s = Er(eE, r)
      , i = st(e, s.triggerRef);
    return y.jsx(Be.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": s.open,
        "aria-controls": s.contentId,
        "data-state": Rm(s.open),
        ...n,
        ref: i,
        onClick: Pe(t.onClick, s.onOpenToggle)
    })
}
);
tE.displayName = eE;
var Om = "DialogPortal"
  , [nM,rE] = YS(Om, {
    forceMount: void 0
})
  , nE = t => {
    const {__scopeDialog: e, forceMount: r, children: n, container: s} = t
      , i = Er(Om, e);
    return y.jsx(nM, {
        scope: e,
        forceMount: r,
        children: b.Children.map(n, o => y.jsx(To, {
            present: r || i.open,
            children: y.jsx(Zp, {
                asChild: !0,
                container: s,
                children: o
            })
        }))
    })
}
;
nE.displayName = Om;
var Cc = "DialogOverlay"
  , sE = b.forwardRef( (t, e) => {
    const r = rE(Cc, t.__scopeDialog)
      , {forceMount: n=r.forceMount, ...s} = t
      , i = Er(Cc, t.__scopeDialog);
    return i.modal ? y.jsx(To, {
        present: n || i.open,
        children: y.jsx(iM, {
            ...s,
            ref: e
        })
    }) : null
}
);
sE.displayName = Cc;
var sM = La("DialogOverlay.RemoveScroll")
  , iM = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, ...n} = t
      , s = Er(Cc, r);
    return y.jsx(QS, {
        as: sM,
        allowPinchZoom: !0,
        shards: [s.contentRef],
        children: y.jsx(Be.div, {
            "data-state": Rm(s.open),
            ...n,
            ref: e,
            style: {
                pointerEvents: "auto",
                ...n.style
            }
        })
    })
}
)
  , Ks = "DialogContent"
  , iE = b.forwardRef( (t, e) => {
    const r = rE(Ks, t.__scopeDialog)
      , {forceMount: n=r.forceMount, ...s} = t
      , i = Er(Ks, t.__scopeDialog);
    return y.jsx(To, {
        present: n || i.open,
        children: i.modal ? y.jsx(oM, {
            ...s,
            ref: e
        }) : y.jsx(aM, {
            ...s,
            ref: e
        })
    })
}
);
iE.displayName = Ks;
var oM = b.forwardRef( (t, e) => {
    const r = Er(Ks, t.__scopeDialog)
      , n = b.useRef(null)
      , s = st(e, r.contentRef, n);
    return b.useEffect( () => {
        const i = n.current;
        if (i)
            return tM(i)
    }
    , []),
    y.jsx(oE, {
        ...t,
        ref: s,
        trapFocus: r.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Pe(t.onCloseAutoFocus, i => {
            var o;
            i.preventDefault(),
            (o = r.triggerRef.current) == null || o.focus()
        }
        ),
        onPointerDownOutside: Pe(t.onPointerDownOutside, i => {
            const o = i.detail.originalEvent
              , a = o.button === 0 && o.ctrlKey === !0;
            (o.button === 2 || a) && i.preventDefault()
        }
        ),
        onFocusOutside: Pe(t.onFocusOutside, i => i.preventDefault())
    })
}
)
  , aM = b.forwardRef( (t, e) => {
    const r = Er(Ks, t.__scopeDialog)
      , n = b.useRef(!1)
      , s = b.useRef(!1);
    return y.jsx(oE, {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: i => {
            var o, a;
            (o = t.onCloseAutoFocus) == null || o.call(t, i),
            i.defaultPrevented || (n.current || (a = r.triggerRef.current) == null || a.focus(),
            i.preventDefault()),
            n.current = !1,
            s.current = !1
        }
        ,
        onInteractOutside: i => {
            var l, u;
            (l = t.onInteractOutside) == null || l.call(t, i),
            i.defaultPrevented || (n.current = !0,
            i.detail.originalEvent.type === "pointerdown" && (s.current = !0));
            const o = i.target;
            ((u = r.triggerRef.current) == null ? void 0 : u.contains(o)) && i.preventDefault(),
            i.detail.originalEvent.type === "focusin" && s.current && i.preventDefault()
        }
    })
}
)
  , oE = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, trapFocus: n, onOpenAutoFocus: s, onCloseAutoFocus: i, ...o} = t
      , a = Er(Ks, r)
      , l = b.useRef(null)
      , u = st(e, l);
    return g2(),
    y.jsxs(y.Fragment, {
        children: [y.jsx(VS, {
            asChild: !0,
            loop: !0,
            trapped: n,
            onMountAutoFocus: s,
            onUnmountAutoFocus: i,
            children: y.jsx(Wc, {
                role: "dialog",
                id: a.contentId,
                "aria-describedby": a.descriptionId,
                "aria-labelledby": a.titleId,
                "data-state": Rm(a.open),
                ...o,
                ref: u,
                onDismiss: () => a.onOpenChange(!1)
            })
        }), y.jsxs(y.Fragment, {
            children: [y.jsx(uM, {
                titleId: a.titleId
            }), y.jsx(dM, {
                contentRef: l,
                descriptionId: a.descriptionId
            })]
        })]
    })
}
)
  , Pm = "DialogTitle"
  , aE = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, ...n} = t
      , s = Er(Pm, r);
    return y.jsx(Be.h2, {
        id: s.titleId,
        ...n,
        ref: e
    })
}
);
aE.displayName = Pm;
var lE = "DialogDescription"
  , uE = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, ...n} = t
      , s = Er(lE, r);
    return y.jsx(Be.p, {
        id: s.descriptionId,
        ...n,
        ref: e
    })
}
);
uE.displayName = lE;
var cE = "DialogClose"
  , dE = b.forwardRef( (t, e) => {
    const {__scopeDialog: r, ...n} = t
      , s = Er(cE, r);
    return y.jsx(Be.button, {
        type: "button",
        ...n,
        ref: e,
        onClick: Pe(t.onClick, () => s.onOpenChange(!1))
    })
}
);
dE.displayName = cE;
function Rm(t) {
    return t ? "open" : "closed"
}
var fE = "DialogTitleWarning"
  , [lM,hE] = CT(fE, {
    contentName: Ks,
    titleName: Pm,
    docsSlug: "dialog"
})
  , uM = ({titleId: t}) => {
    const e = hE(fE)
      , r = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return b.useEffect( () => {
        t && (document.getElementById(t) || console.error(r))
    }
    , [r, t]),
    null
}
  , cM = "DialogDescriptionWarning"
  , dM = ({contentRef: t, descriptionId: e}) => {
    const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${hE(cM).contentName}}.`;
    return b.useEffect( () => {
        var i;
        const s = (i = t.current) == null ? void 0 : i.getAttribute("aria-describedby");
        e && s && (document.getElementById(e) || console.warn(n))
    }
    , [n, t, e]),
    null
}
  , fM = XS
  , hM = tE
  , pM = nE
  , mM = sE
  , gM = iE
  , vM = aE
  , yM = uE
  , pE = dE
  , mE = "AlertDialog"
  , [wM,ZM] = Co(mE, [JS])
  , hn = JS()
  , gE = t => {
    const {__scopeAlertDialog: e, ...r} = t
      , n = hn(e);
    return y.jsx(fM, {
        ...n,
        ...r,
        modal: !0
    })
}
;
gE.displayName = mE;
var _M = "AlertDialogTrigger"
  , vE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , s = hn(r);
    return y.jsx(hM, {
        ...s,
        ...n,
        ref: e
    })
}
);
vE.displayName = _M;
var bM = "AlertDialogPortal"
  , yE = t => {
    const {__scopeAlertDialog: e, ...r} = t
      , n = hn(e);
    return y.jsx(pM, {
        ...n,
        ...r
    })
}
;
yE.displayName = bM;
var xM = "AlertDialogOverlay"
  , wE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , s = hn(r);
    return y.jsx(mM, {
        ...s,
        ...n,
        ref: e
    })
}
);
wE.displayName = xM;
var qi = "AlertDialogContent"
  , [SM,EM] = wM(qi)
  , kM = M_("AlertDialogContent")
  , _E = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, children: n, ...s} = t
      , i = hn(r)
      , o = b.useRef(null)
      , a = st(e, o)
      , l = b.useRef(null);
    return y.jsx(lM, {
        contentName: qi,
        titleName: bE,
        docsSlug: "alert-dialog",
        children: y.jsx(SM, {
            scope: r,
            cancelRef: l,
            children: y.jsxs(gM, {
                role: "alertdialog",
                ...i,
                ...s,
                ref: a,
                onOpenAutoFocus: Pe(s.onOpenAutoFocus, u => {
                    var c;
                    u.preventDefault(),
                    (c = l.current) == null || c.focus({
                        preventScroll: !0
                    })
                }
                ),
                onPointerDownOutside: u => u.preventDefault(),
                onInteractOutside: u => u.preventDefault(),
                children: [y.jsx(kM, {
                    children: n
                }), y.jsx(TM, {
                    contentRef: o
                })]
            })
        })
    })
}
);
_E.displayName = qi;
var bE = "AlertDialogTitle"
  , xE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , s = hn(r);
    return y.jsx(vM, {
        ...s,
        ...n,
        ref: e
    })
}
);
xE.displayName = bE;
var SE = "AlertDialogDescription"
  , EE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , s = hn(r);
    return y.jsx(yM, {
        ...s,
        ...n,
        ref: e
    })
}
);
EE.displayName = SE;
var CM = "AlertDialogAction"
  , kE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , s = hn(r);
    return y.jsx(pE, {
        ...s,
        ...n,
        ref: e
    })
}
);
kE.displayName = CM;
var CE = "AlertDialogCancel"
  , TE = b.forwardRef( (t, e) => {
    const {__scopeAlertDialog: r, ...n} = t
      , {cancelRef: s} = EM(CE, r)
      , i = hn(r)
      , o = st(e, s);
    return y.jsx(pE, {
        ...i,
        ...n,
        ref: o
    })
}
);
TE.displayName = CE;
var TM = ({contentRef: t}) => {
    const e = `\`${qi}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${qi}\` by passing a \`${SE}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${qi}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
    return b.useEffect( () => {
        var n;
        document.getElementById((n = t.current) == null ? void 0 : n.getAttribute("aria-describedby")) || console.warn(e)
    }
    , [e, t]),
    null
}
  , OM = gE
  , PM = vE
  , RM = yE
  , OE = wE
  , PE = _E
  , RE = kE
  , AE = TE
  , jE = xE
  , NE = EE;
const IE = OM
  , DE = PM
  , AM = RM
  , ME = b.forwardRef( ({className: t, ...e}, r) => y.jsx(OE, {
    className: ye("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0", t),
    ...e,
    ref: r
}));
ME.displayName = OE.displayName;
const Am = b.forwardRef( ({className: t, ...e}, r) => y.jsxs(AM, {
    children: [y.jsx(ME, {}), y.jsx(PE, {
        ref: r,
        className: ye("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg", t),
        ...e
    })]
}));
Am.displayName = PE.displayName;
const jm = ({className: t, ...e}) => y.jsx("div", {
    className: ye("flex flex-col space-y-2 text-center sm:text-left", t),
    ...e
});
jm.displayName = "AlertDialogHeader";
const Nm = ({className: t, ...e}) => y.jsx("div", {
    className: ye("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", t),
    ...e
});
Nm.displayName = "AlertDialogFooter";
const Im = b.forwardRef( ({className: t, ...e}, r) => y.jsx(jE, {
    ref: r,
    className: ye("text-lg font-semibold", t),
    ...e
}));
Im.displayName = jE.displayName;
const Dm = b.forwardRef( ({className: t, ...e}, r) => y.jsx(NE, {
    ref: r,
    className: ye("text-sm text-muted-foreground", t),
    ...e
}));
Dm.displayName = NE.displayName;
const Mm = b.forwardRef( ({className: t, ...e}, r) => y.jsx(RE, {
    ref: r,
    className: ye(_m(), t),
    ...e
}));
Mm.displayName = RE.displayName;
const Lm = b.forwardRef( ({className: t, ...e}, r) => y.jsx(AE, {
    ref: r,
    className: ye(_m({
        variant: "outline"
    }), "mt-2 sm:mt-0", t),
    ...e
}));
Lm.displayName = AE.displayName;
function jM() {
    const {id: t} = m_()
      , [,e] = Zs()
      , {toast: r} = ko()
      , {data: n, isLoading: s} = j_({
        queryKey: ["/api/plants", t],
        queryFn: async () => {
            const {data: l, error: u} = await Ft.from("plants").select("*").eq("id", t).single();
            if (u)
                throw u;
            return l
        }
    })
      , i = ec({
        mutationFn: async () => {
            const {error: l} = await Ft.from("plants").delete().eq("id", t);
            if (l)
                throw l
        }
        ,
        onSuccess: () => {
            r({
                title: "Plant deleted",
                description: "The plant has been removed from your collection."
            }),
            Nr.invalidateQueries({
                queryKey: ["/api/plants"]
            }),
            e("/")
        }
        ,
        onError: l => {
            r({
                title: "Error",
                description: l.message,
                variant: "destructive"
            })
        }
    })
      , o = ec({
        mutationFn: async () => {
            const {data: l, error: u} = await Ft.from("plants").update({
                last_watered_date: new Date().toISOString()
            }).eq("id", t).select().single();
            if (u)
                throw u;
            return l
        }
        ,
        onSuccess: () => {
            r({
                title: "Plant watered!",
                description: "Watering date updated successfully"
            }),
            Nr.invalidateQueries({
                queryKey: ["/api/plants", t]
            }),
            Nr.invalidateQueries({
                queryKey: ["/api/plants"]
            })
        }
        ,
        onError: l => {
            r({
                title: "Error",
                description: l.message,
                variant: "destructive"
            })
        }
    });
    if (s)
        return y.jsxs("div", {
            className: "p-4 pb-24 max-w-2xl mx-auto space-y-4",
            children: [y.jsx(Jr, {
                className: "h-10 w-20"
            }), y.jsx(Jr, {
                className: "aspect-video w-full rounded-lg"
            }), y.jsx(Jr, {
                className: "h-8 w-3/4"
            }), y.jsx(Jr, {
                className: "h-40 w-full"
            })]
        });
    if (!n)
        return y.jsxs("div", {
            className: "p-4 text-center",
            children: [y.jsx("p", {
                children: "Plant not found"
            }), y.jsx(mr, {
                onClick: () => e("/"),
                className: "mt-4",
                children: "Go Home"
            })]
        });
    const a = Ai(new Date(n.last_watered_date), n.water_frequency_days);
    return y.jsxs("div", {
        className: "p-4 pb-24 max-w-2xl mx-auto space-y-4",
        children: [y.jsxs(mr, {
            variant: "ghost",
            onClick: () => e("/"),
            "data-testid": "button-back",
            children: [y.jsx(cb, {
                className: "w-4 h-4 mr-2"
            }), "Back"]
        }), y.jsxs(ls, {
            className: "overflow-hidden",
            children: [y.jsx("div", {
                className: "aspect-video w-full overflow-hidden bg-muted",
                children: y.jsx("img", {
                    src: n.photo_url,
                    alt: n.name,
                    className: "w-full h-full object-cover",
                    "data-testid": "img-plant-photo"
                })
            }), y.jsxs(gl, {
                children: [y.jsx(vl, {
                    className: "text-3xl",
                    "data-testid": "text-plant-name",
                    children: n.name
                }), y.jsxs("div", {
                    className: "flex flex-wrap gap-2 pt-2",
                    children: [y.jsxs(cc, {
                        variant: "secondary",
                        children: [y.jsx(hb, {
                            className: "w-3 h-3 mr-1"
                        }), n.location]
                    }), y.jsxs(cc, {
                        variant: "outline",
                        children: ["Every ", n.water_frequency_days, " ", n.water_frequency_days === 1 ? "day" : "days"]
                    })]
                })]
            }), y.jsxs(us, {
                className: "space-y-6",
                children: [y.jsxs("div", {
                    className: "space-y-3",
                    children: [y.jsxs("div", {
                        className: "flex items-start gap-3 p-3 bg-muted/50 rounded-lg",
                        children: [y.jsx(db, {
                            className: "w-5 h-5 text-primary mt-0.5"
                        }), y.jsxs("div", {
                            className: "flex-1",
                            children: [y.jsx("p", {
                                className: "text-sm font-medium",
                                children: "Last Watered"
                            }), y.jsxs("p", {
                                className: "text-sm text-muted-foreground",
                                "data-testid": "text-last-watered",
                                children: [ay(new Date(n.last_watered_date), "PPP"), y.jsxs("span", {
                                    className: "ml-2",
                                    children: ["(", Bh(new Date(n.last_watered_date), {
                                        addSuffix: !0
                                    }), ")"]
                                })]
                            })]
                        })]
                    }), y.jsxs("div", {
                        className: "flex items-start gap-3 p-3 bg-muted/50 rounded-lg",
                        children: [y.jsx(vO, {
                            className: "w-5 h-5 text-primary mt-0.5"
                        }), y.jsxs("div", {
                            className: "flex-1",
                            children: [y.jsx("p", {
                                className: "text-sm font-medium",
                                children: "Next Watering"
                            }), y.jsxs("p", {
                                className: "text-sm text-muted-foreground",
                                "data-testid": "text-next-watering",
                                children: [ay(a, "PPP"), y.jsxs("span", {
                                    className: "ml-2",
                                    children: ["(", Bh(a, {
                                        addSuffix: !0
                                    }), ")"]
                                })]
                            })]
                        })]
                    })]
                }), n.notes && y.jsxs("div", {
                    className: "space-y-2",
                    children: [y.jsx("h3", {
                        className: "font-medium",
                        children: "Notes"
                    }), y.jsx("p", {
                        className: "text-sm text-muted-foreground whitespace-pre-wrap",
                        "data-testid": "text-notes",
                        children: n.notes
                    })]
                }), y.jsxs("div", {
                    className: "flex gap-3",
                    children: [y.jsx(mr, {
                        onClick: () => o.mutate(),
                        disabled: o.isPending,
                        className: "flex-1",
                        "data-testid": "button-water-plant",
                        children: o.isPending ? "Watering..." : "Water Plant"
                    }), y.jsxs(IE, {
                        children: [y.jsx(DE, {
                            asChild: !0,
                            children: y.jsx(mr, {
                                variant: "destructive",
                                size: "icon",
                                "data-testid": "button-delete-plant",
                                children: y.jsx(SO, {
                                    className: "w-4 h-4"
                                })
                            })
                        }), y.jsxs(Am, {
                            children: [y.jsxs(jm, {
                                children: [y.jsx(Im, {
                                    children: "Delete this plant?"
                                }), y.jsxs(Dm, {
                                    children: ["This action cannot be undone. This will permanently delete ", n.name, " from your collection."]
                                })]
                            }), y.jsxs(Nm, {
                                children: [y.jsx(Lm, {
                                    "data-testid": "button-cancel-delete",
                                    children: "Cancel"
                                }), y.jsx(Mm, {
                                    onClick: () => i.mutate(),
                                    className: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                                    "data-testid": "button-confirm-delete",
                                    children: "Delete"
                                })]
                            })]
                        })]
                    })]
                })]
            })]
        })]
    })
}
function NM() {
    const {user: t, signOut: e} = rd()
      , {toast: r} = ko()
      , [,n] = Zs()
      , s = async () => {
        try {
            await e(),
            r({
                title: "Signed out",
                description: "You have been signed out successfully."
            }),
            n("/login")
        } catch (i) {
            r({
                title: "Error",
                description: i.message,
                variant: "destructive"
            })
        }
    }
    ;
    return y.jsx("div", {
        className: "p-4 pb-24 max-w-2xl mx-auto space-y-4",
        children: y.jsxs(ls, {
            children: [y.jsxs(gl, {
                className: "text-center space-y-4",
                children: [y.jsx("div", {
                    className: "flex justify-center",
                    children: y.jsx("div", {
                        className: "w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center",
                        children: y.jsx(pb, {
                            className: "w-10 h-10 text-primary"
                        })
                    })
                }), y.jsxs("div", {
                    children: [y.jsx(vl, {
                        className: "text-2xl",
                        children: "Profile"
                    }), y.jsx(bm, {
                        className: "mt-2",
                        "data-testid": "text-user-email",
                        children: t == null ? void 0 : t.email
                    })]
                })]
            }), y.jsxs(us, {
                className: "space-y-4",
                children: [y.jsxs("div", {
                    className: "space-y-2 p-4 bg-muted/50 rounded-lg",
                    children: [y.jsxs("div", {
                        className: "flex items-center gap-2 text-sm text-muted-foreground",
                        children: [y.jsx(fb, {
                            className: "w-4 h-4 text-primary"
                        }), y.jsx("span", {
                            children: "GreenThumb Plant Care"
                        })]
                    }), y.jsx("p", {
                        className: "text-sm text-muted-foreground",
                        children: "Track your plants' watering schedules and keep them healthy and thriving."
                    })]
                }), y.jsxs(IE, {
                    children: [y.jsx(DE, {
                        asChild: !0,
                        children: y.jsxs(mr, {
                            variant: "destructive",
                            className: "w-full",
                            "data-testid": "button-sign-out",
                            children: [y.jsx(_O, {
                                className: "w-4 h-4 mr-2"
                            }), "Sign Out"]
                        })
                    }), y.jsxs(Am, {
                        children: [y.jsxs(jm, {
                            children: [y.jsx(Im, {
                                children: "Sign out?"
                            }), y.jsx(Dm, {
                                children: "Are you sure you want to sign out? You'll need to sign in again to access your plants."
                            })]
                        }), y.jsxs(Nm, {
                            children: [y.jsx(Lm, {
                                "data-testid": "button-cancel-sign-out",
                                children: "Cancel"
                            }), y.jsx(Mm, {
                                onClick: s,
                                className: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
                                "data-testid": "button-confirm-sign-out",
                                children: "Sign Out"
                            })]
                        })]
                    })]
                })]
            })]
        })
    })
}
function IM() {
    return y.jsx("div", {
        className: "min-h-screen w-full flex items-center justify-center bg-gray-50",
        children: y.jsx(ls, {
            className: "w-full max-w-md mx-4",
            children: y.jsxs(us, {
                className: "pt-6",
                children: [y.jsxs("div", {
                    className: "flex mb-4 gap-2",
                    children: [y.jsx(yO, {
                        className: "h-8 w-8 text-red-500"
                    }), y.jsx("h1", {
                        className: "text-2xl font-bold text-gray-900",
                        children: "404 Page Not Found"
                    })]
                }), y.jsx("p", {
                    className: "mt-4 text-sm text-gray-600",
                    children: "Did you forget to add the page to the router?"
                })]
            })
        })
    })
}
function au({children: t}) {
    return y.jsxs("div", {
        className: "min-h-screen bg-muted/30",
        children: [y.jsx("header", {
            className: "bg-card border-b border-border p-4 sticky top-0 z-40 lg:block hidden",
            children: y.jsx("div", {
                className: "max-w-7xl mx-auto",
                children: y.jsx("h1", {
                    className: "text-2xl font-medium text-primary",
                    children: "GreenThumb"
                })
            })
        }), y.jsx("main", {
            className: "max-w-7xl mx-auto",
            children: t
        }), y.jsx(sN, {})]
    })
}
function DM() {
    return y.jsxs(VC, {
        children: [y.jsx(ti, {
            path: "/login",
            component: lN
        }), y.jsx(ti, {
            path: "/",
            children: y.jsx(tu, {
                children: y.jsx(au, {
                    children: y.jsx(kI, {})
                })
            })
        }), y.jsx(ti, {
            path: "/add-plant",
            children: y.jsx(tu, {
                children: y.jsx(au, {
                    children: y.jsx(l2, {})
                })
            })
        }), y.jsx(ti, {
            path: "/plant/:id",
            children: y.jsx(tu, {
                children: y.jsx(au, {
                    children: y.jsx(jM, {})
                })
            })
        }), y.jsx(ti, {
            path: "/profile",
            children: y.jsx(tu, {
                children: y.jsx(au, {
                    children: y.jsx(NM, {})
                })
            })
        }), y.jsx(ti, {
            component: IM
        })]
    })
}
function MM() {
    return y.jsx(aT, {
        client: Nr,
        children: y.jsx(IR, {
            children: y.jsxs(nN, {
                children: [y.jsx(oP, {}), y.jsx(DM, {})]
            })
        })
    })
}
i_(document.getElementById("root")).render(y.jsx(MM, {}));
